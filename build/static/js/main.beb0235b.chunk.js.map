{"version":3,"sources":["mazeAlgorithims/verticalMaze.js","mazeAlgorithims/HorizontalMaze.js","mazeAlgorithims/recursiveDivisionMaze.js","components/PathFindingVisualizer/Node/Node.jsx","components/PathFindingVisualizer/Visualizer.jsx","mazeAlgorithims/randomMaze.js","data/alg-data.js","media/right-arrow.png","media/dart-board.png","media/stop.png","components/navComponents/Navbar.jsx","components/navComponents/sideNav.jsx","data/item-data.js","workers/pathGrabWorker.js","workers/dijkstraWorker.js","workers/aStarWorker.js","workers/greedyBestFirstSearchWorker.js","workers/breadthFirstSearchWorker.js","workers/depthFirstSearchWorker.js","workers/bidirectionalGreedySearchWorker.js","workers/workerSetup.js","components/MainContainer.jsx","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","this","props","col","isFinish","isStart","isWall","isVisited","isVisitedSecond","isStop","isWeight","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","distance","distanceSecond","id","className","e","Component","PathfindingVisualizer","state","grid","map","rowIdx","node","nodeIdx","mouseIsPressed","handleMouseDown","handleMouseEnter","handleMouseUp","on","randomMaze","startNode","finishNode","isThereStop","stopNode","length","Math","random","push","sort","verticalMaze","vertical","range","horizontal","getVerticalWalls","len","result","i","choice","floor","num","addWall","isStartFinish","tempWalls","temp","splice","wall","horizontalMaze","getHorizontalWalls","recursiveDivisionMaze","getRecursiveWalls","dir","generateOddRandomNumber","slice","indexOf","array","max","randomNum","generateRandomNumber","algData","name","description","Navbar","useStyles","makeStyles","theme","customHoverFocus","backgroundColor","getWaves","currItem","currItemDesc","style","height","width","src","Start","Finish","Stop","info","wave","currItemPic","currBtnColor","showNav","items","currItemObj","currAlg","currAlgObj","IconButton","onClick","toggleNav","alg","val","data-val","handleTabs","play","size","fontSize","handleSpeedChange","animationSpeed","Button","genMaze","variant","fullWidth","color","Typography","title","handleMazeTabs","item","isCurrItem","handleItemChange","NavTop","algChange","target","dataset","console","log","window","innerHeight","innerWidth","clearGrid","resetGrid","handleMiniTabs","handleMiniMazeTabs","currMazeTab","itemData","self","addEventListener","message","stop","data","nodesInShortestPathOrder","startToStop","stopToFinish","currentNodeFin","currentNodeStop","filter","unshift","previousNodeSecond","previousNode","postMessage","currentNode","visitedNodesInorder","visitedNodesInOrder","unvisitedNodesSecond","unvisitedNodes","getAllNodes","forEach","Infinity","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","dijkstra","nodeA","nodeB","distanceCheck","unvisitedNeighbors","neighbors","neighbor","getUnvisitedNeighbors","nodes","aStar","f","af","abs","bf","a","b","totalDistance","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","firstSearch","secondSearch","totalDistanceSecond","greedyBFS","queue","queueSecond","currNode","updateUnvisitedNeighbours","bfs","next","pop","depthFirstSearch","bidirectionalGreedySearch","unvisitedNodesStop","visitedNodesInOrderStop","unvisitedNodesFinish","visitedNodesInOrderFinish","closestNodeStop","closestNodeFinish","isNeighbour","bidirectionalGreedySearchSecond","unvisitedNodesStart","visitedNodesInOrderStart","closestNodeStart","rowStart","colStart","rowFinish","colFinish","WebWorker","worker","code","toString","blob","Blob","Worker","URL","createObjectURL","MainContainer","newGrid","visualizingAlgorithm","generatingMaze","setState","startIsMoving","finishIsMoving","stopIsMoving","getNewGridWithWallToggled","getNewGridWithStart","getNewGridWithFinish","getNewGridWithStopToggled","prevStop","handleNav","handleItemDescChange","newItem","_item","currAlgTab","parseInt","up","currSpeed","generateMaze","gridClean","maze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","generateRandomMaze","document","getElementsByClassName","rowNum","colNum","getElementById","getGridWithoutPath","playAnimation","visualizeDijkstra","visualizeaStar","visualizbfs","visualizegbfs","visualizedfs","visualizeBidirectionalGreedySearch","handleProgressSetup","isSecondAnimation","animationDuration","progressBar","classList","remove","animateDijkstra","animationStall","animationColor","progress","$","integralVal","setTimeout","animateShortestPath","dijkstraWorker","_dijkstraWorker","pathGrabWorker","START_NODE","FINISH_NODE","STOP_NODE","messageTwo","animateTime","animateTiming","animateaStar","replaceWith","clone","aStarWorker","animatebfs","breadthFirstSearchWorker","animategbfs","greedyBestFirstSearchWorker","animatedfs","depthFirstSearchWorker","animateBidirectionalAlgorithm","isShortedPath","undefined","bidirectionalGreedySearchWorker","_startNode","_finishNode","_stopNode","visitedNodesInOrderStopFirst","visitedNodesInOrderStopSecond","isShortedPathSecond","nodesInShortestPathOrderFirst","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrderSecond","stall","currObj","includes","animateMaze","getNewGridWithMaze","newNode","currMazeAlg","resizeTimer","handleResize","renderGrid","clearTimeout","_rowNum","_colNum","currentRow","createNode","prevStart","newStart","oldStart","oldNode","prevFinish","newFinish","oldFinish","newStop","oldStop","minorReset","isShortest","second","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"wQAAIA,ECAAA,ECAAA,E,6JCgDWC,E,4JA3CX,WAAU,IAAD,EAgBDC,KAAKC,MAdPC,EAFG,EAEHA,IACAC,EAHG,EAGHA,SACAC,EAJG,EAIHA,QAGAC,GAPG,EAKHC,UALG,EAMHC,gBANG,EAOHF,QAEAG,GATG,EAQHC,SARG,EASHD,QACAE,EAVG,EAUHA,YACAC,EAXG,EAWHA,aACAC,EAZG,EAYHA,UACAC,EAbG,EAaHA,IAIIC,GAjBD,EAcHC,SAdG,EAeHC,eAGAb,EACE,cACAC,EACA,aACAI,EACA,YACAH,EACA,YACA,IAEJ,OACE,qBACEY,GAAE,eAAUJ,EAAV,YAAiBX,GACnBgB,UAAS,4CAAuCJ,GAChDJ,YAAa,kBAAMA,EAAYG,EAAKX,IACpCS,aAAc,SAACQ,GAEbR,EAAaE,EAAKX,IAEpBU,UAAW,kBAAMA,W,GAvCVQ,aCCEC,E,4JAEjB,WAAU,IAAD,OAEL,OACI,qBAAKH,UAAU,OAAf,SACKlB,KAAKC,MAAMqB,MAAMC,KAAKC,KAAI,SAACX,EAAKY,GAC7B,OACI,qBAAkBP,UAAU,WAA5B,SACKL,EAAIW,KAAI,SAACE,EAAMC,GAAa,IAClBd,EAAqEa,EAArEb,IAAKX,EAAgEwB,EAAhExB,IAAKC,EAA2DuB,EAA3DvB,SAAUC,EAAiDsB,EAAjDtB,QAASC,EAAwCqB,EAAxCrB,OADZ,EACoDqB,EAAhCjB,gBADpB,WACoDiB,EAAhBlB,cADpC,SAExB,OACI,cAAC,EAAD,CAEIN,IAAKA,EACLC,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRI,SAAUA,EACVD,OAAQA,EACRoB,eAAgB,EAAK3B,MAAMqB,MAAMM,eACjClB,YAAa,SAACG,EAAKX,GAAN,OAAc,EAAKD,MAAM4B,gBAAgBhB,EAAKX,IAC3DS,aAAc,SAACE,EAAKX,GAAN,OACV,EAAKD,MAAM6B,iBAAiBjB,EAAKX,IAErCU,UAAW,SAACC,EAAKX,GAAN,OAAc,EAAKD,MAAM8B,cAAclB,EAAKX,IACvD8B,IAAE,EACFnB,IAAKA,GAdAc,OALXF,Y,GARiBL,aCJ5C,SAASa,EAAWV,EAAMW,EAAWC,EAAYC,GAA8B,IAAjBC,EAAgB,wDAEjF,IAAKH,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAIT,IAFA,IAAIrC,EAAQ,GAEHe,EAAM,EAAGA,EAAMU,EAAKe,OAAQzB,IACnC,IAAK,IAAIX,EAAM,EAAGA,EAAMqB,EAAK,GAAGe,OAAQpC,IAEnCW,IAAQqB,EAAUrB,KAAOX,IAAQgC,EAAUhC,KAC3CW,IAAQsB,EAAWtB,KAAOX,IAAQiC,EAAWjC,KAC5CkC,GAAgBvB,IAAQwB,EAASxB,KAAOX,IAAQmC,EAASnC,KAIzDqC,KAAKC,SAAW,KAClB1C,EAAM2C,KAAK,CAAC5B,EAAKX,IAMvB,OADAJ,EAAM4C,MAAK,kBAAMH,KAAKC,SAAW,MAC1B1C,ELtBJ,SAAS6C,EAAapB,EAAMW,EAAWC,EAAYC,GAA8B,IAAjBC,EAAgB,wDACrF,IAAKH,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIS,EAAWC,EAAMtB,EAAK,GAAGe,QACzBQ,EAAaD,EAAMtB,EAAKe,QAG5B,OAFAxC,EAAQ,GACRiD,EAAiBH,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GACpEvC,EAGT,SAAS+C,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOR,KAAKS,GAEd,OAAOD,EAGT,SAASF,EAAiBH,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GAClF,KAAIO,EAASN,OAAS,GAAtB,CAIA,IAL4F,EAKxFa,EAASZ,KAAKa,MAAsB,EAAhBb,KAAKC,UAL+D,cAM5EI,GAN4E,IAM5F,2BAA0B,CAAC,IAAlBS,EAAiB,QACT,IAAXF,GAAgBE,EAAM,IAAM,GAC9BC,EAAQD,EAAKP,EAAYZ,EAAWC,EAAYC,EAAaC,GAEhD,IAAXc,GAAgBE,EAAM,IAAM,GAC9BC,EAAQD,EAAKP,EAAYZ,EAAWC,EAAYC,EAAaC,IAX2B,gCAgB9F,SAASiB,EAAQD,EAAKP,EAAYZ,EAAWC,EAAYC,EAAaC,GACpE,IAD8E,EAC1EkB,GAAgB,EAChBC,EAAY,GAF8D,cAG7DV,GAH6D,IAG9E,2BAA6B,CAAC,IAArBW,EAAoB,QAExBA,IAASvB,EAAUrB,KAAOwC,IAAQnB,EAAUhC,KAC5CuD,IAAStB,EAAWtB,KAAOwC,IAAQlB,EAAWjC,KAC9CkC,GAAgBqB,IAASpB,EAASxB,KAAOwC,IAAQhB,EAASnC,IAE3DqD,GAAgB,EAGlBC,EAAUf,KAAK,CAACgB,EAAMJ,KAZsD,8BAezEE,GACHC,EAAUE,OAAOnB,KAAKa,MAAMb,KAAKC,SAAWgB,EAAUlB,QAAS,GAEjE,cAAiBkB,EAAjB,eAA4B,CAAvB,IAAIG,EAAI,KACX7D,EAAM2C,KAAKkB,ICtDR,SAASC,EAAerC,EAAMW,EAAWC,EAAYC,GAA8B,IAAjBC,EAAgB,wDACvF,IAAKH,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIS,EAAWC,EAAMtB,EAAK,GAAGe,QACzBQ,EAAaD,EAAMtB,EAAKe,QAG5B,OAFAxC,EAAQ,GACR+D,EAAmBjB,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GACtEvC,EAGT,SAAS+C,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOR,KAAKS,GAEd,OAAOD,EAGT,SAASY,EAAmBjB,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GACpF,KAAIS,EAAWR,OAAS,GAAxB,CAIA,IAL8F,EAK1Fa,EAASZ,KAAKa,MAAsB,EAAhBb,KAAKC,UALiE,cAM9EM,GAN8E,IAM9F,2BAA4B,CAAC,IAApBO,EAAmB,QACX,IAAXF,GAAgBE,EAAM,IAAM,GAC9BC,EAAQD,EAAKT,EAAUV,EAAWC,EAAYC,EAAaC,GAE9C,IAAXc,GAAgBE,EAAM,IAAM,GAC9BC,EAAQD,EAAKT,EAAUV,EAAWC,EAAYC,EAAaC,IAX+B,gCAgBhG,SAASiB,EAAQD,EAAKT,EAAUV,EAAWC,EAAYC,EAAaC,GAClE,IAD4E,EACxEkB,GAAgB,EAChBC,EAAY,GAF4D,cAG3DZ,GAH2D,IAG5E,2BAA2B,CAAC,IAAnBa,EAAkB,QAEtBJ,IAAQnB,EAAUrB,KAAO4C,IAASvB,EAAUhC,KAC5CmD,IAAQlB,EAAWtB,KAAO4C,IAAStB,EAAWjC,KAC9CkC,GAAgBiB,IAAQhB,EAASxB,KAAO4C,IAASpB,EAASnC,IAE3DqD,GAAgB,EAGlBC,EAAUf,KAAK,CAACY,EAAKI,KAZqD,8BAcvEF,GACHC,EAAUE,OAAOnB,KAAKa,MAAMb,KAAKC,SAAWgB,EAAUlB,QAAS,GAEjE,cAAiBkB,EAAjB,eAA4B,CAAvB,IAAIG,EAAI,KACX7D,EAAM2C,KAAKkB,ICrDR,SAASG,EAAsBvC,EAAMW,EAAWC,EAAYC,GAA8B,IAAjBC,EAAgB,wDAC9F,IAAKH,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIS,EAAWC,EAAMtB,EAAK,GAAGe,QACzBQ,EAAaD,EAAMtB,EAAKe,QAG5B,OAFAxC,EAAQ,GACRiE,EAAkBnB,EAAUE,EAAYvB,EAAMW,EAAWC,EAAYC,EAAaC,GAC3EvC,EAGT,SAAS+C,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOR,KAAKS,GAEd,OAAOD,EAMT,SAASc,EAAkBnB,EAAUE,EAAYvB,EAAMW,EAAWC,EAAYC,EAAaC,GAIzF,IAAI2B,EACAX,EAJAT,EAASN,OAAS,GAAKQ,EAAWR,OAAS,IAK3CM,EAASN,OAASQ,EAAWR,SAC/B0B,EAAM,EACNX,EAAMY,EAAwBrB,IAE5BA,EAASN,QAAUQ,EAAWR,SAChC0B,EAAM,EACNX,EAAMY,EAAwBnB,IAGpB,IAARkB,GACFV,EAAQU,EAAKX,EAAKT,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GAC5E0B,EACEnB,EAASsB,MAAM,EAAGtB,EAASuB,QAAQd,IACnCP,EACAvB,EACAW,EACAC,EACAC,EACAC,GAEF0B,EACEnB,EAASsB,MAAMtB,EAASuB,QAAQd,GAAO,GACvCP,EACAvB,EACAW,EACAC,EACAC,EACAC,KAGFiB,EAAQU,EAAKX,EAAKT,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GAC5E0B,EACEnB,EACAE,EAAWoB,MAAM,EAAGpB,EAAWqB,QAAQd,IACvC9B,EACAW,EACAC,EACAC,EACAC,GAEF0B,EACEnB,EACAE,EAAWoB,MAAMpB,EAAWqB,QAAQd,GAAO,GAC3C9B,EACAW,EACAC,EACAC,EACAC,KAKN,SAAS4B,EAAwBG,GAC/B,IAAIC,EAAMD,EAAM9B,OAAS,EACrBgC,EACF/B,KAAKa,MAAMb,KAAKC,UAAY6B,EAAM,IAClC9B,KAAKa,MAAMb,KAAKC,UAAY6B,EAAM,IAQpC,OAPIC,EAAY,IAAM,IAChBA,IAAcD,EAChBC,GAAa,EAEbA,GAAa,GAGVF,EAAME,GAMf,SAAShB,EAAQU,EAAKX,EAAKT,EAAUE,EAAYZ,EAAWC,EAAYC,EAAaC,GAEnF,IAAIkB,GAAgB,EAChBC,EAAY,GAChB,GAAY,IAARQ,EAAW,CACb,GAA0B,IAAtBlB,EAAWR,OAAc,OADhB,oBAEIQ,GAFJ,IAEb,2BAA6B,CAAC,IAArBW,EAAoB,QAExBA,IAASvB,EAAUrB,KAAOwC,IAAQnB,EAAUhC,KAC5CuD,IAAStB,EAAWtB,KAAOwC,IAAQlB,EAAWjC,KAC9CkC,GAAgBqB,IAASpB,EAASxB,KAAOwC,IAAQhB,EAASnC,IAE3DqD,GAAgB,EAGlBC,EAAUf,KAAK,CAACgB,EAAMJ,KAXX,mCAaR,CACL,GAAwB,IAApBT,EAASN,OAAc,OADtB,oBAEYM,GAFZ,IAEL,2BAA2B,CAAC,IAAnBa,EAAkB,QAEtBJ,IAAQnB,EAAUrB,KAAO4C,IAASvB,EAAUhC,KAC5CmD,IAAQlB,EAAWtB,KAAO4C,IAAStB,EAAWjC,KAC9CkC,GAAgBiB,IAAQhB,EAASxB,KAAO4C,IAASpB,EAASnC,IAE3DqD,GAAgB,EAGlBC,EAAUf,KAAK,CAACY,EAAKI,KAXlB,+BAcFF,GACHC,EAAUE,OAOd,SAA8BW,GAC5B,IAAIC,EACF/B,KAAKa,MAAMb,KAAKC,UAAY6B,EAAM,IAClC9B,KAAKa,MAAMb,KAAKC,UAAY6B,EAAM,IAChCC,EAAY,IAAM,IAChBA,IAAcD,EAChBC,GAAa,EAEbA,GAAa,GAGjB,OAAOA,EAlBYC,CAAqBf,EAAUlB,QAAS,GAE3D,cAAiBkB,EAAjB,eAA4B,CAAvB,IAAIG,EAAI,KACX7D,EAAM2C,KAAKkB,IItIf,IAiCea,EAjCC,CACZ,CACIC,KAAM,wBACNC,YAAa,yJACbzD,GAAI,GAER,CACIwD,KAAM,YACNC,YAAa,8JACbzD,GAAI,GAER,CACIwD,KAAM,2BACNC,YAAa,sJACbzD,GAAI,GAER,CACIwD,KAAM,8BACNC,YAAa,iJACbzD,GAAI,GAER,CACIwD,KAAM,uBACNC,YAAa,+JACbzD,GAAI,GAER,CACIwD,KAAM,qBACNC,YAAa,oIACbzD,GAAI,IC7BG,G,YAAA,s6GCAA,MAA0B,uCCA1B,MAA0B,iC,6HCoBpB0D,G,4MAEjBC,UAAYC,aAAW,SAAAC,GAAK,MAAK,CAC7BC,iBAAkB,CAChB,8BAA+B,CAAEC,gBAAiB,e,EAIxDC,SAAW,WACP,IACIC,EAAW,EAAKjF,MAAMqB,MAAM6D,aAChC,MAAgB,UAAbD,EAIQ,CAHA,kBACO,qBAAKhE,UAAU,6BAA6BkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKC,IACxF,gBAEI,WAAbN,EAIC,CAHA,mBACO,qBAAKhE,UAAU,8BAA8BkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKE,IACzF,iBAEI,SAAbP,EAIC,CAHA,iBACO,qBAAKhE,UAAU,iBACd,eAEI,SAAbgE,EAIC,CAHA,iBACO,qBAAKhE,UAAU,4BAA4BkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKG,IACvF,oBAHZ,G,4CAOX,WAAS,IAAD,OACEC,EAAO3F,KAAKiF,WACZW,EAAOD,EAAK,GACZE,EAAcF,EAAK,GACnBG,EAAeH,EAAK,GACpBI,EAAU/F,KAAKC,MAAMqB,MAAMyE,QAC3BC,EAAQ,CAAC,QAAS,SAAU,OAAQ,QAEpCd,EAAWlF,KAAKC,MAAMqB,MAAM2E,YAC5BC,EAAUlG,KAAKC,MAAMqB,MAAM6E,WAEjC,OACQ,sBAAKjF,UAAS,sBAAiB6E,EAAU,SAAW,YAApD,UACA,qBAAK7E,UAAU,uBAAf,SACI,cAACkF,EAAA,EAAD,CAAYlF,UAAU,UAAUmF,QAASrG,KAAKC,MAAMqG,UAApD,SACKtG,KAAKC,MAAMqB,MAAMyE,QAAU,cAAC,KAAD,IAA0B,cAAC,KAAD,QAG9D,sBAAK7E,UAAU,iBAAf,UACI,qBAAKA,UAAU,eAAf,SACI,qBAAKA,UAAU,qBAAf,SAEIsD,EAAQhD,KAAI,SAAC+E,EAAKC,GACd,OACI,wBAAQC,WAAUD,EAAKH,QAAS,EAAKpG,MAAMyG,WAA3C,SAAwDH,EAAI9B,cAM5E,qBAAKvD,UAAU,WAAf,SACI,sBAAKA,UAAU,iBAAf,UACI,oBAAIA,UAAU,iBAAd,SAAgCgF,EAAQzB,OACxC,qBAAKvD,UAAU,0BAAf,SACI,mBAAGA,UAAU,gBAAb,SAA8BgF,EAAQxB,gBAE1C,qBAAKxD,UAAU,qBAAf,SACI,cAACkF,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAM0G,KAAhC,SACI,cAAC,IAAD,CAAsBzF,UAAU,WAAW0F,KAAK,OAAOC,SAAS,wBAMpF,sBAAK3F,UAAU,mBAAf,UACI,sBAAKA,UAAU,kBAAf,UACI,cAACkF,EAAA,EAAD,CAAYC,QAAS,SAAClF,GAAO,EAAKlB,MAAM6G,kBAAkB3F,GAAG,IAA7D,SACI,cAAC,IAAD,CAAYD,UAAU,mBAE1B,mBAAGA,UAAU,aAAb,SAA2BlB,KAAKC,MAAMqB,MAAMyF,iBAC5C,cAACX,EAAA,EAAD,CAAYC,QAAS,SAAClF,GAAO,EAAKlB,MAAM6G,kBAAkB3F,GAAG,IAA7D,SACI,cAAC,IAAD,CAASD,UAAU,iBAG3B,cAAC8F,EAAA,EAAD,CAAQ9F,UAAU,WAAWmF,QAASrG,KAAKC,MAAMgH,QAASC,QAAQ,YAAYC,WAAW,EAAMC,MAAM,UAArG,SACI,cAACC,EAAA,EAAD,CAAYnG,UAAU,gBAAtB,wBAIJ,qBAAKA,UAAU,gBAAf,SACI,qBAAKA,UAAU,sBAAf,SArDC,CAAC,0BAA2B,yBAA0B,0BAA2B,eAsDxEM,KAAI,SAAC8F,EAAOd,GAClB,OACI,wBAAQC,WAAUD,EAAKH,QAAS,EAAKpG,MAAMsH,eAA3C,SAA4DD,cAM5E,qBAAKpG,UAAU,kBAAf,SACI,sBAAKA,UAAS,oBAAe0E,GAA7B,UACI,qBAAK1E,UAAU,iBAAf,SACK8E,EAAMxE,KAAI,SAACgG,EAAMtE,GACd,IAAMuE,EAAa,EAAKxH,MAAMqB,MAAM6D,eAAiBqC,EACrD,OACI,mBAAGtG,UAAS,4BAAuBuG,EAAU,UAAM3B,GAAiB,WAAxD,YAA0E,IAAJ5C,EAAQ,YAAc,GAA5F,YAAkGA,IAAK8C,EAAM1D,OAAO,EAAK,WAAa,IAAMrB,GAAE,UAAKuG,EAAL,QAC1JnB,QAAS,SAAClF,GAAO,EAAKlB,MAAMyH,iBAAiBvG,EAAGqG,IADhD,SAEI,mBAAGtG,UAAU,gBAAb,SAA8BsG,WAK9C,oBAAItG,UAAU,aAAd,SAA4BgE,EAASoC,QACrC,qBAAKpG,UAAU,kBAAf,SACI,mBAAGA,UAAU,mBAAb,SAAiCgE,EAASR,gBAE7CmB,c,GAvHWzE,a,oGC+JrBuG,G,4MA3JX1C,SAAW,WACP,IACIC,EAAW,EAAKjF,MAAMqB,MAAM6D,aAChC,MAAgB,UAAbD,EAIQ,CAHA,kBACO,qBAAKhE,UAAU,kCAAkCkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKC,IAC7F,gBAEI,WAAbN,EAIC,CAHA,mBACO,qBAAKhE,UAAU,mCAAmCkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKE,IAC9F,iBAEI,SAAbP,EAIC,CAHA,iBACO,qBAAKhE,UAAU,sBACd,eAEI,SAAbgE,EAIC,CAHA,iBACO,qBAAKhE,UAAU,iCAAiCkE,MAAO,CAACC,OAAQ,OAAQC,MAAO,QAASC,IAAKG,IAC5F,oBAHZ,G,EAQXkC,UAAY,SAACzG,GACT,IAAIqF,EAAMrF,EAAE0G,OAAOC,QAAQtB,IAC3BuB,QAAQC,IAAIxB,I,4CAGhB,WAAS,IAAD,OACEb,EAAO3F,KAAKiF,WACZW,EAAOD,EAAK,GAEZG,GADcH,EAAK,GACJA,EAAK,IACpBI,EAAU/F,KAAKC,MAAMqB,MAAMyE,QAC3BC,EAAQ,CAAC,QAAS,SAAU,OAAQ,QAEpCd,EAAWlF,KAAKC,MAAMqB,MAAM2E,YAC5BC,EAAUlG,KAAKC,MAAMqB,MAAM6E,WACZ8B,OAAOC,YAE5B,OAAGD,OAAOE,WAAa,IAEf,qBAAKjH,UAAU,qBAAf,SACI,sBAAKA,UAAU,0BAAf,UACI,qBAAKA,UAAU,kBAAf,SACI,cAACkF,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAMmI,UAAWhB,MAAM,UAAjD,SACQ,cAAC,KAAD,CAAWlG,UAAU,kBAGjC,qBAAKA,UAAU,kBAAf,SACI,cAACkF,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAMoI,UAAWjB,MAAM,UAAjD,SACQ,cAAC,KAAD,CAAYlG,UAAU,uBAS9C,sBAAKA,UAAS,gCAA2B6E,EAAU,SAAW,YAA9D,UACI,qBAAK7E,UAAU,4BAAf,SACI,cAACkF,EAAA,EAAD,CAAYlF,UAAU,eAAemF,QAASrG,KAAKC,MAAMqG,UAAzD,SACKtG,KAAKC,MAAMqB,MAAMyE,QAAU,cAAC,KAAD,IAA0B,cAAC,KAAD,QAG9D,sBAAK7E,UAAU,qBAAf,UACI,qBAAKA,UAAU,oBAAf,SACI,sBAAKA,UAAU,0BAAf,UAEQsD,EAAQhD,KAAI,SAAC+E,EAAKC,GACd,GAAGD,EAAItF,KAAOiF,EAAQjF,GAAI,OAAS,oBAAIC,UAAU,aAAd,SAA4BqF,EAAI9B,UAG3E,cAAC2B,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAMqI,eAAhC,SACI,cAAC,KAAD,CAAqBpH,UAAU,WAAW2F,SAAS,mBAI/D,sBAAK3F,UAAU,gBAAf,UACI,sBAAKA,UAAU,gBAAf,UACI,6BAAKgF,EAAQzB,OACb,4BAAIyB,EAAQxB,iBAEhB,sBAAKxD,UAAU,gBAAf,UACI,cAACkF,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAM0G,KAAhC,SACI,cAAC,IAAD,CAAsBzF,UAAU,YAAY0F,KAAK,OAAOC,SAAS,cAErE,cAACT,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAMmI,UAAWhB,MAAM,UAAjD,SACI,cAAC,KAAD,CAAWlG,UAAU,iBAEzB,cAACkF,EAAA,EAAD,CAAYC,QAASrG,KAAKC,MAAMoI,UAAWjB,MAAM,UAAjD,SACI,cAAC,KAAD,CAAYlG,UAAU,0BAKtC,sBAAKA,UAAU,wBAAf,UACI,wBAAQA,UAAU,oBAAoBmF,QAASrG,KAAKC,MAAMgH,QAA1D,2BACA,sBAAK/F,UAAU,sBAAf,UACI,sBAAKA,UAAU,yBAAf,UACI,cAACkF,EAAA,EAAD,CAAYC,QAAS,kBAAM,EAAKpG,MAAMsI,oBAAmB,IAAzD,SACI,cAAC,KAAD,CAAqBrH,UAAU,mBAnEtC,CAAC,0BAA2B,yBAA0B,0BAA2B,eAsEjEM,KAAI,SAAC+E,EAAKC,GACf,GAAGA,IAAQ,EAAKvG,MAAMqB,MAAMkH,YAAa,OACrC,qBAAKtH,UAAU,kBAAf,SAAiC,oBAAIA,UAAU,aAAd,SAA4BqF,SAIzE,cAACH,EAAA,EAAD,CAAYC,QAAS,kBAAM,EAAKpG,MAAMsI,oBAAmB,IAAzD,SACI,cAAC,KAAD,CAAuBrH,UAAU,wBAGzC,sBAAKA,UAAU,gCAAf,UACI,cAACkF,EAAA,EAAD,CAAYC,QAAS,SAAClF,GAAO,EAAKlB,MAAM6G,kBAAkB3F,GAAG,IAA7D,SACI,cAAC,IAAD,CAAYD,UAAU,mBAE1B,mBAAGA,UAAU,kBAAb,SAAgClB,KAAKC,MAAMqB,MAAMyF,iBACjD,cAACX,EAAA,EAAD,CAAYC,QAAS,SAAClF,GAAO,EAAKlB,MAAM6G,kBAAkB3F,GAAG,IAA7D,SACI,cAAC,IAAD,CAASD,UAAU,uBAKnC,qBAAKA,UAAU,wBAAf,SACI,sBAAKA,UAAS,yBAAoB0E,GAAlC,UACI,qBAAK1E,UAAU,iBAAf,SACK8E,EAAMxE,KAAI,SAACgG,EAAMtE,GACd,IAAMuE,EAAa,EAAKxH,MAAMqB,MAAM6D,eAAiBqC,EACrD,OACI,mBAAGtG,UAAS,4BAAuBuG,EAAU,UAAM3B,GAAiB,WAAxD,YAA0E,IAAJ5C,EAAQ,YAAc,GAA5F,YAAkGA,IAAK8C,EAAM1D,OAAO,EAAK,WAAa,IAAMrB,GAAE,UAAKuG,EAAL,QAC1JnB,QAAS,SAAClF,GAAO,EAAKlB,MAAMyH,iBAAiBvG,EAAGqG,IADhD,SAEI,mBAAGtG,UAAU,gBAAb,SAA8BsG,WAK9C,sBAAKtG,UAAU,iBAAf,UACI,6BAAKgE,EAASoC,QACd,qBAAKpG,UAAU,iBAAf,SACI,4BAAIgE,EAASR,+B,GAnJxBtD,aCMNqH,GA5BE,CACb,CACIxH,GAAI,QACJqG,MAAO,aACP5C,YAAa,oJAEjB,CACIzD,GAAI,SACJqG,MAAO,cACP5C,YAAa,uJAEjB,CACIzD,GAAI,OACJqG,MAAO,OACP5C,YAAa,wIAOjB,CACIzD,GAAI,OACJqG,MAAO,OACP5C,YAAa,qICvBjBgE,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAE7B,GAAKA,EAAL,CAEA,IAAIvG,GAAS,EAAOF,GAAW,EAAOD,GAAU,EAE1C2G,EAAOD,EAAQE,KAAK,IACZD,EAAI,sBAAOD,EAAQE,KAAK,GAAG,IAAvB,YAA8BF,EAAQE,KAAK,GAAG,KAAMF,EAAQE,KAAK,IAE7EtH,KAAI,SAACE,GAQP,OANmB,IAAhBA,EAAKlB,SAAiB6B,EAAWX,IAEf,IAAlBA,EAAKvB,WAAmBgC,EAAaT,IAEpB,IAAjBA,EAAKtB,UAAkB8B,EAAYR,GAE/BA,KAGX,IAAIqH,EAA2B,GAE/B,GAAIF,GAmBG,GAAGA,EAAM,CAEZ,IAAIG,EAAY,GAAIC,EAAa,GAC7BC,EAAiB/G,EACjBgH,EAAkB9G,EAEtB,GAAIuG,EAAQE,KAAK,GAAG,GAAGM,QAAO,SAAA1H,GAAI,OAAsB,IAAlBA,EAAKvB,YAAmBmC,OAAS,EAAG,CACtE,KAA0B,OAAnB4G,IAEwB,IAAxBA,EAAe1I,QAElByI,EAAaI,QAAQH,GAErBA,EAAiBA,EAAeI,mBAEhCL,EAAa,GAAGzI,QAAQyI,EAAaI,QAAQhH,QAEjD4G,EAAaI,SAAQ,GAGzB,GAAIT,EAAQE,KAAK,GAAG,GAAGM,QAAO,SAAA1H,GAAI,OAAoB,IAAhBA,EAAKlB,UAAiB8B,OAAS,EAAG,CACpE,KAA2B,OAApB6G,IAE0B,IAA1BA,EAAgB/I,SAEnB4I,EAAYK,QAAQF,GAEpBA,EAAkBA,EAAgBI,aAElCP,EAAY,GAAG5I,SAAS4I,EAAYK,QAAQnH,QAGhD8G,EAAYK,SAAQ,GAGxBG,YAAY,CAACR,EAAaC,SAtDpB,EAEY,IAAf9G,GAAsBqH,aAAY,GAIrC,IAFA,IAAIC,EAActH,EAEK,OAAhBsH,IAEsB,IAAtBA,EAAYrJ,SAEf2I,EAAyBM,QAAQI,GAEjCA,EAAcA,EAAYF,aAG1BR,EAAyB,GAAG3I,SAAS2I,EAAyBM,QAAQnH,GAE1EsH,YAAYT,SCzCpBL,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC/B,GAAKA,EAAL,CAoKE,IAIMc,EAvKN,SAAkBnI,EAAMW,EAAWC,GAA4B,IAEvD3B,EAFuC6B,EAAe,wDAS1D,GALE7B,GADY,IAAX6B,EAKH0F,QAAQC,IAAI3F,GACR7B,GAkCG,GAAGA,EAAO,CAEjB,IAAMmJ,EAAsB,CAAC,GAAG,IAI5BC,GAFAC,EAAiBC,EAAYvI,GAENuI,EAAYvI,IAcvC,IAZAsI,EAAeE,SAAQ,SAACrI,GACjBA,IAASQ,EACZR,EAAKX,SAAW,EACNW,IAASW,EACnBX,EAAKV,eAAiB,GAEtBU,EAAKX,SAAWiJ,IAChBtI,EAAKV,eAAiBgJ,QAKlBH,GAAgB,CACpBI,EAAoBJ,GAAgB,GACpC,IAAMK,EAAcL,EAAeM,QAGnC,IAAGD,EAAY7J,OAAf,CAGA,GAAG6J,EAAYnJ,WAAaiJ,IAAU,MAOtC,GAJAE,EAAY5J,WAAY,EACxBqJ,EAAoB,GAAGlH,KAAKyH,GAGzBA,IAAgB7H,EAAU,MAG7B+H,EAAyBF,EAAa3I,GAAM,IAIhD,KAAQqI,GAAsB,CAE1BK,EAAoBL,GAAsB,GAE1C,IAAMM,EAAcN,EAAqBO,QAEzC,IAAGD,EAAY7J,OAAf,CAEA,GAAG6J,EAAYlJ,iBAAmBgJ,IAAU,MAK5C,GAHAE,EAAY3J,iBAAkB,EAC9BoJ,EAAoB,GAAGlH,KAAKyH,GAEzBA,IAAgB/H,EAAY,MAE/BiI,EAAyBF,EAAa3I,GAAM,IAEhD,OAAOoI,OA7FI,CACX,IAEIE,EAFEF,EAAsB,GAa5B,KAXIE,EAAiBC,EAAYvI,IAElBwI,SAAQ,SAACrI,GAEpBA,EAAKX,SADFW,IAASQ,EACI,EAEA8H,OAKZH,GAAe,CACnBI,EAAoBJ,GAAgB,GAEpC,IAAMK,EAAcL,EAAeM,QAGnC,IAAGD,EAAY7J,OAAf,CAGA,GAAG6J,EAAYnJ,WAAaiJ,IAAU,OAAOL,EAM7C,GAJAO,EAAY5J,WAAY,EACxBqJ,EAAoBlH,KAAKyH,GAGtBA,IAAgB/H,EAAY,OAAOwH,EAGtCS,EAAyBF,EAAa3I,GAAM,MA8HxB8I,CAJfzB,EAAQE,KAAK,GACRF,EAAQE,KAAK,GACZF,EAAQE,KAAK,GACfF,EAAQE,KAAK,IAG9BU,YAAYE,GA/DZ,SAASO,EAAoBJ,EAAgBrJ,GAEzCqJ,EAAenH,MAAK,SAAC4H,EAAOC,GAC1B,OAAY,IAAT/J,EAEM8J,EAAMtJ,eAAiBuJ,EAAMvJ,eAG7BsJ,EAAMvJ,SAAWwJ,EAAMxJ,YAGlC,IAAIyJ,EAAgB,GACjBhK,GACDqJ,EAAeE,SAAQ,SAACrI,GACnBA,EAAKV,iBAAmBgJ,KAAUQ,EAAc/H,KAAKf,MAKhE,SAAS0I,EAAyB1I,EAAMH,EAAMf,GAC1C,IADkD,EAC5CiK,EAQV,SAA+B/I,EAAMH,EAAMf,GACvC,IAAMkK,EAAY,GACXxK,EAAYwB,EAAZxB,IAAKW,EAAOa,EAAPb,IACRA,EAAM,GAAG6J,EAAUjI,KAAKlB,EAAKV,EAAM,GAAGX,IACtCW,EAAMU,EAAKe,OAAS,GAAGoI,EAAUjI,KAAKlB,EAAKV,EAAM,GAAGX,IACpDA,EAAM,GAAGwK,EAAUjI,KAAKlB,EAAKV,GAAKX,EAAM,IACxCA,EAAMqB,EAAK,GAAGe,OAAS,GAAGoI,EAAUjI,KAAKlB,EAAKV,GAAKX,EAAM,IAC7D,OAAOwK,EAAUtB,QAAO,SAACuB,GAEvB,OAAY,IAATnK,GACOmK,EAASpK,iBAEToK,EAASrK,aApBMsK,CAAsBlJ,EAAMH,EAAMf,GADX,cAE3BiK,GAF2B,IAElD,2BAA2C,CAAC,IAAjCE,EAAgC,QACzCnK,EAASmK,EAAS3J,eAAiBU,EAAKV,eAAiB,EAAI2J,EAAS5J,SAAWW,EAAKX,SAAW,EAEjGP,EAASmK,EAASrB,mBAAqB5H,EAAOiJ,EAASpB,aAAe7H,GALtB,+BA0BtD,SAASoI,EAAYvI,GACjB,IADuB,EACjBsJ,EAAQ,GADS,cAELtJ,GAFK,IAEvB,2BAAwB,CAAC,IAAD,EAAbV,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAda,EAAa,QACtBmJ,EAAMpI,KAAKf,IAFS,gCAFD,8BAOvB,OAAOmJ,OCnKnB,IAAInC,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC/B,GAAKA,EAAL,CAiKE,IAIMc,EAnKN,SAAenI,EAAMW,EAAWC,GAA4B,IAEpD3B,EAFoC6B,EAAe,wDASvD,GALE7B,GADY,IAAX6B,GAyCI,GAAG7B,EAAO,CAEb,IAAMmJ,EAAsB,CAAC,GAAG,IAI5BC,GAFAC,EAAiBC,EAAYvI,GAENuI,EAAYvI,IAcvC,IAZAsI,EAAeE,SAAQ,SAACrI,GACjBA,IAASQ,EACRR,EAAKX,SAAW,EACVW,IAASW,EACfX,EAAKV,eAAiB,GAEtBU,EAAKX,SAAWiJ,IAChBtI,EAAKV,eAAiBgJ,QAKtBH,GAAgB,CACpBI,EAAoBJ,EAAgBxH,GAAU,GAC9C,IAAM6H,EAAcL,EAAeM,QAGnC,IAAGD,EAAY7J,OAAf,CAGA,GAAG6J,EAAYnJ,WAAaiJ,IAAU,MAOtC,GAJAE,EAAY5J,WAAY,EACxBqJ,EAAoB,GAAGlH,KAAKyH,GAGzBA,IAAgB7H,EAAU,MAG7B+H,EAAyBF,EAAa3I,GAAM,IAIhD,KAAQqI,GAAsB,CAE1BK,EAAoBL,EAAsBzH,GAAY,GAEtD,IAAM+H,EAAcN,EAAqBO,QAEzC,IAAGD,EAAY7J,OAAf,CAEA,GAAG6J,EAAYlJ,iBAAmBgJ,IAAU,MAK5C,GAHAE,EAAY3J,iBAAkB,EAC9BoJ,EAAoB,GAAGlH,KAAKyH,GAEzBA,IAAgB/H,EAAY,MAE/BiI,EAAyBF,EAAa3I,GAAM,IAEhD,OAAOoI,OA9FA,CACX,IAEIE,EAFEF,EAAsB,GAa5B,KAXIE,EAAiBC,EAAYvI,IAElBwI,SAAQ,SAACrI,GAEhBA,EAAKX,SADNW,IAASQ,EACQ,EAEA8H,OAKhBH,GAAe,CAEnBI,EAAoBJ,EAAgB1H,GAAY,GAEhD,IAAM+H,EAAcL,EAAeM,QAGnC,IAAGD,EAAY7J,OAAf,CAGA,GAAG6J,EAAYnJ,WAAaiJ,IAAU,OAAOL,EAM7C,GAJAO,EAAY5J,WAAY,EACxBqJ,EAAoBlH,KAAKyH,GAGtBA,IAAgB/H,EAAY,OAAOwH,EAGtCS,EAAyBF,EAAa3I,GAAM,MAyHxBuJ,CAJflC,EAAQE,KAAK,GACRF,EAAQE,KAAK,GACZF,EAAQE,KAAK,GACfF,EAAQE,KAAK,IAG9BU,YAAYE,GA1DZ,SAASO,EAAoBJ,EAAgB1H,EAAY3B,GAErD,IAAMuK,EAAI5I,EACV0H,EAAenH,MAAK,SAAC4H,EAAOC,GACxB,IAAMS,EAAMzI,KAAK0I,IAAIF,EAAElK,IAAMyJ,EAAMzJ,KAAM0B,KAAK0I,IAAIF,EAAE7K,IAAMoK,EAAMpK,KAC1DgL,EAAM3I,KAAK0I,IAAIF,EAAElK,IAAM0J,EAAM1J,KAAM0B,KAAK0I,IAAIF,EAAE7K,IAAMqK,EAAMrK,KAEhE,OAAGM,EACS8J,EAAMtJ,eAAegK,GAAOT,EAAMvJ,eAAekK,GAEjDZ,EAAMvJ,SAASiK,GAAOT,EAAMxJ,SAASmK,MAKzD,SAASd,EAAyB1I,EAAMH,EAAMf,GAC1C,IADkD,EAC5CiK,EASV,SAA+B/I,EAAMH,EAAMf,GACvC,IAAMkK,EAAY,GACXxK,EAAYwB,EAAZxB,IAAKW,EAAOa,EAAPb,IACRA,EAAM,GAAG6J,EAAUjI,KAAKlB,EAAKV,EAAM,GAAGX,IACtCW,EAAMU,EAAKe,OAAS,GAAGoI,EAAUjI,KAAKlB,EAAKV,EAAM,GAAGX,IACpDA,EAAM,GAAGwK,EAAUjI,KAAKlB,EAAKV,GAAKX,EAAM,IACxCA,EAAMqB,EAAK,GAAGe,OAAS,GAAGoI,EAAUjI,KAAKlB,EAAKV,GAAKX,EAAM,IAC7D,OAAOwK,EAAUtB,QAAO,SAACuB,GAEzB,OAAY,IAATnK,GACSmK,EAASpK,iBAEToK,EAASrK,aArBMsK,CAAsBlJ,EAAMH,EAAMf,GADX,cAE3BiK,GAF2B,IAElD,2BAA2C,CAAC,IAAjCE,EAAgC,QAEvCnK,EAASmK,EAAS3J,eAAiBU,EAAKV,eAAiB,EAAI2J,EAAS5J,SAAWW,EAAKX,SAAW,EAEjGP,EAASmK,EAASrB,mBAAqB5H,EAAOiJ,EAASpB,aAAe7H,GANxB,+BA2BtD,SAASoI,EAAYvI,GACjB,IADuB,EACjBsJ,EAAQ,GADS,cAELtJ,GAFK,IAEvB,2BAAwB,CAAC,IAAD,EAAbV,EAAa,sBACLA,GADK,IACxB,2BAAwB,CAAC,IAAda,EAAa,QACpBmJ,EAAMpI,KAAKf,IAFS,gCAFD,8BAOvB,OAAOmJ,OCpKfnC,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC7B,GAAKA,EAAL,CAiKA,IAIMe,EAnKN,SAAmBpI,EAAMW,EAAWC,GAA6B,IAMzD3B,EANwC6B,EAAgB,wDAE5D,IAAKH,IAAcC,GAAcD,IAAcC,EAC3C,OAAO,EASX,KAJI3B,GADU,IAAX6B,GAKQ,CACP,IAAIwH,EAAiB,GACjBF,EAAsB,GAI1B,IAHAzH,EAAUnB,SAAW,EACrB8I,EAAepH,KAAKP,GAEa,IAA1B2H,EAAevH,QAAc,CAClCuH,EAAenH,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEE,cAAgBD,EAAEC,iBAClD,IAAInB,EAAcL,EAAeM,QACjC,GAAID,IAAgB/H,EAElB,OADAwH,EAAoBlH,KAAKyH,GAClBP,EAGTO,EAAY5J,WAAY,EACxBqJ,EAAoBlH,KAAKyH,GAEzB,IAXkC,EAW9BoB,EAAaC,EAAcrB,EAAa3I,GAXV,cAYZ+J,GAZY,IAYlC,2BAAkC,CAAC,IAA1BE,EAAyB,QAC5BzK,EAAWmJ,EAAYnJ,SAAW,EAElC0K,EAA6BD,EAAW3B,IAC1CA,EAAeR,QAAQmC,GACvBA,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWrJ,GACvDqJ,EAAUjC,aAAeW,GAChBnJ,EAAWyK,EAAUzK,WAC9ByK,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWrJ,GACvDqJ,EAAUjC,aAAeW,IAvBK,+BA4BpC,OAAOP,EAEJ,GAAGnJ,EAAO,CAEb,IAAIqJ,EAAiB,GACjBD,EAAuB,GACvB+B,EAAc,GACdC,EAAe,GAKnB,IAJA1J,EAAUnB,SAAW,EACrB8I,EAAepH,KAAKP,GACpB0H,EAAqBnH,KAAKJ,GAEO,IAA1BwH,EAAevH,QAAc,CAClCuH,EAAenH,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEE,cAAgBD,EAAEC,iBAClD,IAAInB,EAAcL,EAAeM,QACjC,GAAID,IAAgB7H,EAAU,CAC5BsJ,EAAYlJ,KAAKyH,GACjB,MAGFA,EAAY5J,WAAY,EACxBqL,EAAYlJ,KAAKyH,GAEjB,IAXkC,EAW9BoB,EAAaC,EAAcrB,EAAa3I,GAAM,GAXhB,cAYZ+J,GAZY,IAYlC,2BAAkC,CAAC,IAA1BE,EAAyB,QAC5BzK,EAAWmJ,EAAYnJ,SAAW,EAElC0K,EAA6BD,EAAW3B,IAC1CA,EAAeR,QAAQmC,GACvBA,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWnJ,GACvDmJ,EAAUjC,aAAeW,GAChBnJ,EAAWyK,EAAUzK,WAC9ByK,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWnJ,GACvDmJ,EAAUjC,aAAeW,IAvBK,+BA4BpC,KAAuC,IAAhCN,EAAqBtH,QAAc,CACxCsH,EAAqBlH,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEU,oBAAsBT,EAAES,uBAC9D,IAAI3B,EAAcN,EAAqBO,QACvC,GAAID,IAAgB/H,EAAY,CAC9ByJ,EAAanJ,KAAKyH,GAClB,MAGFA,EAAY3J,iBAAkB,EAC9BqL,EAAanJ,KAAKyH,GAElB,IAXwC,EAWpCoB,EAAaC,EAAcrB,EAAa3I,GAAM,GAXV,cAYlB+J,GAZkB,IAYxC,2BAAkC,CAAC,IAA1BE,EAAyB,QAC5BzK,EAAWmJ,EAAYlJ,eAAiB,EAExCyK,EAA6BD,EAAW5B,IAC1CA,EAAqBP,QAAQmC,GAC7BA,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWrJ,GAC7DqJ,EAAUlC,mBAAqBY,GACtBnJ,EAAWyK,EAAUxK,iBAC9BwK,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWrJ,GAC7DqJ,EAAUlC,mBAAqBY,IAvBK,+BA4B1C,MAAO,CAACyB,EAAaC,IAiDDE,CAJflD,EAAQE,KAAK,GACRF,EAAQE,KAAK,GACZF,EAAQE,KAAK,GACfF,EAAQE,KAAK,IAG9BU,YAAYG,GA/CZ,SAAS4B,EAAc7J,EAAMH,EAAMf,GAC/B,IAAIgL,EAAY,GACV3K,EAAaa,EAAbb,IAAKX,EAAQwB,EAARxB,IAaX,OAVgB,IAARW,GAAW2K,EAAU/I,KAAKlB,EAAKV,EAAM,GAAGX,IACxCA,IAAQqB,EAAK,GAAGe,OAAS,GAAGkJ,EAAU/I,KAAKlB,EAAKV,GAAKX,EAAM,IAC3DW,IAAQU,EAAKe,OAAS,GAAGkJ,EAAU/I,KAAKlB,EAAKV,EAAM,GAAGX,IAC9C,IAARA,GAAWsL,EAAU/I,KAAKlB,EAAKV,GAAKX,EAAM,IAO3CsL,EAAUpC,QACf,SAAC1H,GACG,OAAGlB,GACOkB,EAAKrB,SAAWqB,EAAKnB,iBAErBmB,EAAKrB,SAAWqB,EAAKpB,aAMzC,SAASoL,EAAkBhK,EAAMS,GAG7B,OAFQI,KAAK0I,IAAIvJ,EAAKb,IAAMsB,EAAWtB,KAC/B0B,KAAK0I,IAAIvJ,EAAKxB,IAAMiC,EAAWjC,KAI3C,SAASuL,EAA6BD,EAAW3B,GAAiB,IAAD,gBAC5CA,GAD4C,IAC7D,2BAAiC,CAAC,IAAzBnI,EAAwB,QAC/B,GAAIA,EAAKb,MAAQ2K,EAAU3K,KAAOa,EAAKxB,MAAQsL,EAAUtL,IACvD,OAAO,GAHkD,8BAM7D,OAAO,OChKnB,IAAIwI,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC/B,GAAKA,EAAL,CAgJE,IAKMe,EApJN,SAAapI,EAAMW,EAAWC,GAA6B,IAEnD3B,EAFkC6B,EAAgB,wDAQlDsH,EAAsB,GAE1B,GANInJ,GADU,IAAX6B,EAOQ,CAEP,IAAI0J,EAAQ,GACRC,EAAc,GAIlB,IAHArC,EAAsB,CAAC,GAAG,IAC1BoC,EAAMtJ,KAAKP,GACX8J,EAAYvJ,KAAKJ,GACV0J,EAAMzJ,QAAQ,CACjB,IAAM2J,EAAWF,EAAM5B,QAEvB,GAAI8B,IAAa5J,EAAU,CACvBsH,EAAoB,GAAGlH,KAAKwJ,GAC5B,MAIJ,IAAKA,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS3L,WAAY,CAC/D2L,EAAS3L,WAAY,EACrBqJ,EAAoB,GAAGlH,KAAKwJ,GAFmC,IAGvDpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAK0K,GAAU,IAGlE,KAAOD,EAAY1J,QAAQ,CACvB,IAAM2J,EAAWD,EAAY7B,QAE7B,GAAI8B,IAAa9J,EAAY,CACzBwH,EAAoB,GAAGlH,KAAKwJ,GAC5B,MAIJ,IAAKA,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS1L,iBAAkB,CACrE0L,EAAS1L,iBAAkB,EAC3BoJ,EAAoB,GAAGlH,KAAKwJ,GAFyC,IAG7DpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK8L,EAAazK,EAAM0K,GAAU,IAGzE,OAAOtC,EAEJ,IAAInJ,EAAQ,CAEf,IAAIuL,EAAQ,GAEZ,IADAA,EAAMtJ,KAAKP,GACJ6J,EAAMzJ,QAAQ,CACjB,IAAM2J,EAAWF,EAAM5B,QAEvB,GAAI8B,IAAa9J,EAEb,OADAwH,EAAoBlH,KAAKwJ,GAClBtC,EAIX,IAAKsC,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS3L,WAAY,CAC/D2L,EAAS3L,WAAY,EACrBqJ,EAAoBlH,KAAKwJ,GAFsC,IAGvDpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAK0K,GAAU,IAGlE,OAAOtC,GA6EawC,CALfvD,EAAQE,KAAK,GACRF,EAAQE,KAAK,GACZF,EAAQE,KAAK,GACfF,EAAQE,KAAK,IAI9BU,YAAYG,GAxEZ,SAASuC,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAM0K,GAAyB,IAGvEG,EAHwD5L,EAAc,wDAE9E,GAAGA,EAEKK,EAAM,KACRuL,EAAO7K,EAAKV,EAAM,GAAGX,IACXK,kBACRwL,EAAMtJ,KAAK2J,GACXA,EAAK9C,mBAAqB2C,IAG1BpL,EAAMU,EAAKe,OAAS,KACtB8J,EAAO7K,EAAKV,EAAM,GAAGX,IACXK,kBACRwL,EAAMtJ,KAAK2J,GACXA,EAAK9C,mBAAqB2C,IAG1B/L,EAAM,KACRkM,EAAO7K,EAAKV,GAAKX,EAAM,IACbK,kBACRwL,EAAMtJ,KAAK2J,GACXA,EAAK9C,mBAAqB2C,IAG1B/L,EAAMqB,EAAK,GAAGe,OAAS,KACzB8J,EAAO7K,EAAKV,GAAKX,EAAM,IACbK,kBACRwL,EAAMtJ,KAAK2J,GACXA,EAAK9C,mBAAqB2C,SAG3B,IAAIzL,EAAQ,CACf,IAAI4L,EACAvL,EAAM,KACRuL,EAAO7K,EAAKV,EAAM,GAAGX,IACXI,YACRyL,EAAMtJ,KAAK2J,GACXA,EAAK7C,aAAe0C,IAGpBpL,EAAMU,EAAKe,OAAS,KACtB8J,EAAO7K,EAAKV,EAAM,GAAGX,IACXI,YACRyL,EAAMtJ,KAAK2J,GACXA,EAAK7C,aAAe0C,IAGpB/L,EAAM,KACRkM,EAAO7K,EAAKV,GAAKX,EAAM,IACbI,YACRyL,EAAMtJ,KAAK2J,GACXA,EAAK7C,aAAe0C,IAGpB/L,EAAMqB,EAAK,GAAGe,OAAS,KACzB8J,EAAO7K,EAAKV,GAAKX,EAAM,IACbI,YACRyL,EAAMtJ,KAAK2J,GACXA,EAAK7C,aAAe0C,UC/IpCvD,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC7B,GAAKA,EAAL,CAqJA,IAIMe,EAvJN,SAA0BpI,EAAMW,EAAWC,GAA6B,IAEhE3B,EAF+C6B,EAAgB,wDASnE,KALI7B,GADU,IAAX6B,GAMS,CAER,IAAMsH,EAAsB,GAEtBoC,EAAQ,GAEd,IADAA,EAAMtJ,KAAKP,GACJ6J,EAAMzJ,QAAQ,CACjB,IAAM2J,EAAWF,EAAMM,MAEvB,GAAIJ,IAAa9J,EAEb,OADAwH,EAAoBlH,KAAKwJ,GAClBtC,EAIX,IAAKsC,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS3L,WAAY,CAC/D2L,EAAS3L,WAAY,EACrBqJ,EAAoBlH,KAAKwJ,GAFsC,IAGvDpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAM0K,GAAU,IAGnE,OAAOtC,EAEJ,GAAGnJ,EAAQ,CAEd,IAAMmL,EAAc,GACdC,EAAe,GACjBG,EAAQ,GACRC,EAAc,GAIlB,IAHAD,EAAMtJ,KAAKP,GACX8J,EAAYvJ,KAAKJ,GAEV0J,EAAMzJ,QAAQ,CACjB,IAAM2J,EAAWF,EAAMM,MAEvB,GAAIJ,IAAa5J,EAAU,CACvBsJ,EAAYlJ,KAAKwJ,GACjB,MAIJ,IAAKA,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS3L,WAAY,CAC/D2L,EAAS3L,WAAY,EACrBqL,EAAYlJ,KAAKwJ,GAF8C,IAGvDpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAM0K,GAAU,IAInE,KAAOD,EAAY1J,QAAQ,CACvB,IAAM2J,EAAWD,EAAYK,MAE7B,GAAIJ,IAAa9J,EAAY,CACzByJ,EAAanJ,KAAKwJ,GAClB,MAIJ,IAAKA,EAAS5L,SAAW4L,EAAS7L,UAAY6L,EAAS1L,iBAAkB,CACrE0L,EAAS1L,iBAAkB,EAC3BqL,EAAanJ,KAAKwJ,GAFmD,IAG7DpL,EAAaoL,EAAbpL,IAAKX,EAAQ+L,EAAR/L,IACbgM,EAA0BrL,EAAKX,EAAK8L,EAAazK,EAAM0K,GAAU,IAIzE,MAAO,CAACN,EAAaC,IA2EDU,CAJf1D,EAAQE,KAAK,GACRF,EAAQE,KAAK,GACZF,EAAQE,KAAK,GACfF,EAAQE,KAAK,IAG9BU,YAAYG,GAzEZ,SAAUuC,EAA0BrL,EAAKX,EAAK6L,EAAOxK,EAAM0K,EAAUzL,GACjE,IAAI4L,EAEJ,OAAG5L,GACKK,EAAM,KACNuL,EAAO7K,EAAKV,EAAM,GAAGX,IACXK,kBACR6L,EAAK9C,mBAAqB2C,EAC1BF,EAAMtJ,KAAK2J,KAGXvL,EAAMU,EAAKe,OAAS,KACtB8J,EAAO7K,EAAKV,EAAM,GAAGX,IACXK,kBACR6L,EAAK9C,mBAAqB2C,EAC1BF,EAAMtJ,KAAK2J,KAGXlM,EAAMqB,EAAK,GAAGe,OAAS,KACzB8J,EAAO7K,EAAKV,GAAKX,EAAM,IACbK,kBACR6L,EAAK9C,mBAAqB2C,EAC1BF,EAAMtJ,KAAK2J,UAGXlM,EAAM,KACRkM,EAAO7K,EAAKV,GAAKX,EAAM,IACbK,kBACR6L,EAAK9C,mBAAqB2C,EAC1BF,EAAMtJ,KAAK2J,OAKV5L,OAAJ,GACCK,EAAM,KACNuL,EAAO7K,EAAKV,EAAM,GAAGX,IACXI,YACR8L,EAAK7C,aAAe0C,EACpBF,EAAMtJ,KAAK2J,KAGXvL,EAAMU,EAAKe,OAAS,KACtB8J,EAAO7K,EAAKV,EAAM,GAAGX,IACXI,YACR8L,EAAK7C,aAAe0C,EACpBF,EAAMtJ,KAAK2J,KAGXlM,EAAMqB,EAAK,GAAGe,OAAS,KACzB8J,EAAO7K,EAAKV,GAAKX,EAAM,IACbI,YACR8L,EAAK7C,aAAe0C,EACpBF,EAAMtJ,KAAK2J,UAGXlM,EAAM,KACRkM,EAAO7K,EAAKV,GAAKX,EAAM,IACbI,YACR8L,EAAK7C,aAAe0C,EACpBF,EAAMtJ,KAAK2J,YClJ7B1D,QAAO,EACI,cAEXA,GAAKC,iBAAiB,WAAW,SAAAC,GAC7B,GAAKA,EAAL,CAsMA,IAAMrH,EAAOqH,EAAQE,KAAK,GACpB5G,EAAY0G,EAAQE,KAAK,GACzB3G,EAAayG,EAAQE,KAAK,GAC1BzG,EAAWuG,EAAQE,KAAK,GAE1BY,EAAsB,GADXd,EAAQE,KAAK,IAKxBY,EAAsB,CAAC6C,EAA0BhL,EAAMW,EAAWG,GA/HtE,SAAyCd,EAAMc,EAAUF,GAErD,IAAIqK,EAAqB,GACrBC,EAA0B,GAC1BC,EAAuB,GACvBC,EAA4B,GAMhC,IALAtK,EAASrB,eAAiB,EAC1BmB,EAAWnB,eAAiB,EAC5BwL,EAAmB/J,KAAKJ,GACxBqK,EAAqBjK,KAAKN,GAGQ,IAA9BqK,EAAmBlK,QACa,IAAhCoK,EAAqBpK,QACvB,CACEkK,EAAmB9J,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEU,oBAAsBT,EAAES,uBAC5Da,EAAqBhK,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEU,oBAAsBT,EAAES,uBAC9D,IAAIe,EAAkBJ,EAAmBrC,QACrC0C,EAAoBH,EAAqBvC,QAM7C,GAJAyC,EAAgBrM,iBAAkB,EAClCsM,EAAkBtM,iBAAkB,EACpCkM,EAAwBhK,KAAKmK,GAC7BD,EAA0BlK,KAAKoK,GAC3BC,EAAYF,EAAiBC,GAC7B,MAAO,CAACJ,EAAyBE,GAA2B,EAAM,KAGtE,IAdF,EAcMrB,EAAaC,EAAcqB,EAAiBrL,GAAM,GAdxD,cAeuB+J,GAfvB,IAeE,IAAI,EAAJ,qBAAiC,CAAC,IAA1BE,EAAyB,QAC7B,IAAKC,EAA6BD,EAAWkB,GAGzC,OAFAD,EAAwBhK,KAAKmK,GAC7BD,EAA0BlK,KAAK+I,GACxB,CAACiB,EAAyBE,GAA2B,GAEhE,IAAI5L,EAAW6L,EAAgB5L,eAAiB,EAE5CyK,EAA6BD,EAAWgB,IACxCA,EAAmBnD,QAAQmC,GAC3BA,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWrJ,GAC7DqJ,EAAUlC,mBAAqBsD,GACxB7L,EAAWyK,EAAUxK,iBAC5BwK,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWrJ,GAC7DqJ,EAAUlC,mBAAqBsD,IA/BzC,8BAmCEtB,EAAaC,EAAcsB,EAAmBtL,GAAM,GAnCtD,oBAoCwB+J,GApCxB,IAoCE,2BAAkC,CAAC,IAA1BE,EAAyB,QAC9B,IAAKC,EAA6BD,EAAWgB,GAGzC,OAFAG,EAA0BlK,KAAKoK,GAC/BJ,EAAwBhK,KAAK+I,GACtB,CAACiB,EAAyBE,GAA2B,GAEhE,IAAI5L,EAAW8L,EAAkB7L,eAAiB,EAE9CyK,EAA6BD,EAAWkB,IACxCA,EAAqBrD,QAAQmC,GAC7BA,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWnJ,GAC7DmJ,EAAUlC,mBAAqBuD,GACxB9L,EAAWyK,EAAUxK,iBAC5BwK,EAAUxK,eAAiBD,EAC3ByK,EAAUK,oBAAsBH,EAAkBF,EAAWnJ,GAC7DmJ,EAAUlC,mBAAqBuD,IApDzC,gCAiH2EE,CAAgCxL,EAAMc,EAAUF,IAC7HqH,YAAYE,KAGZA,EAAsB6C,EAA0BhL,EAAMW,EAAWC,GACjEqH,YAAYE,IAnNhB,SAAS6C,EAA0BhL,EAAMW,EAAWC,GAChD,IAAKD,IAAcC,GAAcD,IAAcC,EAC/C,OAAO,EAGP,IAAI6K,EAAsB,GACtBC,EAA2B,GAC3BP,EAAuB,GACvBC,EAA4B,GAMhC,IALAzK,EAAUnB,SAAW,EACrBoB,EAAWpB,SAAW,EACtBiM,EAAoBvK,KAAKP,GACzBwK,EAAqBjK,KAAKN,GAGS,IAA/B6K,EAAoB1K,QACY,IAAhCoK,EAAqBpK,QACvB,CACE0K,EAAoBtK,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEE,cAAgBD,EAAEC,iBACvDqB,EAAqBhK,MAAK,SAACyI,EAAGC,GAAJ,OAAUD,EAAEE,cAAgBD,EAAEC,iBACxD,IAAI6B,EAAmBF,EAAoB7C,QACvC0C,EAAoBH,EAAqBvC,QAM7C,GAJA+C,EAAiB5M,WAAY,EAC7BuM,EAAkBvM,WAAY,EAC9B2M,EAAyBxK,KAAKyK,GAC9BP,EAA0BlK,KAAKoK,GAC3BC,EAAYI,EAAkBL,GAC9B,MAAO,CAACI,EAA0BN,GAA2B,GAIjE,IAfF,EAeMrB,EAAaC,EAAc2B,EAAkB3L,GAfnD,cAgBwB+J,GAhBxB,IAgBE,2BAAkC,CAAC,IAA1BE,EAAyB,QAC9B,IAAKC,EAA6BD,EAAWkB,GAGzC,OAFAO,EAAyBxK,KAAKyK,GAC9BP,EAA0BlK,KAAK+I,GACxB,CAACyB,EAA0BN,GAA2B,GAEjE,IAAI5L,EAAWmM,EAAiBnM,SAAW,EAEvC0K,EAA6BD,EAAWwB,IACxCA,EAAoB3D,QAAQmC,GAC5BA,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWrJ,GACvDqJ,EAAUjC,aAAe2D,GAClBnM,EAAWyK,EAAUzK,WAC5ByK,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWrJ,GACvDqJ,EAAUjC,aAAe2D,IAhCnC,8BAqCE5B,EAAaC,EAAcsB,EAAmBtL,GArChD,oBAsCwB+J,GAtCxB,IAsCE,2BAAkC,CAAC,IAA1BE,EAAyB,QAC9B,IAAKC,EAA6BD,EAAWwB,GAGzC,OAFAL,EAA0BlK,KAAKoK,GAC/BI,EAAyBxK,KAAK+I,GACvB,CAACyB,EAA0BN,GAA2B,GAEjE,IAAI5L,EAAW8L,EAAkB9L,SAAW,EAExC0K,EAA6BD,EAAWkB,IACxCA,EAAqBrD,QAAQmC,GAC7BA,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWtJ,GAC3DsJ,EAAUjC,aAAesD,GACd9L,EAAWyK,EAAUzK,WAC5ByK,EAAUzK,SAAWA,EACrByK,EAAUH,cAAgBK,EAAkBF,EAAWtJ,GACvDsJ,EAAUjC,aAAesD,IAtDnC,+BA0DF,MAAO,CAACI,EAA0BN,GAA2B,GA4EjE,SAASG,EAAYI,EAAkBL,GACnC,IAAIM,EAAWD,EAAiBrM,IAC5BuM,EAAWF,EAAiBhN,IAC5BmN,EAAYR,EAAkBhM,IAC9ByM,EAAYT,EAAkB3M,IAClC,OAAImN,IAAcF,EAAW,GAAKG,IAAcF,IAC5CC,IAAcF,GAAYG,IAAcF,EAAW,IACnDC,IAAcF,EAAW,GAAKG,IAAcF,GAC5CC,IAAcF,GAAYG,IAAcF,EAAW,IAI3D,SAAS7B,EAAc7J,EAAMH,GAAqB,IAAff,EAAc,wDACzC8K,EAAa,GACXzK,EAAaa,EAAbb,IAAKX,EAAQwB,EAARxB,IAMX,OALY,IAARW,GAAWyK,EAAW7I,KAAKlB,EAAKV,EAAM,GAAGX,IACzCA,IAAQqB,EAAK,GAAGe,OAAS,GAAGgJ,EAAW7I,KAAKlB,EAAKV,GAAKX,EAAM,IAC5DW,IAAQU,EAAKe,OAAS,GAAGgJ,EAAW7I,KAAKlB,EAAKV,EAAM,GAAGX,IAC/C,IAARA,GAAWoL,EAAW7I,KAAKlB,EAAKV,GAAKX,EAAM,IAE5CM,EACQ8K,EAAWlC,QACd,SAACoC,GAAD,OAAgBA,EAAUnL,SAAWmL,EAAUjL,mBAG5C+K,EAAWlC,QACd,SAACoC,GAAD,OAAgBA,EAAUnL,SAAWmL,EAAUlL,aAK3D,SAASoL,EAAkBpB,EAAOC,GAG9B,OAFQhI,KAAK0I,IAAIX,EAAMzJ,IAAM0J,EAAM1J,KAC3B0B,KAAK0I,IAAIX,EAAMpK,IAAMqK,EAAMrK,KAIvC,SAASuL,EAA6BD,EAAW3B,GAAiB,IAAD,gBAC5CA,GAD4C,IAC7D,2BAAiC,CAAC,IAAzBnI,EAAwB,QAC7B,GAAIA,EAAKb,MAAQ2K,EAAU3K,KAAOa,EAAKxB,MAAQsL,EAAUtL,IACrD,OAAO,GAH8C,8BAM7D,OAAO,O,ICvMEqN,GACjB,WAAYC,GAAS,oBACnB,IAAMC,EAAOD,EAAOE,WACdC,EAAO,IAAIC,KAAK,CAAC,IAAMH,EAAO,QACpC,OAAO,IAAII,OAAOC,IAAIC,gBAAgBJ,KCgBvBK,I,wDACjB,WAAY/N,GAAO,IAAD,8BACd,cAAMA,IAoEV4B,gBAAkB,SAAChB,EAAKX,GAEpB,IAAI+N,EAAU,EAAK3M,MAAMC,KACrBG,EAAOuM,EAAQpN,GAAKX,GAErB,EAAKoB,MAAM4M,sBAAwB,EAAK5M,MAAM6M,iBAE9C,EAAK7M,MAAMC,KAAKV,GAAKX,GAAKE,SAC3B,EAAKgO,SAAS,CAACC,eAAe,IAC9BJ,EAAU,EAAK3M,MAAMC,MACb,EAAKD,MAAMC,KAAKV,GAAKX,GAAKC,UAClC,EAAKiO,SAAS,CAACE,gBAAgB,IAC/BL,EAAU,EAAK3M,MAAMC,MACe,SAA5B,EAAKD,MAAM6D,aACnB,EAAKiJ,SAAS,CAACG,cAAc,EAAMnM,aAAa,IACZ,SAA5B,EAAKd,MAAM6D,cAA6BzD,EAAKtB,SAAYsB,EAAKvB,UAAauB,EAAKlB,SACxFyN,EAAUO,GAA2BP,EAASpN,EAAKX,IAErD,EAAKkO,SAAS,CAAC7M,KAAM0M,EAASrM,gBAAgB,MAvFhC,EA0FlBE,iBAAmB,SAACjB,EAAKX,GAErB,GAAK,EAAKoB,MAAMM,eAAhB,CAEA,IAAIqM,EAAU,EAAK3M,MAAMC,KACrBG,EAAOuM,EAAQpN,GAAKX,GAEpBwB,EAAKtB,SAAWsB,EAAKlB,QAAUkB,EAAKvB,UAAY,EAAKmB,MAAM4M,sBAAwB,EAAK5M,MAAM6M,iBAE/F,EAAK7M,MAAM+M,eACZJ,EAAUQ,GAAoB,EAAKnN,MAAMC,KAAMV,EAAKX,EAAK,EAAKoB,MAAMY,WACpE,EAAKkM,SAAS,CAAClM,UAAW,CAACrB,EAAKX,MACxB,EAAKoB,MAAMgN,gBACnBL,EAAUS,GAAqB,EAAKpN,MAAMC,KAAMV,EAAKX,EAAK,EAAKoB,MAAMa,YACrE,EAAKiM,SAAS,CAACjM,WAAY,CAACtB,EAAKX,MACG,SAA5B,EAAKoB,MAAM6D,cACnB8I,EAAUU,GAA0B,EAAKrN,MAAMC,KAAMV,EAAKX,EAAK,EAAKoB,MAAMsN,UAC1E,EAAKR,SAAS,CAACQ,SAAU,CAAC/N,EAAKX,MACK,SAA5B,EAAKoB,MAAM6D,cAA6BzD,EAAKtB,SAAYsB,EAAKvB,UAAauB,EAAKlB,SACxFyN,EAAUO,GAA2BP,EAASpN,EAAKX,IAErD,EAAKkO,SAAS,CAAC7M,KAAM0M,OA/GP,EAkHlBlM,cAAgB,SAAClB,EAAKX,GAClB,EAAKkO,SAAS,CAACxM,gBAAgB,EAAOyM,eAAe,EAAOC,gBAAgB,KAnH9D,EAsHlBO,UAAY,WACV,EAAKT,SAAS,CAACrI,SAAU,EAAKzE,MAAMyE,WAvHpB,EA2HlB+I,qBAAuB,SAAC3N,EAAGqG,GACzB,IAAIuH,EAAO,UAAMvH,GACjBiB,GAASjH,KAAI,SAACwN,GAGZ,OAFGxH,IAASwH,EAAM/N,IAAI,EAAKmN,SAAS,CAACjJ,aAAc4J,EAAS9I,YAAa+I,IAElEA,MAhIO,EAoIlBtI,WAAa,SAACvF,GACZ,IAAIqF,EAAMrF,EAAE0G,OAAOC,QAAQtB,IAC3B,EAAK4H,SAAS,CAACa,WAAYzI,EAAKL,WAAY3B,EAAQgC,MAtIpC,EAyIlB8B,eAAiB,SAACnH,GAChB,IAAIqF,EAAM,EAAKlF,MAAM2N,WAClBzI,EAAI,EAAIhC,EAAQlC,OAAO,EACxBkE,EAAM,EAENA,IAGF,EAAK4H,SAAS,CAACa,WAAYzI,EAAKL,WAAY3B,EAAQgC,MAjJpC,EAoJlBe,eAAiB,SAACpG,GAChB,IAAIqF,EAAM0I,SAAS/N,EAAE0G,OAAOC,QAAQtB,KACpC,EAAK4H,SAAS,CAAC5F,YAAahC,KAtJZ,EAyJlB+B,mBAAqB,SAAC4G,GACpB,IAAI3I,EAAM,EAAKlF,MAAMkH,YAErB,GAAG2G,EAAI,CACL,GAAG3I,GAAO,EAER,YADA,EAAK4H,SAAS,CAAC5F,YAAa,IAG9BhC,QACK,CACL,GAAGA,GAAO,EAER,YADA,EAAK4H,SAAS,CAAC5F,YAAa,IAG9BhC,IAGF,EAAK4H,SAAS,CAAC5F,YAAahC,KA1KZ,EA6KlBM,kBAAoB,SAAC3F,EAAGqF,GACtB,IAAI4I,EAAY,EAAK9N,MAAMyF,eAExBP,GAAO4I,EAAY,GACpB,EAAKhB,SAAS,CAACrH,eAAgBqI,EAAU,KACrC5I,GAAO4I,EAAY,IACvB,EAAKhB,SAAS,CAACrH,eAAgBqI,EAAU,KAnL3B,EAuLlBC,aAAe,SAAClO,GAEd,IAAG,EAAKG,MAAM6M,iBAAkB,EAAK7M,MAAM4M,sBAAyB,EAAK5M,MAAMgO,YAAa,EAAKhO,MAAMiO,KAAvG,CAEA,EAAKnB,SAAS,CAACmB,MAAM,IAErB,IAAIrJ,EAAU,EAAK5E,MAAMkH,YAEZ,IAAVtC,EACD,EAAKsJ,gCACa,IAAVtJ,EACR,EAAKuJ,uBACa,IAAVvJ,EACR,EAAKwJ,yBACa,IAAVxJ,GACR,EAAKyJ,uBAtMS,EA0MlBtH,UAAY,WACV,IAAI,EAAK/G,MAAM4M,uBAAwB,EAAK5M,MAAM6M,eAAlD,CAGAyB,SAASC,uBAAuB,YAAY,GAAGzK,MAAME,MAAQ,KAU7D,IARA,IAAIwK,EAAS,EAAKxO,MAAMwO,OACpBC,EAAS,EAAKzO,MAAMyO,OAElBxO,EAAO,EAAKD,MAAMC,KAClBW,EAAY,EAAKZ,MAAMY,UACvBC,EAAa,EAAKb,MAAMa,WACxBE,IAAW,EAAKf,MAAMc,aAAc,EAAKd,MAAMsN,SAE5C/N,EAAM,EAAGA,EAAMiP,EAAQjP,IAC9B,IAAK,IAAIX,EAAM,EAAGA,EAAM6P,EAAQ7P,IACxBW,IAAQqB,EAAU,IAAMhC,IAAQgC,EAAU,GAE9C0N,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,kBACjDL,IAAQsB,EAAW,IAAMjC,IAAQiC,EAAW,GAErDyN,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,oBACrC,IAAbmB,GAAuBxB,IAAQwB,EAAS,IAAMnC,IAAQmC,EAAS,GAEvEuN,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,iBAClDK,EAAKV,GAAKX,GAAKG,OAEvBuP,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,iBAE1D0O,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,OAIhE,IAAM+M,EAAUgC,GAAmB,EAAK3O,MAAMC,MAAM,GACpD,EAAK6M,SAAS,CACZ7M,KAAM0M,EACNC,sBAAsB,EACtBC,gBAAgB,EAChBmB,WAAW,EACXC,MAAM,MAjPQ,EAqPlBnH,UAAY,WAEV,IAAI,EAAK9G,MAAM4M,uBAAwB,EAAK5M,MAAM6M,eAAlD,CAGAyB,SAASC,uBAAuB,YAAY,GAAGzK,MAAME,MAAQ,KAQ7D,IANA,IAAIwK,EAAS,EAAKxO,MAAMwO,OACpBC,EAAS,EAAKzO,MAAMyO,OAElB7N,EAAY,EAAKZ,MAAMY,UACvBC,EAAa,EAAKb,MAAMa,WAErBtB,EAAM,EAAGA,EAAMiP,EAAQjP,IAC9B,IAAK,IAAIX,EAAM,EAAGA,EAAM6P,EAAQ7P,IACxBW,IAAQqB,EAAU,IAAMhC,IAAQgC,EAAU,GAE9C0N,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,kBACjDL,IAAQsB,EAAW,IAAMjC,IAAQiC,EAAW,GAErDyN,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,mBAG1D0O,SAASI,eAAT,eAAgCnP,EAAhC,YAAuCX,IAAOgB,UAAY,OAIhE,IAAM+M,EAAUgC,GAAmB,EAAK3O,MAAMC,MAC9C,EAAK6M,SAAS,CACZ7M,KAAM0M,EACNC,sBAAsB,EACtBC,gBAAgB,EAChBS,SAAU,GACVxM,aAAa,EACbkN,WAAW,EACXC,MAAM,MAxRQ,EA8RlBW,cAAgB,SAAC/O,GAEf,IAAG,EAAKG,MAAM6M,iBAAkB,EAAK7M,MAAM4M,sBAAyB,EAAK5M,MAAMgO,UAA/E,CAEA,IAAIpJ,EAAU,EAAK5E,MAAM6E,WAAWlF,GACpC,EAAKmN,SAAS,CACZkB,WAAW,EACXpB,sBAAsB,EACtBnI,SAAS,IAEE,IAAVG,EACD,EAAKiK,oBACa,IAAVjK,EACR,EAAKkK,iBACa,IAAVlK,EACR,EAAKmK,cACa,IAAVnK,EACR,EAAKoK,gBACa,IAAVpK,EACR,EAAKqK,eACa,IAAVrK,GACR,EAAKsK,uCAnTS,EAwTlBC,oBAAsB,SACpBrO,EACAsO,EACA3J,EACA4J,GAGA,IAAMC,EAAchB,SAASI,eAAT,eAGpB,OAFAY,EAAY1P,UAAY,4BAEpBkB,GAUOsO,GAAqBtO,GAE9BwO,EAAY1P,UAAY,kCACxB0P,EAAYxL,MAAMuL,kBAAlB,UAA0CA,EAAkB5J,EAAe,IAA3E,KACA6J,EAAYjI,iBAAiB,gBAAgB,WAC3CiI,EAAYC,UAAUC,OAAO,0BAC7BF,EAAY1P,UAAY,+BAEnB,GAAGyP,GAEFD,GAAqBtO,GAE7BwO,EAAY1P,UAAY,+BACxB0P,EAAYxL,MAAMuL,kBAAlB,UAA0CA,EAAkB5J,EAAe,IAA3E,KACA6J,EAAYjI,iBAAiB,gBAAgB,WAC3CiI,EAAYC,UAAUC,OAAO,uBAC7BF,EAAY1P,UAAY,4BAEnB,GAAGyP,QARL,GAlBLC,EAAY1P,UAAY,kCACxB0P,EAAYxL,MAAMuL,kBAAlB,UAA0CA,EAAkB5J,EAAe,IAA3E,KACA6J,EAAYjI,iBAAiB,gBAAgB,WAC3CiI,EAAYC,UAAUC,OAAO,0BAC7BF,EAAY1P,UAAY,+BAEnB,IAAIyP,IA1UG,EAqWlBI,gBAAkB,SAChBpH,EACAZ,EACAiI,GAII,IAEAC,EALJlK,EAGG,uDAHY,GACf3E,EAEG,wDADHsO,EACG,wDAIHO,EAAqCA,EAApBP,EAAqC,sBAAyC,eAY/F,IATA,IAAMQ,EAAWC,IAAE,gBAEfC,EAAc,EAAKX,oBACrBrO,EACAsO,EACA3J,EACA4C,EAAoBrH,QAbnB,WAgBMY,GAEP,GAAIA,IAAMyG,EAAoBrH,OAE5B,OAAGoO,GAAqBtO,GAExBiP,WAAW,EAAKC,oBAAqBN,EAAejK,EAAgBgC,GAFzB,CAAN,UAMvCsI,YAAW,WACT,IAAM3P,EAAOiI,EAAoBzG,GAC/B0M,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAxD,eAA4E+P,EAA5E,iCACAC,EAAS5L,MAAT,YAAoB8L,EAApB,QACCrK,EAAiB7D,IAdfA,EAAI,EAAGA,GAAKyG,EAAoBrH,OAAQY,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCA5XtC,EA8YlBiN,kBAAoB,WAElB,EAAKoB,eAAiB,IAAIhE,GAAUiE,IAEpC,EAAKC,eAAiB,IAAIlE,GAAUkE,IAEpC,IAAIlQ,EAAO,EAAKD,MAAMC,KAChBmQ,EAAa,EAAKpQ,MAAMY,UACxByP,EAAc,EAAKrQ,MAAMa,WACzByP,EAAY,EAAKtQ,MAAMsN,SACvB1M,EAAYX,EAAKmQ,EAAW,IAAIA,EAAW,IAC3CvP,EAAaZ,EAAKoQ,EAAY,IAAIA,EAAY,IAC9CtP,EAAW,EAAKf,MAAMc,YAAcb,EAAKqQ,EAAU,IAAIA,EAAU,IAAM,GAC7E,GAAG,EAAKtQ,MAAMc,YAoDZ,OAlDA,EAAKmP,eAAe/H,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,SAE9D,EAAKkP,eAAe5I,iBAAiB,WAAW,SAACC,IAE1B,uCAAG,WAAOA,GAAP,SAAAuC,EAAA,sDAElB,EAAKsG,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,IAEzB,SAACjJ,EAASiJ,GAE5B,IAAI9I,EAGFA,GAD2B,IAA1B8I,EAAW/I,KAAK,GAAG,KAA0C,IAA1B+I,EAAW/I,KAAK,GAAG,GAC5B,CAAC5G,EAAWG,EAAUF,IACf,IAA1B0P,EAAW/I,KAAK,GAAG,GACH,CAAI5G,GAAJ,mBAAkB2P,EAAW/I,KAAK,MACxB,IAA1B+I,EAAW/I,KAAK,GAAG,GACH,sBAAO+I,EAAW/I,KAAK,IAAvB,CAA2B3G,IAE3B,sBAAO0P,EAAW/I,KAAK,IAAvB,YAA8B+I,EAAW/I,KAAK,KAGxE,EAAKiI,gBACHnI,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAGFiP,WAAW,EAAKN,gBACdnI,EAAQE,KAAK,GAAGxG,OAAS,EAAKhB,MAAMyF,eACpC6B,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAIJ0P,CAAYlJ,EAASiJ,MAxCP,2CAAH,sDA2CnBE,CAAcnJ,MAKT,EAAKtH,MAAMc,cAEpB,EAAKmP,eAAe/H,YAAY,CAACjI,EAAMW,EAAWC,GAAY,IAE9D,EAAKoP,eAAe5I,iBAAiB,WAAW,SAACC,GAE7C,EAAK6I,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,GAE/C,IAAI9I,GAA+C,IAApB8I,EAAW/I,KAAiB,CAAC5G,EAAWC,GAAc0P,EAAW/I,KAEhG,EAAKiI,gBACHnI,EAAQE,KACRC,EACAH,EAAQE,KAAKxG,OACb,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,qBAleL,EA4elB4P,aAAe,SACbrI,EACAZ,EACAiI,EACAjK,EACA3E,GAEI,IAEA6O,EAHJP,EACG,wDAIHO,EAAqCA,EAApBP,EAAqC,sBAAyC,eAG/F,IAAMQ,EAAWC,IAAE,gBACnBD,EAASe,YAAYd,IAAE,iBAAiBe,OAAM,GAS9C,IAPA,IAAId,EAAc,EAAKX,oBACrBrO,EACAsO,EACA3J,EACA4C,EAAoBrH,QAdnB,WAiBMY,GACP,GAAIA,IAAMyG,EAAoBrH,OAE5B,OAAGoO,GAAqBtO,GAExBiP,WAAW,EAAKC,oBAAqBN,EAAejK,EAAgBgC,GAFzB,CAAN,UAMvCsI,YAAW,WACP,IAAM3P,EAAOiI,EAAoBzG,GACjC0M,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAxD,eAA4E+P,EAA5E,iCACAC,EAAS5L,MAAT,YAAoB8L,EAApB,QACCrK,EAAiB7D,IAbfA,EAAI,EAAGA,GAAKyG,EAAoBrH,OAAQY,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCApgBtC,EAqhBlBkN,eAAiB,WAEf,EAAK+B,YAAc,IAAI5E,GAAU4E,IAEjC,EAAKV,eAAiB,IAAIlE,GAAUkE,IAEpC,IAAIlQ,EAAO,EAAKD,MAAMC,KAChBmQ,EAAa,EAAKpQ,MAAMY,UACxByP,EAAc,EAAKrQ,MAAMa,WACzByP,EAAY,EAAKtQ,MAAMsN,SACvB1M,EAAYX,EAAKmQ,EAAW,IAAIA,EAAW,IAC3CvP,EAAaZ,EAAKoQ,EAAY,IAAIA,EAAY,IAC9CtP,EAAW,EAAKf,MAAMc,YAAcb,EAAKqQ,EAAU,IAAIA,EAAU,IAAM,GAE7E,GAAG,EAAKtQ,MAAMc,YAkDV,OAjDF,EAAK+P,YAAY3I,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,SAE3D,EAAK8P,YAAYxJ,iBAAiB,WAAW,SAACC,IAEzB,uCAAG,WAAOA,GAAP,SAAAuC,EAAA,sDAEpB,EAAKsG,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,IAEzB,SAACjJ,EAASiJ,GAE5B,IAAI9I,EAGFA,GAD2B,IAA1B8I,EAAW/I,KAAK,GAAG,KAA0C,IAA1B+I,EAAW/I,KAAK,GAAG,GAC5B,CAAC5G,EAAWG,EAAUF,IACf,IAA1B0P,EAAW/I,KAAK,GAAG,GACH,CAAI5G,GAAJ,mBAAkB2P,EAAW/I,KAAK,MACxB,IAA1B+I,EAAW/I,KAAK,GAAG,GACH,sBAAO+I,EAAW/I,KAAK,IAAvB,CAA2B3G,IAE3B,sBAAO0P,EAAW/I,KAAK,IAAvB,YAA8B+I,EAAW/I,KAAK,KAGxE,EAAKkJ,aACHpJ,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAGFiP,WAAW,EAAKW,aACdpJ,EAAQE,KAAK,GAAGxG,OAAS,EAAKhB,MAAMyF,eACpC6B,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAIJ0P,CAAYlJ,EAASiJ,MAxCL,2CAAH,sDA2CrBE,CAAcnJ,MAIL,EAAKtH,MAAMc,cAElB,EAAK+P,YAAY3I,YAAY,CAACjI,EAAMW,EAAWC,GAAY,IAE3D,EAAKgQ,YAAYxJ,iBAAiB,WAAW,SAACC,GAE1C,EAAK6I,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,GAE/C,IAAI9I,GAA+C,IAApB8I,EAAW/I,KAAiB,CAAC5G,EAAWC,GAAc0P,EAAW/I,KAEhG,EAAKkJ,aACHpJ,EAAQE,KACRC,EACAH,EAAQE,KAAKxG,OACb,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,WAzmBI,EAmnBlBgQ,WAAa,SACXzI,EACAZ,EACAiI,EACAjK,EACA3E,GAEI,IAEA6O,EAHJP,EACG,wDAIHO,EAAqCA,EAApBP,EAAqC,sBAAyC,eAG/F,IAAMQ,EAAWC,IAAE,gBACnBD,EAASe,YAAYd,IAAE,iBAAiBe,OAAM,GAS9C,IAPA,IAAId,EAAc,EAAKX,oBACrBrO,EACAsO,EACA3J,EACA4C,EAAoBrH,QAdnB,WAiBMY,GACP,GAAIA,IAAMyG,EAAoBrH,OAE5B,OAAGoO,GAAqBtO,GAExBiP,WAAW,EAAKC,oBAAqBvK,EAAeiK,EAAgBjI,GAFzB,CAAN,UAMvCsI,YAAW,WACT,IAAM3P,EAAOiI,EAAoBzG,GACjC0M,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAxD,eAA4E+P,EAA5E,iCACAC,EAAS5L,MAAT,YAAoB8L,EAApB,QACCrK,EAAiB7D,IAbbA,EAAI,EAAGA,GAAKyG,EAAoBrH,OAAQY,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCA3oBtC,EA4pBlBmN,YAAc,WAEZ,EAAKgC,yBAA2B,IAAI9E,GAAU8E,IAE9C,EAAKZ,eAAiB,IAAIlE,GAAUkE,IAEpC,IAAIlQ,EAAO,EAAKD,MAAMC,KAChBmQ,EAAa,EAAKpQ,MAAMY,UACxByP,EAAc,EAAKrQ,MAAMa,WACzByP,EAAY,EAAKtQ,MAAMsN,SACvB1M,EAAYX,EAAKmQ,EAAW,IAAIA,EAAW,IAC3CvP,EAAaZ,EAAKoQ,EAAY,IAAIA,EAAY,IAC9CtP,EAAW,EAAKf,MAAMc,YAAcb,EAAKqQ,EAAU,IAAIA,EAAU,IAAM,GAE7E,GAAG,EAAKtQ,MAAMc,YAmDd,OAjDE,EAAKiQ,yBAAyB7I,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,SAExE,EAAKgQ,yBAAyB1J,iBAAiB,WAAW,SAACC,IAEpC,uCAAG,WAAOA,GAAP,SAAAuC,EAAA,sDAEpB,EAAKsG,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,IAEzB,SAACjJ,EAASiJ,GAE5B,IAAI9I,EAGFA,GAD2B,IAA1B8I,EAAW/I,KAAK,GAAG,KAA0C,IAA1B+I,EAAW/I,KAAK,GAAG,GAC5B,CAAC5G,EAAWG,EAAUF,IACf,IAA1B0P,EAAW/I,KAAK,GAAG,GACH,CAAI5G,GAAJ,mBAAkB2P,EAAW/I,KAAK,MACxB,IAA1B+I,EAAW/I,KAAK,GAAG,GACH,sBAAO+I,EAAW/I,KAAK,IAAvB,CAA2B3G,IAE3B,sBAAO0P,EAAW/I,KAAK,IAAvB,YAA8B+I,EAAW/I,KAAK,KAGxE,EAAKsJ,WACHxJ,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAGFiP,WAAW,EAAKe,WACdxJ,EAAQE,KAAK,GAAGxG,OAAS,EAAKhB,MAAMyF,eACpC6B,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAIJ0P,CAAYlJ,EAASiJ,MAxCL,2CAAH,sDA2CrBE,CAAcnJ,MAIP,EAAKtH,MAAMc,cAEpB,EAAKiQ,yBAAyB7I,YAAY,CAACjI,EAAMW,EAAWC,GAAY,IAExE,EAAKkQ,yBAAyB1J,iBAAiB,WAAW,SAACC,GAEvD,EAAK6I,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,GAE/C,IAAI9I,GAA+C,IAApB8I,EAAW/I,KAAiB,CAAC5G,EAAWC,GAAc0P,EAAW/I,KAEhG,EAAKsJ,WACHxJ,EAAQE,KACRC,EACAH,EAAQE,KAAKxG,OACb,EAAKhB,MAAMyF,gBACX,WAhvBM,EAyvBlBuL,YAAc,SACZ3I,EACAZ,EACAiI,EACAjK,EACA3E,GAEI,IAEA6O,EAHJP,EACG,wDAIHO,EAAqCA,EAApBP,EAAqC,sBAAyC,eAG/F,IAAMQ,EAAWC,IAAE,gBACnBD,EAASe,YAAYd,IAAE,iBAAiBe,OAAM,GAS9C,IAPA,IAAId,EAAc,EAAKX,oBACrBrO,EACAsO,EACA3J,EACA4C,EAAoBrH,QAdnB,WAiBMY,GACP,GAAIA,IAAMyG,EAAoBrH,OAE5B,OAAGoO,GAAqBtO,GAExBiP,WAAW,EAAKC,oBAAqBN,EAAejK,EAAgBgC,GAFzB,CAAN,UAMvCsI,YAAW,WACP,IAAM3P,EAAOiI,EAAoBzG,GACjC0M,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAxD,eAA4E+P,EAA5E,iCACAC,EAAS5L,MAAT,YAAoB8L,EAApB,QACCrK,EAAiB7D,IAbfA,EAAI,EAAGA,GAAKyG,EAAoBrH,OAAQY,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCAjxBtC,EAkyBlBoN,cAAgB,WAEd,EAAKiC,4BAA8B,IAAIhF,GAAUgF,IAEjD,EAAKd,eAAiB,IAAIlE,GAAUkE,IAEpC,IAAIlQ,EAAO,EAAKD,MAAMC,KAChBmQ,EAAa,EAAKpQ,MAAMY,UACxByP,EAAc,EAAKrQ,MAAMa,WACzByP,EAAY,EAAKtQ,MAAMsN,SACvB1M,EAAYX,EAAKmQ,EAAW,IAAIA,EAAW,IAC3CvP,EAAaZ,EAAKoQ,EAAY,IAAIA,EAAY,IAC9CtP,EAAW,EAAKf,MAAMc,YAAcb,EAAKqQ,EAAU,IAAIA,EAAU,IAAM,GAE1E,EAAKtQ,MAAMc,aAEZ,EAAKmQ,4BAA4B/I,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,IAE3E,EAAKkQ,4BAA4B5J,iBAAiB,WAAW,SAACC,IAEzC,uCAAG,WAAOA,GAAP,SAAAuC,EAAA,sDAEpB,EAAKsG,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,IAEzB,SAACjJ,EAASiJ,GAE5B,IAAI9I,EAGFA,GAD2B,IAA1B8I,EAAW/I,KAAK,GAAG,KAA0C,IAA1B+I,EAAW/I,KAAK,GAAG,GAC5B,CAAC5G,EAAWG,EAAUF,IACf,IAA1B0P,EAAW/I,KAAK,GAAG,GACH,CAAI5G,GAAJ,mBAAkB2P,EAAW/I,KAAK,MACxB,IAA1B+I,EAAW/I,KAAK,GAAG,GACH,sBAAO+I,EAAW/I,KAAK,IAAvB,CAA2B3G,IAE3B,sBAAO0P,EAAW/I,KAAK,IAAvB,YAA8B+I,EAAW/I,KAAK,KAGxE,EAAKwJ,YACH1J,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAGFiP,WAAW,EAAKiB,YACd1J,EAAQE,KAAK,GAAGxG,OAAS,EAAKhB,MAAMyF,eACpC6B,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAIJ0P,CAAYlJ,EAASiJ,MAxCL,2CAAH,sDA2CnBE,CAAcnJ,OAGP,EAAKtH,MAAMc,cAEpB,EAAKmQ,4BAA4B/I,YAAY,CAACjI,EAAMW,EAAWC,GAAY,IAE3E,EAAKoQ,4BAA4B5J,iBAAiB,WAAW,SAACC,GAE1D,EAAK6I,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,GAE/C,IAAI9I,GAA+C,IAApB8I,EAAW/I,KAAiB,CAAC5G,EAAWC,GAAc0P,EAAW/I,KAEhG,EAAKwJ,YACH1J,EAAQE,KACRC,EACAH,EAAQE,KAAKxG,OACb,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,WAt3BM,EAg4BlBoQ,WAAa,SACX7I,EACAZ,EACAiI,EACAjK,EACA3E,GAEI,IAEA6O,EAHJP,EACG,wDAIHO,EAAqCA,EAApBP,EAAqC,sBAAyC,eAG/F,IAAMQ,EAAWC,IAAE,gBACnBD,EAASe,YAAYd,IAAE,iBAAiBe,OAAM,GAS9C,IAPA,IAAId,EAAc,EAAKX,oBACrBrO,EACAsO,EACA3J,EACA4C,EAAoBrH,QAdnB,WAiBMY,GACP,GAAIA,IAAMyG,EAAoBrH,OAE5B,OAAGoO,GAAqBtO,GAExBiP,WAAW,EAAKC,oBAAqBN,EAAejK,EAAgBgC,GAFzB,CAAN,UAMvCsI,YAAW,WACP,IAAM3P,EAAOiI,EAAoBzG,GACjC0M,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAxD,eAA4E+P,EAA5E,iCACAC,EAAS5L,MAAT,YAAoB8L,EAApB,QACCrK,EAAiB7D,IAbfA,EAAI,EAAGA,GAAKyG,EAAoBrH,OAAQY,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCAx5BtC,EAy6BlBqN,aAAe,WAEb,EAAKkC,uBAAyB,IAAIlF,GAAUkF,IAE5C,EAAKhB,eAAiB,IAAIlE,GAAUkE,IAEpC,IAAIlQ,EAAO,EAAKD,MAAMC,KAChBmQ,EAAa,EAAKpQ,MAAMY,UACxByP,EAAc,EAAKrQ,MAAMa,WACzByP,EAAY,EAAKtQ,MAAMsN,SACvB1M,EAAYX,EAAKmQ,EAAW,IAAIA,EAAW,IAC3CvP,EAAaZ,EAAKoQ,EAAY,IAAIA,EAAY,IAC9CtP,EAAW,EAAKf,MAAMc,YAAcb,EAAKqQ,EAAU,IAAIA,EAAU,IAAM,GAE7E,GAAG,EAAKtQ,MAAMc,YAoDZ,OAlDA,EAAKqQ,uBAAuBjJ,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,SAEtE,EAAKoQ,uBAAuB9J,iBAAiB,WAAW,SAACC,IAEpC,uCAAG,WAAOA,GAAP,SAAAuC,EAAA,sDAEpB,EAAKsG,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,IAEzB,SAACjJ,EAASiJ,GAE5B,IAAI9I,EAGFA,GAD2B,IAA1B8I,EAAW/I,KAAK,GAAG,KAA0C,IAA1B+I,EAAW/I,KAAK,GAAG,GAC5B,CAAC5G,EAAWG,EAAUF,IACf,IAA1B0P,EAAW/I,KAAK,GAAG,GACH,CAAI5G,GAAJ,mBAAkB2P,EAAW/I,KAAK,MACxB,IAA1B+I,EAAW/I,KAAK,GAAG,GACH,sBAAO+I,EAAW/I,KAAK,IAAvB,CAA2B3G,IAE3B,sBAAO0P,EAAW/I,KAAK,IAAvB,YAA8B+I,EAAW/I,KAAK,KAGxE,EAAK0J,WACH5J,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAGFiP,WACE,EAAKmB,WACL5J,EAAQE,KAAK,GAAGxG,OAAS,EAAKhB,MAAMyF,eACpC6B,EAAQE,KAAK,GACbC,EACCH,EAAQE,KAAK,GAAGxG,OAAOsG,EAAQE,KAAK,GAAGxG,OACxC,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,GAIJ0P,CAAYlJ,EAASiJ,MAzCL,2CAAH,sDA4CnBE,CAAcnJ,MAIP,EAAKtH,MAAMc,cAEpB,EAAKqQ,uBAAuBjJ,YAAY,CAACjI,EAAMW,EAAWC,GAAY,IAEtE,EAAKsQ,uBAAuB9J,iBAAiB,WAAW,SAACC,GAErD,EAAK6I,eAAejI,YAAY,CAACZ,EAAQE,MAAM,IAE/C,EAAK2I,eAAe9I,iBAAiB,WAAW,SAACkJ,GAE/C,IAAI9I,GAA+C,IAApB8I,EAAW/I,KAAiB,CAAC5G,EAAWC,GAAc0P,EAAW/I,KAEhG,EAAK0J,WACH5J,EAAQE,KACRC,EACAH,EAAQE,KAAKxG,OACb,EAAKhB,MAAMyF,eACX,EAAKzF,MAAMc,aACX,WA//BM,EAygClBsQ,8BAAgC,SAC9BzF,EACAN,EACA5D,EACA4J,EACA5L,EACAiK,GAEI,IAIAC,EALJP,EACG,wDAEH,EAAKtC,SAAS,CAACF,sBAAsB,IAIrC+C,EAAqCA,EAApBP,EAAqC,sBAAyC,eAG/F,IAAMQ,EAAWC,IAAE,gBACnBD,EAASe,YAAYd,IAAE,iBAAiBe,OAAM,GAc9C,IAZA,IAAId,EAAc,EAAKX,oBACrB,EAAKnP,MAAMc,aACX,EACA2E,EACAkG,EAAyB3K,QAGvBU,EAAMT,KAAK8B,IACb4I,EAAyB3K,OACzBqK,EAA0BrK,QArBzB,WAwBMY,GACP,IAAIoH,EAAQ2C,EAAyB/J,GACjCqH,EAAQoC,EAA0BzJ,GACtC,GAAIA,IAAM+J,EAAyB3K,OAEjC,OAAGoO,GAAqB,EAAKpP,MAAMc,aAEnCiP,YAAW,WACLsB,EACF,EAAKrB,oBACHvI,GAGF,EAAKqF,SAAS,CAAEF,sBAAsB,MAEvC8C,EAAiBjK,GAVkC,CAAN,UAalDsK,YAAW,gBAEKuB,IAAVtI,IACFsF,SAASI,eAAT,eAAgC1F,EAAMzJ,IAAtC,YAA6CyJ,EAAMpK,MAAOgB,UAA1D,eAA8E+P,EAA9E,uCAEY2B,IAAVrI,IACFqF,SAASI,eAAT,eAAgCzF,EAAM1J,IAAtC,YAA6C0J,EAAMrK,MAAOgB,UAA1D,eAA8E+P,EAA9E,kCAEFC,EAAS5L,MAAT,YAAgC,EAAZ8L,EAApB,QAEClO,EAAI6D,IA5BA7D,EAAI,EAAGA,GAAKF,EAAKE,IAAK,CAAC,IAAD,IAAtBA,GAAsB,oCAziCf,EAykClBsN,mCAAqC,WACnC,IAAI,EAAKlP,MAAM4M,uBAAwB,EAAK5M,MAAM6M,eAAlD,CAIA,EAAK0E,gCAAkC,IAAItF,GAAUsF,IALZ,IAOjCtR,EAAS,EAAKD,MAAdC,KACFuR,EAAa,EAAKxR,MAAMY,UACxB6Q,EAAc,EAAKzR,MAAMa,WACzB6Q,EAAY,EAAK1R,MAAMsN,SACvB1M,EAAYX,EAAKuR,EAAW,IAAIA,EAAW,IAC3C3Q,EAAaZ,EAAKwR,EAAY,IAAIA,EAAY,IAC9C1Q,IAAW,EAAKf,MAAMc,aAAcb,EAAKyR,EAAU,IAAIA,EAAU,IAEpE,EAAK1R,MAAMc,aAEZ,EAAKyQ,gCAAgCrJ,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,GAAU,IAEzF,EAAKwQ,gCAAgClK,iBAAiB,WAAW,SAACC,GAE9D,IAAMqE,EAA2BrE,EAAQE,KAAK,GAAG,GAC3CmK,EAA+BrK,EAAQE,KAAK,GAAG,GAC/C6J,EAAgB/J,EAAQE,KAAK,GAAG,GAEhCoK,EAAgCtK,EAAQE,KAAK,GAAG,GAChD6D,EAA4B/D,EAAQE,KAAK,GAAG,GAC5CqK,EAAsBvK,EAAQE,KAAK,GAAG,GAEzCmE,EAAyB,KAAO/K,GAAW+K,EAAyB5D,QAAQnH,GAE5E+Q,EAA6B,KAAO5Q,GAAU4Q,EAA6B5J,QAAQhH,GAEnFsK,EAA0B,KAAOxK,GAAYwK,EAA0BtD,QAAQlH,GAElF,IAAM6O,EAAkB/D,EAAyB3K,OAAO2Q,EAA6B3Q,OAAO4Q,EAA8B5Q,OAAOqK,EAA0BrK,OAErJ8Q,EAAgCC,GACpCpG,EAAyBA,EAAyB3K,OAAS,GAC3D2Q,EAA6BA,EAA6B3Q,OAAS,IACnE,GAGIgR,EAAiCD,GACrCH,EAA8BA,EAA8B5Q,OAAS,GACrEqK,EAA0BA,EAA0BrK,OAAS,IAC7D,GAGIyG,EAAwB,sBAAOqK,GAAP,YAAyCE,IAEvEjC,YAAW,WACT,EAAKqB,8BACHzF,EACAgG,EACAlK,EACA4J,EACA,EAAKrR,MAAMyF,eACXiK,GACA,KAED,EAAK1P,MAAMyF,gBAEdsK,YAAW,WACT,EAAKqB,8BACHQ,EACAvG,EACA5D,EACAoK,EACA,EAAK7R,MAAMyF,eACXiK,GACA,KAED,EAAK1P,MAAMyF,gBAAiBkG,EAAyB3K,OAAO,GAAI2Q,EAA6B3Q,OAAO,SAIlG,EAAKhB,MAAMc,cAEpB,EAAKyQ,gCAAgCrJ,YAAY,CAACjI,EAAMW,EAAWC,EAAYE,IAE/E,EAAKwQ,gCAAgClK,iBAAiB,WAAW,SAACC,GAE9D,IAAMqE,EAA2BrE,EAAQE,KAAK,GACxC6D,EAA4B/D,EAAQE,KAAK,GAC3C6D,EAA0B,GAAGxM,UAAUwM,EAA0BtD,QAAQlH,GAE7E,IAAMwQ,EAAgB/J,EAAQE,KAAK,GAC7BC,EAA2BsK,GAC/BpG,EAAyBA,EAAyB3K,OAAS,GAC3DqK,EAA0BA,EAA0BrK,OAAS,IAG/D+O,YAAW,WACT,EAAKqB,8BACHzF,EACAN,EACA5D,EACA4J,EACA,EAAKrR,MAAMyF,kBAEZ,EAAKzF,MAAMyF,sBA9qCJ,EAqrClBuK,oBAAsB,SAACvI,GAErB,IAAM7G,EAAY,EAAKZ,MAAMC,KAAK,EAAKD,MAAMY,UAAU,IAAI,EAAKZ,MAAMY,UAAU,IAC1EC,EAAa,EAAKb,MAAMC,KAAK,EAAKD,MAAMa,WAAW,IAAI,EAAKb,MAAMa,WAAW,IAC7EE,EAAW,EAAKf,MAAMc,YAAc,EAAKd,MAAMC,KAAK,EAAKD,MAAMsN,SAAS,IAAI,EAAKtN,MAAMsN,SAAS,IAAM,GACtG2E,EAAyC,GAAhCxK,EAAyBzG,OAAW,EAEnD+O,YAAW,WAAO,EAAKjD,SAAS,CAACF,sBAAsB,MAAUqF,GAEjE,IATkD,eASzCrQ,GACPmO,YAAW,WACT,IAAM3P,EAAOqH,EAAyB7F,GAElCsQ,EAAU5D,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAE5DwB,EAAKb,MAAQqB,EAAUrB,KAAOa,EAAKxB,MAAQgC,EAAUhC,IACtDsT,EAAQtS,UAAY,oEACZQ,EAAKb,MAAQsB,EAAWtB,KAAOa,EAAKxB,MAAQiC,EAAWjC,IAC/DsT,EAAQtS,UAAY,oDACZ,EAAKI,MAAMc,aAAgBV,EAAKb,MAAQwB,EAASxB,KAAOa,EAAKxB,MAAQmC,EAASnC,IACtFsT,EAAQtS,UAAY,kDACZ0O,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAUuS,SAAS,sBACnFtC,IAAE,SAAD,OAAUzP,EAAKb,IAAf,YAAsBa,EAAKxB,MAAO+R,YAAYd,IAAE,SAAD,OAAUzP,EAAKb,IAAf,YAAsBa,EAAKxB,MAAOgS,OAAM,IAExFsB,EAAQtS,UAAY,4BAGrB,GAAKgC,IAlBDA,EAAI,EAAGA,EAAI6F,EAAyBzG,OAAQY,IAAM,EAAlDA,IA9rCO,EAstClBwQ,YAAc,SAAC5T,GACb,IADwB,IAAD,WACdoD,GACP,GAAIA,IAAMpD,EAAMwC,OAId,OAHA+O,YAAW,WACT,EAAKjD,SAAS,CAAED,gBAAgB,MAC3B,GAAJjL,GACG,CAAN,UAEFmO,YAAW,WAET,IAAI1N,EAAO7D,EAAMoD,GACbxB,EAAO,EAAKJ,MAAMC,KAAKoC,EAAK,IAAIA,EAAK,IACzCjC,EAAKrB,QAAS,EACduP,SAASI,eAAT,eAAgCtO,EAAKb,IAArC,YAA4Ca,EAAKxB,MAAOgB,UAAY,mBAE/D,GAAJgC,IAdIA,EAAI,EAAGA,GAAKpD,EAAMwC,OAAQY,IAAK,CAAC,IAAD,IAA/BA,GAA+B,oCAvtCxB,EAyuClByQ,mBAAqB,SAAC7T,GACpB,IAD8B,EAC1ByB,EAAO,EAAKD,MAAMC,KAClB0M,EAAU1M,EAAK2C,QAFW,cAGbpE,GAHa,IAG9B,2BAAwB,CAAC,IAAhB6D,EAAe,QAClBjC,EAAOH,EAAKoC,EAAK,IAAIA,EAAK,IAC1BiQ,EAAO,2BACNlS,GADM,IAETrB,QAAQ,IAEV4N,EAAQtK,EAAK,IAAIA,EAAK,IAAMiQ,GATA,8BAW9B,EAAKxF,SAAS,CAAE7M,KAAM0M,EAASE,gBAAgB,KAlvC7C,EAAK7M,MAAQ,CACTC,KAAM,GACNK,gBAAgB,EAChBmE,SAAS,EACTZ,aAAc,QACdc,YAAawC,GAAS,GACtBtC,WAAY3B,EAAQ,GACpByK,WAAY,EACZ4E,YAAa,0BACb/D,OAAQ,GACRC,OAAQ,GACRvH,YAAa,EACbtG,UAAW,CAAC,EAAG,GACfC,WAAY,CAAC,EAAG,IAChBkM,eAAe,EACfC,gBAAgB,EAChBlM,aAAa,EACbmM,cAAc,EACdK,SAAU,GACVT,gBAAgB,EAChBD,sBAAsB,EACtBnH,eAAgB,GAChBuI,WAAW,EACXC,MAAM,GAzBI,E,qDA+BlB,WAAqB,IAoBfuE,EApBc,OAEZC,EAAY,uCAAG,8BAAA5I,EAAA,yDACNlD,OAAOC,eAChB5C,EAAQ2C,OAAOE,YAER,KAJQ,gCAKX,EAAKiG,SAAS,CAAC0B,OAAQ,GAAIC,OAAQ,GAAI7N,UAAW,CAAC,GAAG,GAAIC,WAAW,CAAC,GAAI,MAL/D,mCAMTmD,EAAQ,KAAQA,EAAQ,KANf,kCAOX,EAAK8I,SAAS,CAAC0B,OAAQ,GAAIC,OAAQ,GAAI7N,UAAW,CAAC,GAAG,GAAIC,WAAW,CAAC,GAAI,MAP/D,qCAQTmD,EAAQ,MAAQA,EAAQ,KARf,kCASX,EAAK8I,SAAS,CAAC0B,OAAQ,GAAIC,OAAQ,GAAI7N,UAAW,CAAC,GAAG,GAAIC,WAAW,CAAC,GAAI,MAT/D,qCAUTmD,EAAQ,MAVC,kCAWX,EAAK8I,SAAS,CAAC0B,OAAQ,GAAIC,OAAQ,GAAI7N,UAAW,CAAC,GAAG,GAAIC,WAAW,CAAC,GAAI,MAX/D,QAcbZ,EAAOyS,GAAW,EAAK1S,MAAO,EAAKA,MAAMwO,OAAQ,EAAKxO,MAAMyO,QAClE,EAAK3B,SAAS,CAAC7M,KAAMA,IAfF,4CAAH,qDAoBlB0G,OAAOU,iBAAiB,UAAU,WAEhCsL,aAAaH,GAEbA,EAAczC,YAAW,WAEvB0C,MAEC,QAKLA,M,gCAsrCF,WAAsB,IAAD,OACf/T,KAAKsB,MAAM4M,sBAAwBlO,KAAKsB,MAAM6M,iBAGlDnO,KAAKoO,SAAS,CAAED,gBAAgB,IAChCkD,YAAW,WAAO,IACR9P,EAAS,EAAKD,MAAdC,KACFuR,EAAa,EAAKxR,MAAMY,UACxB6Q,EAAc,EAAKzR,MAAMa,WACzBD,EAAYX,EAAKuR,EAAW,IAAIA,EAAW,IAC3C3Q,EAAaZ,EAAKwR,EAAY,IAAIA,EAAY,IAC9C1Q,IAAW,EAAKf,MAAMc,aAAcb,EAAK,EAAKD,MAAMsN,SAAS,IAAI,EAAKtN,MAAMsN,SAAS,IACrF9O,EAAQ,EAAKwB,MAAMc,YAAcH,EAAWV,EAAMW,EAAWC,GAAY,EAAME,GAAYJ,EAAWV,EAAMW,EAAWC,GAAY,GACzI,EAAKuR,YAAY5T,KAChB,O,2CAGL,WAAiC,IAAD,OAC1BE,KAAKsB,MAAM4M,sBAAwBlO,KAAKsB,MAAM6M,iBAGlDnO,KAAKoO,SAAS,CAAED,gBAAgB,IAChCkD,YAAW,WAAO,IACR9P,EAAS,EAAKD,MAAdC,KACFuR,EAAa,EAAKxR,MAAMY,UACxB6Q,EAAc,EAAKzR,MAAMa,WACzBD,EAAYX,EAAKuR,EAAW,IAAIA,EAAW,IAC3C3Q,EAAaZ,EAAKwR,EAAY,IAAIA,EAAY,IAC9C1Q,IAAW,EAAKf,MAAMc,aAAcb,EAAK,EAAKD,MAAMsN,SAAS,IAAI,EAAKtN,MAAMsN,SAAS,IACrF9O,EAAQ,EAAKwB,MAAMc,YAAc0B,EAAsBvC,EAAMW,EAAWC,GAAY,EAAME,GAAYyB,EAAsBvC,EAAMW,EAAWC,GAAY,EAAOE,GACtK,EAAKqR,YAAY5T,KAChB,O,kCAGL,WAAwB,IAAD,OACjBE,KAAKsB,MAAM4M,sBAAwBlO,KAAKsB,MAAM6M,iBAGlDnO,KAAKoO,SAAS,CAAED,gBAAgB,IAChCkD,YAAW,WAAO,IACR9P,EAAS,EAAKD,MAAdC,KACFuR,EAAa,EAAKxR,MAAMY,UACxB6Q,EAAc,EAAKzR,MAAMa,WACzBD,EAAYX,EAAKuR,EAAW,IAAIA,EAAW,IAC3C3Q,EAAaZ,EAAKwR,EAAY,IAAIA,EAAY,IAC9C1Q,IAAW,EAAKf,MAAMc,aAAcb,EAAK,EAAKD,MAAMsN,SAAS,IAAI,EAAKtN,MAAMsN,SAAS,IACrF9O,EAAQ,EAAKwB,MAAMc,YAAcO,EAAapB,EAAMW,EAAWC,GAAY,EAAME,GAAYM,EAAapB,EAAMW,EAAWC,GAAY,GAC7I,EAAKuR,YAAY5T,KAChB,O,oCAGL,WAA0B,IAAD,OACnBE,KAAKsB,MAAM4M,sBAAwBlO,KAAKsB,MAAM6M,iBAGlDnO,KAAKoO,SAAS,CAAED,gBAAgB,IAChCkD,YAAW,WAAO,IACR9P,EAAS,EAAKD,MAAdC,KACFuR,EAAa,EAAKxR,MAAMY,UACxB6Q,EAAc,EAAKzR,MAAMa,WACzBD,EAAYX,EAAKuR,EAAW,IAAIA,EAAW,IAC3C3Q,EAAaZ,EAAKwR,EAAY,IAAIA,EAAY,IAC9C1Q,IAAW,EAAKf,MAAMc,aAAcb,EAAK,EAAKD,MAAMsN,SAAS,IAAI,EAAKtN,MAAMsN,SAAS,IACrF9O,EAAQ,EAAKwB,MAAMc,YAAcwB,EAAerC,EAAMW,EAAWC,GAAY,EAAME,GAAYuB,EAAerC,EAAMW,EAAWC,GAAY,GACjJ,EAAKuR,YAAY5T,KAChB,O,oBAGL,WAEI,OACI,sBAAKoB,UAAU,iBAAf,UACI,sBAAKA,UAAU,sBAAf,UACE,qBAAKA,UAAU,sBAAf,SACE,oBAAGA,UAAU,YAAb,iCAA6C,sBAAMA,UAAU,gBAAhB,SAAiClB,KAAKsB,MAAM6E,WAAW1B,YAEtG,qBAAKvD,UAAU,yBAAf,SACI,qBAAKA,UAAU,4BAA4BD,GAAG,qBAGpD,cAAC,GAAD,CAAQK,MAAOtB,KAAKsB,MAAOiH,mBAAoBvI,KAAKuI,mBAAoBD,eAAgBtI,KAAKsI,eAAgBF,UAAWpI,KAAKoI,UAAWC,UAAWrI,KAAKqI,UAAW/B,UAAWtG,KAAK6O,UAAW/H,kBAAmB9G,KAAK8G,kBAAmBS,eAAgBvH,KAAKuH,eAAgBN,QAASjH,KAAKqP,aAAc1I,KAAM3G,KAAKkQ,cAAexJ,WAAY1G,KAAK0G,WAAYgB,iBAAkB1H,KAAK8O,uBACxX,qBAAK5N,UAAU,uBAAf,SACI,cAAC,EAAD,CACII,MAAOtB,KAAKsB,MACZO,gBAAiB7B,KAAK6B,gBACtBC,iBAAkB9B,KAAK8B,iBACvBC,cAAe/B,KAAK+B,kBAG3BkG,OAAOE,WAAa,KAAQ,cAAC,GAAD,CAAQ7G,MAAOtB,KAAKsB,MAAOgF,UAAWtG,KAAK6O,UAAW/H,kBAAmB9G,KAAK8G,kBAAmBS,eAAgBvH,KAAKuH,eAAgBN,QAASjH,KAAKqP,aAAc1I,KAAM3G,KAAKkQ,cAAexJ,WAAY1G,KAAK0G,WAAYgB,iBAAkB1H,KAAK8O,qBAAsBqB,kBAAmBnQ,KAAKmQ,2B,GAl1ChS/O,cAw1CrC4S,GAAa,SAAC1S,EAAO4S,EAASC,GAIhC,IAHA,IAAM5S,EAAO,GACTuO,EAASoE,EACTnE,EAASoE,EACJtT,EAAM,EAAGA,EAAMiP,EAAQjP,IAAO,CAErC,IADA,IAAMuT,EAAa,GACVlU,EAAM,EAAGA,EAAM6P,EAAQ7P,IAAO,CACrC,IAAIwB,EAAO2S,GAAWnU,EAAKW,EAAKS,GAChCI,EAAKR,UAAY,OACjBkT,EAAW3R,KAAKf,GAElBH,EAAKkB,KAAK2R,GAEZ,OAAO7S,GAKL8S,GAAa,SAACnU,EAAKW,EAAKS,GAC1B,IAAMY,EAAYZ,EAAMY,UAClBC,EAAab,EAAMa,WACnBE,EAAWf,EAAMsN,SACvB,MAAO,CACL1O,MACAW,MACAT,QAASS,IAAQqB,EAAU,IAAMhC,IAAQgC,EAAU,GACnD/B,SAAUU,IAAQsB,EAAW,IAAMjC,IAAQiC,EAAW,GACtD3B,SAAQc,EAAMc,cAAcvB,IAAQwB,EAAS,IAAMnC,IAAQmC,EAAS,IACpEhC,QAAQ,EACRkJ,aAAc,KACdD,mBAAoB,KACpBhJ,WAAW,EACXC,iBAAiB,EACjBQ,SAAUiJ,IACVhJ,eAAgBgJ,MAIdyE,GAAsB,SAAClN,EAAMV,EAAKX,EAAKoU,GAE3C,IAAMrG,EAAU1M,EAAK2C,QACfqQ,EAAWtG,EAAQpN,GAAKX,GACxBsU,EAAWvG,EAAQqG,EAAU,IAAIA,EAAU,IAC3CG,EAAO,2BACRD,GADQ,IAEXpU,SAAUoU,EAASpU,UAEfwT,EAAO,2BACRW,GADQ,IAEXnU,SAAUmU,EAASnU,QACnBC,QAAQ,IAIV,OAFA4N,EAAQpN,GAAKX,GAAO0T,EACpB3F,EAAQqG,EAAU,IAAIA,EAAU,IAAMG,EAC/BxG,GAGHS,GAAuB,SAACnN,EAAMV,EAAKX,EAAKwU,GAE5C,IAAMzG,EAAU1M,EAAK2C,QACfyQ,EAAY1G,EAAQpN,GAAKX,GACzB0U,EAAY3G,EAAQyG,EAAW,IAAIA,EAAW,IAC9CD,EAAO,2BACRG,GADQ,IAEXzU,UAAWyU,EAAUzU,WAEjByT,EAAO,2BACRe,GADQ,IAEXxU,UAAWwU,EAAUxU,SACrBE,QAAQ,IAIV,OAFA4N,EAAQpN,GAAKX,GAAO0T,EACpB3F,EAAQyG,EAAW,IAAIA,EAAW,IAAMD,EACjCxG,GAGHO,GAA4B,SAACjN,EAAMV,EAAKX,GAC5C,IAAM+N,EAAU1M,EAAK2C,QACfxC,EAAOuM,EAAQpN,GAAKX,GACtB0T,EAAO,eAAOlS,GAMlB,OALAkS,EAAO,2BACFlS,GADE,IAELrB,QAASqB,EAAKrB,SAEhB4N,EAAQpN,GAAKX,GAAO0T,EACb3F,GAGHU,GAA4B,SAACpN,EAAMV,EAAKX,EAAK0O,GAEjD,IAAMX,EAAU1M,EAAK2C,QACf2Q,EAAU5G,EAAQpN,GAAKX,GAC7B,GAAuB,IAApB0O,EAAStM,OAAa,CACvB,IAAMsR,EAAO,2BACRiB,GADQ,IAEXrU,QAASqU,EAAQrU,OACjBH,QAAQ,IAGV,OADA4N,EAAQpN,GAAKX,GAAO0T,EACb3F,EAET,IAAM6G,EAAU7G,EAAQW,EAAS,IAAIA,EAAS,IACxC6F,EAAO,2BACRK,GADQ,IAEXtU,QAASsU,EAAQtU,SAEboT,EAAO,2BACRiB,GADQ,IAEXrU,QAASqU,EAAQrU,OACjBH,QAAQ,IAIV,OAFA4N,EAAQpN,GAAKX,GAAO0T,EACpB3F,EAAQW,EAAS,IAAIA,EAAS,IAAM6F,EAC7BxG,GAGHgC,GAAqB,SAAC1O,GAA4B,IAAD,EAArBwT,EAAqB,wDACjD9G,EAAU1M,EAAK2C,QADkC,cAErC3C,GAFqC,IAErD,2BAAsB,CAAC,IAAD,EAAbV,EAAa,sBACHA,GADG,IACpB,2BAAsB,CAAC,IAAda,EAAa,QAChBiC,GAAO,EACPkF,GAAO,EACRkM,IACExT,EAAKG,EAAKb,KAAKa,EAAKxB,KAAKG,SAAQsD,GAAO,GAExCpC,EAAKG,EAAKb,KAAKa,EAAKxB,KAAKM,SAAQqI,GAAO,IAE7C,IAAI+K,EAAO,2BACNlS,GADM,IAETX,SAAUiJ,IACVhJ,eAAgBgJ,IAChBqB,cAAerB,IACf1J,WAAW,EACXC,iBAAiB,EACjByU,YAAY,EACZzL,aAAc,KACdlJ,OAAQsD,EACRlD,UAAU,EACVD,OAAQqI,IAEVoF,EAAQvM,EAAKb,KAAKa,EAAKxB,KAAO0T,GAtBZ,gCAF+B,8BA2BrD,OAAO3F,GAGT,SAASoF,GACP/I,EACAC,GAKA,IAHC,IADD0K,EACA,wDACIlM,EAA2B,GAC3BU,EAAcc,EACK,OAAhBd,GACLV,EAAyBtG,KAAKgH,GAE5BA,EADCwL,EACaxL,EAAYH,mBAEZG,EAAYF,aAI9B,IADAE,EAAca,EACS,OAAhBb,GACLV,EAAyBM,QAAQI,GAE/BA,EADCwL,EACaxL,EAAYH,mBAEZG,EAAYF,aAG9B,OAAOR,EC7gDImM,OARf,WACE,OACE,qBAAKhU,UAAU,MAAf,SACE,cAAC,GAAD,OCOSiU,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFlG,SAASI,eAAe,SAM1BmF,O","file":"static/js/main.beb0235b.chunk.js","sourcesContent":["let walls;\nexport function verticalMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col) ||\n      (isThereStop && (temp === stopNode.row && num === stopNode.col))\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function horizontalMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode, isThereStop, stopNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode, isThereStop, stopNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode, isThereStop, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col) ||\n      (isThereStop && (num === stopNode.row && temp === stopNode.col))\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, isThereStop, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  \n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col) ||\n        (isThereStop && (temp === stopNode.row && num === stopNode.col))\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col) ||\n        (isThereStop && (num === stopNode.row && temp === stopNode.col))\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}","import React, {Component} from 'react';\nimport './Node.css'\n\nclass Node extends Component {\n\n    render() {\n        const {\n          col,\n          isFinish,\n          isStart,\n          isVisited,\n          isVisitedSecond,\n          isWall,\n          isWeight,\n          isStop,\n          onMouseDown,\n          onMouseEnter,\n          onMouseUp,\n          row,\n          distance,\n          distanceSecond\n        } = this.props;\n        const extraClassName = \n          isFinish\n          ? 'node-finish'\n          : isStart\n          ? 'node-start'\n          : isStop\n          ? 'node-stop'\n          : isWall\n          ? 'node-wall'\n          : ''\n    \n        return (\n          <div\n            id={`node-${row}-${col}`}\n            className={`node node-gap-vert node-gap-horiz ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={(e) => {\n              \n              onMouseEnter(row, col)\n            }}\n            onMouseUp={() => onMouseUp()}>\n          </div>\n        );\n      }\n}\n\nexport default Node;","import React, {Component} from 'react';\nimport './visualizer.css'\nimport Node from './Node/Node.jsx'\n\nexport default class PathfindingVisualizer extends Component{\n\n    render() {\n\n        return (\n            <div className=\"grid\">\n                {this.props.state.grid.map((row, rowIdx) => {\n                    return(\n                        <div key={rowIdx} className='grid-row'>\n                            {row.map((node, nodeIdx) => {\n                                const {row, col, isFinish, isStart, isWall, isWeight=false, isStop=false} = node;\n                                return (\n                                    <Node\n                                        key={nodeIdx}\n                                        col={col}\n                                        isFinish={isFinish}\n                                        isStart={isStart}\n                                        isWall={isWall}\n                                        isWeight={isWeight}\n                                        isStop={isStop}\n                                        mouseIsPressed={this.props.state.mouseIsPressed}\n                                        onMouseDown={(row, col) => this.props.handleMouseDown(row, col)}\n                                        onMouseEnter={(row, col) =>\n                                            this.props.handleMouseEnter(row, col)\n                                        }\n                                        onMouseUp={(row, col) => this.props.handleMouseUp(row, col)}\n                                        on\n                                        row={row}\n                                    />\n                                );\n                            })}\n                        </div>\n                    )\n                })}\n            </div>\n        )\n    }\n}\n\n","export function randomMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let walls = [];    \n\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          (row === startNode.row && col === startNode.col) ||\n          (row === finishNode.row && col === finishNode.col) ||\n          ( isThereStop && (row === stopNode.row && col === stopNode.col))\n        )\n          continue;\n\n        if (Math.random() < 0.33) {\n          walls.push([row, col]);\n        }\n      }\n    }\n    \n    walls.sort(() => Math.random() - 0.5);\n    return walls;\n  }","const algData = [\n    {\n        name: \"Dijkstra's algorithim\",\n        description: \"Dijkstra's Algorithm starts at the chosen source node and continues to expand outwards calculating distance up until the target node has been reached.\",\n        id: 0\n    },\n    {\n        name: \"A* search\",\n        description: \"A* search is identical to Dijkstra's but, it has brains. A* search calculates the theoretical distance from source to target using the pythagorean theorem.\",\n        id: 1\n    },\n    {\n        name: \"Greedy Best-first Search\",\n        description: \"Greedy Best-first Search is an algorithim which takes after depth-first search and breadth-first search, it uses the heuristic function and search.\",\n        id: 2\n    },\n    {\n        name: \"Bidirectional Greedy Search\",\n        description: \"Bidirectional Greedy Search is Greedy Best-first Search but rather than it searching from just the source it searches from the target as well.\",\n        id: 3\n    },\n    {\n        name: \"Breadth-first search\",\n        description: \"Breadth-first search searches every node in an organized manner until target has been reached but it does not calculate distance like Dijkstra's algorithim.\",\n        id: 4\n    },\n    {\n        name: \"Depth-first search\",\n        description: \"Depth-first search begins at the source node then explores along each branch before backtracking and starting on the next branch.\",\n        id: 5\n    }\n]\n\nexport default algData","export default \"data:image/png;base64,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\"","export default __webpack_public_path__ + \"static/media/dart-board.6357f04e.png\";","export default __webpack_public_path__ + \"static/media/stop.1934617d.png\";","import React, {Component} from 'react';\nimport algData from '../../data/alg-data'\nimport './nav.css'\nimport './navmini.css'\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\n\n\nexport default class Navbar extends Component {\n\n    useStyles = makeStyles(theme => ({\n        customHoverFocus: {\n          \"&:hover, &.Mui-focusVisible\": { backgroundColor: \"yellow\" }\n        }\n    }));    \n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n\n        return(\n                <div className={`nav-bar nav-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container'>\n                    <IconButton className=\"nav-btn\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"algs-container\">\n                    <div className=\"alg-selector\">\n                        <div className=\"alg-select-wrapper\">\n                        {\n                            algData.map((alg, val) => {\n                                return (\n                                    <button data-val={val} onClick={this.props.handleTabs}>{alg.name}</button>\n                                )\n                            })\n                        }\n                        </div>\n                    </div>\n                    <div className='alg-card'>\n                        <div className='alg-card-glass'>\n                            <h2 className=\"alg-card-title\">{currAlg.name}</h2>\n                            <div className=\"alg-card-text-container\">\n                                <p className=\"alg-card-desc\">{currAlg.description}</p>\n                            </div>\n                            <div className=\"play-btn-container\">\n                                <IconButton onClick={this.props.play}>\n                                    <PlayCircleFilledIcon className=\"play-btn\" size=\"10em\" fontSize=\"inherit\"/>\n                                </IconButton>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container\">\n                    <div className='speed-container'>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                            <RemoveIcon className='subtract-btn'/>\n                        </IconButton>\n                        <p className='speed-text'>{this.props.state.animationSpeed}</p>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                            <AddIcon className='add-btn'/>\n                        </IconButton>\n                    </div>\n                    <Button className=\"maze-btn\" onClick={this.props.genMaze} variant=\"contained\" fullWidth={true} color=\"primary\">\n                        <Typography className=\"maze-btn-text\">\n                            Generate\n                        </Typography>\n                    </Button>\n                    <div className=\"maze-selector\">\n                        <div className='maze-select-wrapper'>\n                        {mazeAlgs.map((title, val) => {\n                            return (\n                                <button data-val={val} onClick={this.props.handleMazeTabs}>{title}</button>\n                            )\n                        })}\n                        </div>\n                    </div>\n                </div>\n                <div className=\"items-container\">\n                    <div className={`item-card ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <h2 className=\"item-title\">{currItem.title}</h2>\n                        <div className=\"description-box\">\n                            <p className=\"item-description\">{currItem.description}</p>\n                        </div>\n                        {currItemPic}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","import React, {Component} from \"react\";\nimport algData from '../../data/alg-data'\nimport './navmini.css'\nimport IconButton from '@material-ui/core/IconButton';\nimport ReplayIcon from '@material-ui/icons/Replay';\nimport CloseIcon from '@mui/icons-material/Close';\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';\nimport KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';\nimport KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\nimport { FaAngleDoubleRight } from 'react-icons/fa'\n\nclass NavTop extends Component {\n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture-mini start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture-mini target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture-mini'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture-mini stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n\n    algChange = (e) => {\n        var val = e.target.dataset.val\n        console.log(val)\n    }\n\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n        const screenHeight = window.innerHeight\n\n        if(window.innerWidth > 1000) {\n            return(\n                <div className='side-nav-container'>\n                    <div className='reset-options-container'>\n                        <div className='reset-container'>\n                            <IconButton onClick={this.props.clearGrid} color=\"primary\">\n                                    <CloseIcon className=\"erase-btn\" />\n                            </IconButton>\n                        </div>\n                        <div className='erase-container'>\n                            <IconButton onClick={this.props.resetGrid} color=\"primary\">\n                                    <ReplayIcon className=\"reset-btn\" />\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n            )\n        }\n\n        return(\n            <div className={`nav-bar-mini nav-mini-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container-mini'>\n                    <IconButton className=\"nav-btn-mini\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"top-container-mini\">\n                    <div className=\"alg-selector-mini\">\n                        <div className=\"alg-select-wrapper-mini\">\n                            {\n                                algData.map((alg, val) => {\n                                    if(alg.id === currAlg.id) return ( <h4 className='title-mini'>{alg.name}</h4> )\n                                })\n                            }\n                            <IconButton onClick={this.props.handleMiniTabs}>\n                                <ArrowForwardIosIcon className=\"next-btn\" fontSize=\"inherit\"/>\n                            </IconButton>\n                        </div>\n                    </div>\n                    <div className=\"alg-card-mini\">\n                        <div className=\"alg-text-mini\">\n                            <h2>{currAlg.name}</h2>\n                            <p>{currAlg.description}</p>\n                        </div>\n                        <div className=\"alg-play-mini\">\n                            <IconButton onClick={this.props.play}>\n                                <PlayCircleFilledIcon className=\"play-mini\" size=\"10em\" fontSize=\"inherit\"/>\n                            </IconButton>\n                            <IconButton onClick={this.props.clearGrid} color=\"primary\">\n                                <CloseIcon className=\"erase-mini\" />\n                            </IconButton>\n                            <IconButton onClick={this.props.resetGrid} color=\"primary\">\n                                <ReplayIcon className=\"reset-mini\" />\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container-mini\">\n                    <button className='generate-btn-mini' onClick={this.props.genMaze}>Generate Maze</button>\n                    <div className=\"card-container-mini\">\n                        <div className=\"maze-alg-selector-mini\">\n                            <IconButton onClick={() => this.props.handleMiniMazeTabs(true)}>\n                                <KeyboardArrowUpIcon className='arrow-btn-up'/>\n                            </IconButton>\n                            {\n                                mazeAlgs.map((alg, val) => {\n                                    if(val === this.props.state.currMazeTab) return (\n                                        <div className=\"maze-title-mini\"><h4 className='title-mini'>{alg}</h4></div>\n                                    )\n                                })\n                            }\n                            <IconButton onClick={() => this.props.handleMiniMazeTabs(false)}>\n                                <KeyboardArrowDownIcon className='arrow-btn-down'/>\n                            </IconButton>\n                        </div>\n                        <div className=\"speed-controls-container-mini\">\n                            <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                                <RemoveIcon className='subtract-btn'/>\n                            </IconButton>\n                            <p className='speed-text-mini'>{this.props.state.animationSpeed}</p>\n                            <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                                <AddIcon className='add-btn'/>\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"bottom-container-mini\">\n                    <div className={`item-card-mini ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <div className='item-info-mini'>\n                            <h2>{currItem.title}</h2>\n                            <div className=\"item-text-mini\">\n                                <p>{currItem.description}</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default NavTop","const itemData = [\n    {\n        id: 'Start',\n        title: 'Start Node',\n        description: 'The Start node represents where we will start. You can click and drag the start node around anywhere on the grid to create a new starting point.'\n    },\n    {\n        id: 'Target',\n        title: 'Target Node',\n        description: 'The target node represents the desired destination. You can click and drag the target node around anywhere on the grid to create a new destination.'\n    },\n    {\n        id: 'Wall',\n        title: 'Wall',\n        description: 'Walls represent obstructions that stand in the way of you and your destination. Click and drag anywhere on the grid to create walls.'\n    },\n    // {\n    //     id: 'Weight',\n    //     title: 'Wheight',\n    //     description: 'Wheights represent a node that will take longer to travel through than a regular node. Click and drag to drop wheights on the grid.'\n    // },\n    {\n        id: 'Stop',\n        title: 'Stop',\n        description: 'A stop node represents a sub destination. This means that we must find the shortest route that includes a stop at the stop node.'\n    }\n]\n\nexport default itemData","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n\n        if (!message) return;\n\n        var stopNode=false, finishNode=false, startNode=false\n\n        const stop = message.data[1]\n        const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0]\n\n        nodes.map((node) => {\n\n            if(node.isStop === true) stopNode = node\n\n            if(node.isFinish === true) finishNode = node\n\n            if(node.isStart === true) startNode = node\n\n            return node\n        })\n\n        var nodesInShortestPathOrder = [];\n\n        if(!stop) {\n\n            if(finishNode === false) postMessage(false)\n\n            let currentNode = finishNode\n\n            while (currentNode !== null) {\n\n                if(currentNode.isStart===true) break\n\n                nodesInShortestPathOrder.unshift(currentNode)\n\n                currentNode = currentNode.previousNode\n            }\n\n            if(!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode)\n\n            postMessage(nodesInShortestPathOrder)\n\n        } else if(stop) {\n\n            var startToStop=[], stopToFinish=[]\n            let currentNodeFin = finishNode\n            let currentNodeStop = stopNode\n\n            if (message.data[0][1].filter(node => node.isFinish === true).length > 0) {\n                while (currentNodeFin !== null) {\n\n                    if(currentNodeFin.isStop===true) break;\n    \n                    stopToFinish.unshift(currentNodeFin);\n    \n                    currentNodeFin = currentNodeFin.previousNodeSecond;\n                }\n                if(!stopToFinish[0].isStop) stopToFinish.unshift(stopNode)\n            } else {\n                stopToFinish.unshift(false)\n            }\n\n            if (message.data[0][0].filter(node => node.isStop === true).length > 0) {\n                while (currentNodeStop !== null) {\n\n                    if(currentNodeStop.isStart===true) break;\n\n                    startToStop.unshift(currentNodeStop);\n\n                    currentNodeStop = currentNodeStop.previousNode;\n                }\n                if(!startToStop[0].isStart) startToStop.unshift(startNode)\n\n            } else {\n                startToStop.unshift(false)\n            }\n\n            postMessage([startToStop, stopToFinish])\n        }\n    })\n}","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function dijkstra(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n            console.log(stopNode)\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else {\n                node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){     \n                sortNodesByDistance(unvisitedNodes, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            } else if(isStop){\n            //going to repeat normal function yet twice for stop\n            const visitedNodesInOrder = [[],[]]\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n        \n            var unvisitedNodesSecond = getAllNodes(grid)\n              \n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else if(node === stopNode) {\n                node.distanceSecond = 0\n                } else {\n                node.distance = Infinity\n                node.distanceSecond = Infinity\n                }\n            })\n        \n            //getting path from start to stop\n            while(!!unvisitedNodes) {\n                sortNodesByDistance(unvisitedNodes, false)\n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) break\n        \n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder[0].push(closestNode)\n        \n                //checking to see is closest node is the finishnode\n                if(closestNode === stopNode) break\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            \n            //getting path from stop to finish\n            while(!!unvisitedNodesSecond) {\n                \n                sortNodesByDistance(unvisitedNodesSecond, true)\n\n                const closestNode = unvisitedNodesSecond.shift()\n        \n                if(closestNode.isWall) continue\n        \n                if(closestNode.distanceSecond === Infinity) break\n\n                closestNode.isVisitedSecond = true\n                visitedNodesInOrder[1].push(closestNode)\n        \n                if(closestNode === finishNode) break\n        \n                updateUnvisitedNeighbors(closestNode, grid, true)\n            }\n            return visitedNodesInOrder\n        }\n    }\n\n        function sortNodesByDistance(unvisitedNodes, isStop) {\n            //it is not calculating second distace correctly stays at infinity\n            unvisitedNodes.sort((nodeA, nodeB) => {\n              if(isStop===true) {\n\n                return nodeA.distanceSecond - nodeB.distanceSecond\n              } else {\n                \n                return nodeA.distance - nodeB.distance\n              }\n            });\n            var distanceCheck = []\n            if(isStop){\n              unvisitedNodes.forEach((node) => {\n                if(node.distanceSecond !== Infinity) distanceCheck.push(node)\n              })\n            }\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop)\n            for (const neighbor of unvisitedNeighbors) {\n              isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1\n        \n              isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node\n            }\n        }\n          \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node\n            if (row > 0) neighbors.push(grid[row - 1][col])\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\n            if (col > 0) neighbors.push(grid[row][col - 1])\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\n            return neighbors.filter((neighbor) => {\n              //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n              if(isStop===true){\n                return !neighbor.isVisitedSecond\n              } else {\n                return !neighbor.isVisited\n              }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = []\n            for (const row of grid) {\n              for (const node of row) {\n                nodes.push(node)\n              }\n            }\n            return nodes\n        }\n\n\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = dijkstra(grid, startNode, finishNode, stopNode)\n  \n        postMessage(visitedNodesInorder)\n    });\n};\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode, stop=false) {\n      const nodesInShortestPathOrder = []\n      let currentNode = finishNode\n      while (currentNode !== null) {\n\n        if(currentNode.isStart===true && stop===false || typeof currentNode.previousNode !== 'object') break\n\n        if(currentNode.isStop===true && stop===true) break\n\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n      }\n      return nodesInShortestPathOrder\n  }","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n\n        function aStar(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                    node.distance = 0\n                } else {\n                    node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){\n\n                sortNodesByDistance(unvisitedNodes, finishNode, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false);\n            }\n            } else if(isStop){\n                //going to repeat normal function yet twice for stop\n                const visitedNodesInOrder = [[],[]]\n                //grabbing all nodes   \n                var unvisitedNodes = getAllNodes(grid)\n                     \n                var unvisitedNodesSecond = getAllNodes(grid)\n            \n                unvisitedNodes.forEach((node) => {\n                    if(node === startNode){\n                        node.distance = 0\n                    } else if(node === stopNode) {\n                        node.distanceSecond = 0\n                    } else {\n                        node.distance = Infinity\n                        node.distanceSecond = Infinity\n                    }\n                })\n            \n                //getting path from start to stop\n                while(!!unvisitedNodes) {\n                    sortNodesByDistance(unvisitedNodes, stopNode, false)\n                    const closestNode = unvisitedNodes.shift()\n            \n                    //checking if current node is a wall\n                    if(closestNode.isWall) continue\n            \n                    //checking if node has no where to venture to\n                    if(closestNode.distance === Infinity) break\n            \n                    //update current node as visited then pushing it to visitednodes array\n                    closestNode.isVisited = true\n                    visitedNodesInOrder[0].push(closestNode)\n            \n                    //checking to see is closest node is the finishnode\n                    if(closestNode === stopNode) break\n            \n                    //get current nodes neighbors\n                    updateUnvisitedNeighbors(closestNode, grid, false);\n                }\n                \n                //getting path from stop to finish\n                while(!!unvisitedNodesSecond) {\n                    \n                    sortNodesByDistance(unvisitedNodesSecond, finishNode, true)\n\n                    const closestNode = unvisitedNodesSecond.shift()\n            \n                    if(closestNode.isWall) continue\n            \n                    if(closestNode.distanceSecond === Infinity) break\n\n                    closestNode.isVisitedSecond = true\n                    visitedNodesInOrder[1].push(closestNode)\n            \n                    if(closestNode === finishNode) break\n            \n                    updateUnvisitedNeighbors(closestNode, grid, true)\n                }\n                return visitedNodesInOrder\n            }\n        }\n\n        function sortNodesByDistance(unvisitedNodes, finishNode, isStop) {\n            // calculating f\n            const f = finishNode\n            unvisitedNodes.sort((nodeA, nodeB) => {\n                const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n                const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n\n                if(isStop){\n                    return (nodeA.distanceSecond+af) - (nodeB.distanceSecond+bf)\n                } else {\n                    return (nodeA.distance+af) - (nodeB.distance+bf)\n                }\n            });\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop);\n            for (const neighbor of unvisitedNeighbors) {\n                \n                isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1;\n        \n                isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node;\n            }\n        }\n        \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node;\n            if (row > 0) neighbors.push(grid[row - 1][col]);\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n            if (col > 0) neighbors.push(grid[row][col - 1]);\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n            return neighbors.filter((neighbor) => {\n            //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n            if(isStop===true){\n                return !neighbor.isVisitedSecond\n            } else {\n                return !neighbor.isVisited\n            }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = [];\n            for (const row of grid) {\n            for (const node of row) {\n                nodes.push(node);\n            }\n            }\n            return nodes;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = aStar(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}","var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                \n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = []\n                let unvisitedNodesSecond = []\n                let firstSearch = []\n                let secondSearch = []\n                startNode.distance = 0\n                unvisitedNodes.push(startNode)\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance)\n                  let closestNode = unvisitedNodes.shift()\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour)\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                  let closestNode = unvisitedNodesSecond.shift()\n                  if (closestNode === finishNode) {\n                    secondSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisitedSecond = true\n                  secondSearch.push(closestNode)\n              \n                  let neighbours = getNeighbours(closestNode, grid, true)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n                      unvisitedNodesSecond.unshift(neighbour)\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    } else if (distance < neighbour.distanceSecond) {\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    }\n                  }\n                }\n\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            }\n            return neighbour.filter(\n              (node) => {\n                  if(isStop){\n                    return !node.isWall && !node.isVisitedSecond\n                  } else {\n                    return !node.isWall && !node.isVisited\n                  }\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row)\n            let y = Math.abs(node.col - finishNode.col)\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false\n              }\n            }\n            return true\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = []\n    let currentNode = finishNode\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder\n}","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                let queueSecond = [];\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode);\n                queueSecond.push(stopNode)\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        visitedNodesInOrder[0].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                while (queueSecond.length) {\n                    const currNode = queueSecond.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder[1].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n                return visitedNodesInOrder\n\n            } else if(!isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode);\n                        return visitedNodesInOrder;\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                return visitedNodesInOrder\n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n\n            let unvisitedNodesStart = []\n            let visitedNodesInOrderStart = []\n            let unvisitedNodesFinish = []\n            let visitedNodesInOrderFinish = []\n            startNode.distance = 0\n            finishNode.distance = 0\n            unvisitedNodesStart.push(startNode)\n            unvisitedNodesFinish.push(finishNode)\n        \n            while (\n                unvisitedNodesStart.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                let closestNodeStart = unvisitedNodesStart.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n        \n                closestNodeStart.isVisited = true;\n                closestNodeFinish.isVisited = true;\n                visitedNodesInOrderStart.push(closestNodeStart);\n                visitedNodesInOrderFinish.push(closestNodeFinish);\n                if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                }\n            \n                //Start side search\n                let neighbours = getNeighbours(closestNodeStart, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStart.push(closestNodeStart);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeStart.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        unvisitedNodesStart.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    }\n                }\n            \n                //Finish side search\n                neighbours = getNeighbours(closestNodeFinish, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStart.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                    }\n                }\n            }\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n                      \n        }\n\n        function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n\n            let unvisitedNodesStop = [];\n            let visitedNodesInOrderStop = [];\n            let unvisitedNodesFinish = [];\n            let visitedNodesInOrderFinish = [];\n            stopNode.distanceSecond = 0\n            finishNode.distanceSecond = 0\n            unvisitedNodesStop.push(stopNode)\n            unvisitedNodesFinish.push(finishNode)\n\n            while (\n                unvisitedNodesStop.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStop = unvisitedNodesStop.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStop.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStop.push(closestNodeStop)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                    return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStop, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStop.push(closestNodeStop);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true]\n                    }\n                    let distance = closestNodeStop.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        unvisitedNodesStop.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStop\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStop;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStop.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        var visitedNodesInorder = []\n\n        if (isStop) {\n\n            visitedNodesInorder = [bidirectionalGreedySearch(grid, startNode, stopNode), bidirectionalGreedySearchSecond(grid, stopNode, finishNode)]\n            postMessage(visitedNodesInorder)\n        } else {\n\n            visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n            postMessage(visitedNodesInorder);\n        }\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","\nexport default class WebWorker {\n    constructor(worker) {\n      const code = worker.toString();\n      const blob = new Blob([\"(\" + code + \")()\"]);\n      return new Worker(URL.createObjectURL(blob));\n    }\n}","import React, {Component} from 'react';\nimport $ from 'jquery' \nimport Visualizer from './PathFindingVisualizer/Visualizer'\nimport { randomMaze } from '../mazeAlgorithims/randomMaze';\nimport { verticalMaze } from '../mazeAlgorithims/verticalMaze';\nimport { horizontalMaze } from '../mazeAlgorithims/HorizontalMaze';\nimport { recursiveDivisionMaze } from '../mazeAlgorithims/recursiveDivisionMaze';\nimport Navbar from './navComponents/Navbar';\nimport NavTop from './navComponents/sideNav';\nimport itemData from '../data/item-data'\nimport algData from '../data/alg-data'\nimport pathGrabWorker from '../workers/pathGrabWorker';\nimport _dijkstraWorker from \"../workers/dijkstraWorker\";\nimport aStarWorker from '../workers/aStarWorker'\nimport greedyBestFirstSearchWorker from '../workers/greedyBestFirstSearchWorker';\nimport breadthFirstSearchWorker from '../workers/breadthFirstSearchWorker';\nimport depthFirstSearchWorker from '../workers/depthFirstSearchWorker';\nimport bidirectionalGreedySearchWorker from '../workers/bidirectionalGreedySearchWorker';\nimport WebWorker from \"../workers/workerSetup\";\nimport './mainContainer.css'\n\nexport default class MainContainer extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n            showNav: false,\n            currItemDesc: 'Start',\n            currItemObj: itemData[0],\n            currAlgObj: algData[0],\n            currAlgTab: 0,\n            currMazeAlg: 'Recursive Division Maze',\n            rowNum: 24,\n            colNum: 49,\n            currMazeTab: 0,\n            startNode: [9, 1],\n            finishNode: [9, 47],\n            startIsMoving: false,\n            finishIsMoving: false,\n            isThereStop: false,\n            stopIsMoving: false,\n            prevStop: [],\n            generatingMaze: false,\n            visualizingAlgorithm: false,\n            animationSpeed: 20,\n            gridClean: true,\n            maze: false\n        }\n    }\n    //reminder!!\n    // row is width\n    // col is height\n    componentDidMount() {\n\n      const handleResize = async () => {\n        var height = window.innerHeight\n        var width = window.innerWidth\n\n        if(width < 500) {\n          await this.setState({rowNum: 24, colNum: 12, startNode: [12,1], finishNode:[12, 10]})\n        } else if(width < 1000 && width > 500) {\n          await this.setState({rowNum: 30, colNum: 23, startNode: [15,1], finishNode:[15, 21]})\n        } else if(width < 1200 && width > 1000) {\n          await this.setState({rowNum: 24, colNum: 35, startNode: [15,1], finishNode:[15, 21]})\n        } else if(width > 1200) {\n          await this.setState({rowNum: 24, colNum: 49, startNode: [12,1], finishNode:[12, 47]})\n        }\n\n        const grid = renderGrid(this.state, this.state.rowNum, this.state.colNum)\n        this.setState({grid: grid});\n      }\n      \n      var resizeTimer;\n\n      window.addEventListener('resize', () => {\n\n        clearTimeout(resizeTimer);\n\n        resizeTimer = setTimeout(function() {\n      \n          handleResize()\n                  \n        }, 250);\n      })\n\n      // const grid = renderGrid(this.state, this.state.rowNum, this.state.colNum)\n      // this.setState({grid: grid});\n      handleResize()\n    }\n\n    handleMouseDown = (row, col) => {\n\n        var newGrid = this.state.grid\n        var node = newGrid[row][col]\n\n        if(this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.grid[row][col].isStart){\n          this.setState({startIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.grid[row][col].isFinish){\n          this.setState({finishIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.currItemDesc === 'Stop'){\n          this.setState({stopIsMoving: true, isThereStop: true})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col)   \n        }\n        this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n    \n    handleMouseEnter = (row, col) => {\n\n        if (!this.state.mouseIsPressed) return;\n\n        var newGrid = this.state.grid;\n        var node = newGrid[row][col]\n\n        if( node.isStart || node.isStop || node.isFinish || this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.startIsMoving){\n          newGrid = getNewGridWithStart(this.state.grid, row, col, this.state.startNode)\n          this.setState({startNode: [row, col]})\n        } else if(this.state.finishIsMoving){\n          newGrid = getNewGridWithFinish(this.state.grid, row, col, this.state.finishNode)\n          this.setState({finishNode: [row, col]})\n        } else if(this.state.currItemDesc === 'Stop'){\n          newGrid = getNewGridWithStopToggled(this.state.grid, row, col, this.state.prevStop);\n          this.setState({prevStop: [row, col]})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col);\n        }\n        this.setState({grid: newGrid});\n    }\n    \n    handleMouseUp = (row, col) => {\n        this.setState({mouseIsPressed: false, startIsMoving: false, finishIsMoving: false});\n    }\n\n    handleNav = () => {\n      this.setState({showNav: !this.state.showNav})\n    }\n\n    //navBar functions\n    handleItemDescChange = (e, item) => {\n      var newItem = `${item}`\n      itemData.map((_item) => {\n        if(item === _item.id) this.setState({currItemDesc: newItem, currItemObj: _item})\n\n        return _item\n      })\n    }\n\n    handleTabs = (e) => {\n      var val = e.target.dataset.val\n      this.setState({currAlgTab: val, currAlgObj: algData[val]})\n    }\n\n    handleMiniTabs = (e) => {\n      var val = this.state.currAlgTab\n      if(val+1 > algData.length-1){\n        val = 0\n      } else {\n        val++\n      }\n\n      this.setState({currAlgTab: val, currAlgObj: algData[val]})\n    }\n\n    handleMazeTabs = (e) => {\n      var val = parseInt(e.target.dataset.val)\n      this.setState({currMazeTab: val})\n    }\n\n    handleMiniMazeTabs = (up) => {\n      var val = this.state.currMazeTab\n\n      if(up) {\n        if(val <= 0) {\n          this.setState({currMazeTab: 3})\n          return\n        }\n        val--\n      } else {\n        if(val >= 3) {\n          this.setState({currMazeTab: 0})\n          return\n        }\n        val++\n      }\n\n      this.setState({currMazeTab: val})\n    }\n\n    handleSpeedChange = (e, val) => {\n      var currSpeed = this.state.animationSpeed\n\n      if(val && currSpeed > 5){\n        this.setState({animationSpeed: currSpeed-5})\n      } if(!val && currSpeed < 35){\n        this.setState({animationSpeed: currSpeed+5})\n      }\n    }\n\n    generateMaze = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean || this.state.maze) return\n\n      this.setState({maze: true})\n\n      var currAlg = this.state.currMazeTab\n \n      if(currAlg===0){\n        this.generateRecursiveDivisionMaze()\n      } else if(currAlg===1){\n        this.generateVerticalMaze()\n      } else if(currAlg===2){\n        this.generateHorizontalMaze()\n      } else if(currAlg===3){\n        this.generateRandomMaze()\n      }\n    }\n\n    resetGrid = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n\n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const grid = this.state.grid\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n      const stopNode = this.state.isThereStop ? this.state.prevStop : false\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else if(stopNode !== false && (row === stopNode[0] && col === stopNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-stop\";\n          } else if(grid[row][col].isWall)\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-wall\";\n          } else {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid, true);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    clearGrid = () => {\n\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n      \n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        prevStop: [],\n        isThereStop: false  ,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    // play animation\n\n    playAnimation = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean) return\n\n      var currAlg = this.state.currAlgObj.id\n      this.setState({\n        gridClean: false,\n        visualizingAlgorithm: true,\n        showNav: false\n      })\n      if(currAlg===0){\n        this.visualizeDijkstra()\n      } else if(currAlg===1){\n        this.visualizeaStar()\n      } else if(currAlg===4){\n        this.visualizbfs()\n      } else if(currAlg===2){\n        this.visualizegbfs()\n      } else if(currAlg===5){\n        this.visualizedfs()\n      } else if(currAlg===3){\n        this.visualizeBidirectionalGreedySearch()\n      }\n      return\n    }\n\n    handleProgressSetup = (\n      isThereStop, \n      isSecondAnimation, \n      animationSpeed,\n      animationDuration,\n    ) => {\n\n      const progressBar = document.getElementById(`progressBar`)\n      progressBar.className = 'progress progress-no-stop'\n      \n      if(!isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 100/animationDuration\n\n      } else if(!isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 50/animationDuration\n\n      } else if(isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-stop-anime')\n          progressBar.className = 'progress progress-stop'\n        })\n        return 50/animationDuration\n\n      }\n    }\n\n    //animte dijkstra\n\n    animateDijkstra = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed=10, \n      isThereStop=false,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor;\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progressTracker\n      const progress = $(\"#progressBar\")\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n    \n    visualizeDijkstra = () => {\n\n      this.dijkstraWorker = new WebWorker(_dijkstraWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      if(this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n            \n            const animateTiming = async (message) => {\n\n                this.pathGrabWorker.postMessage([message.data, true])\n\n                this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                    const animateTime = (message, messageTwo) => {\n\n                      var nodesInShortestPathOrder;\n\n                      if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                      } else if(messageTwo.data[0][0] === false) {\n                        nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                      } else if(messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                      } else {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                      }\n\n                      this.animateDijkstra(\n                        message.data[0], \n                        nodesInShortestPathOrder, \n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop,\n                        false\n                      )\n\n                      setTimeout(this.animateDijkstra, \n                        message.data[0].length * this.state.animationSpeed, \n                        message.data[1], \n                        nodesInShortestPathOrder,\n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop, \n                        true\n                      )\n                    }\n\n                    animateTime(message, messageTwo)\n                })\n            }\n            animateTiming(message)\n        })\n\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animateDijkstra(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop\n              )\n\n            })\n        })\n      }\n    }\n\n    //animate aStar\n\n    animateaStar = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed,\n      isThereStop, \n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizeaStar = () => {\n\n      this.aStarWorker = new WebWorker(aStarWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n        this.aStarWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.aStarWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animateaStar(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animateaStar, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n        }\n        animateTiming(message)\n    })\n          return\n          \n      } else if(!this.state.isThereStop){\n\n          this.aStarWorker.postMessage([grid, startNode, finishNode, false])\n\n          this.aStarWorker.addEventListener('message', (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, false])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n                this.animateaStar(\n                  message.data, \n                  nodesInShortestPathOrder, \n                  message.data.length,\n                  this.state.animationSpeed,\n                  this.state.isThereStop,\n                  false\n                )\n\n              })\n          })\n      }\n    }\n\n    //animate breadth first search \n\n    animatebfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n          \n          setTimeout(this.animateShortestPath, animationSpeed*animationStall, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          progress.width(`+=${integralVal}%`)\n        }, animationSpeed * i);\n      }\n    }\n\n    visualizbfs = () => {\n      \n      this.breadthFirstSearchWorker = new WebWorker(breadthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n                       \n            const animateTiming = async (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, true])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                  const animateTime = (message, messageTwo) => {\n\n                    var nodesInShortestPathOrder;\n\n                    if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                    } else if(messageTwo.data[0][0] === false) {\n                      nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                    } else if(messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                    } else {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                    }\n\n                    this.animatebfs(\n                      message.data[0], \n                      nodesInShortestPathOrder, \n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      false\n                    )\n\n                    setTimeout(this.animatebfs, \n                      message.data[0].length * this.state.animationSpeed, \n                      message.data[1], \n                      nodesInShortestPathOrder,\n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      true\n                    )\n                  }\n\n                  animateTime(message, messageTwo)\n              })\n            }\n          animateTiming(message)\n      })\n      return\n\n      } else if(!this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatebfs(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                false\n              )\n            })\n        })\n      }\n    }\n\n    // greedy best first search\n\n    animategbfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizegbfs = () => {\n      \n      this.greedyBestFirstSearchWorker = new WebWorker(greedyBestFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n\n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animategbfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animategbfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n      \n      } else if(!this.state.isThereStop) {\n        \n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animategbfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop,\n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // depth first search\n\n    animatedfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizedfs = () => {\n            \n      this.depthFirstSearchWorker = new WebWorker(depthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      \n      if(this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animatedfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(\n                    this.animatedfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatedfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed,\n                this.state.isThereStop, \n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // bidirectional greedy first search\n\n    animateBidirectionalAlgorithm = (\n      visitedNodesInOrderStart,\n      visitedNodesInOrderFinish,\n      nodesInShortestPathOrder,\n      isShortedPath,\n      animationSpeed,\n      animationStall,\n      isSecondAnimation=false\n    ) => {\n\n      this.setState({visualizingAlgorithm: true})\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        this.state.isThereStop,\n        false,\n        animationSpeed,\n        visitedNodesInOrderStart.length\n      )\n\n      let len = Math.max(\n        visitedNodesInOrderStart.length,\n        visitedNodesInOrderFinish.length\n      );\n\n      for (let i = 1; i <= len; i++) {\n        let nodeA = visitedNodesInOrderStart[i];\n        let nodeB = visitedNodesInOrderFinish[i];\n        if (i === visitedNodesInOrderStart.length) {\n\n          if(isSecondAnimation && this.state.isThereStop) return\n\n          setTimeout(() => {\n            if (isShortedPath) {\n              this.animateShortestPath(\n                nodesInShortestPathOrder\n              );\n            } else {\n              this.setState({ visualizingAlgorithm: false });\n            }\n          }, animationStall * animationSpeed);\n          return;\n        }\n        setTimeout(() => {\n          //visited nodes\n          if (nodeA !== undefined) {\n            document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          if (nodeB !== undefined) {\n            document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          progress.width(`+=${integralVal*2}%`)\n\n        }, i * animationSpeed);\n      }\n    }\n\n    visualizeBidirectionalGreedySearch = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n\n      this.bidirectionalGreedySearchWorker = new WebWorker(bidirectionalGreedySearchWorker)\n\n      const { grid } = this.state;\n      const _startNode = this.state.startNode\n      const _finishNode = this.state.finishNode\n      const _stopNode = this.state.prevStop\n      const startNode = grid[_startNode[0]][_startNode[1]];\n      const finishNode = grid[_finishNode[0]][_finishNode[1]];\n      const stopNode = this.state.isThereStop ? grid[_stopNode[0]][_stopNode[1]] : false\n\n      if(this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode, true])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0][0];\n            const visitedNodesInOrderStopFirst = message.data[0][1];\n            const isShortedPath = message.data[0][2];\n\n            const visitedNodesInOrderStopSecond = message.data[1][0]\n            const visitedNodesInOrderFinish = message.data[1][1]\n            const isShortedPathSecond = message.data[1][2]\n\n            if(visitedNodesInOrderStart[0] !== startNode) visitedNodesInOrderStart.unshift(startNode)\n\n            if(visitedNodesInOrderStopFirst[0] !== stopNode) visitedNodesInOrderStopFirst.unshift(stopNode)\n\n            if(visitedNodesInOrderFinish[0] !== finishNode) visitedNodesInOrderFinish.unshift(finishNode)\n\n            const animationStall = (visitedNodesInOrderStart.length+visitedNodesInOrderStopFirst.length+visitedNodesInOrderStopSecond.length+visitedNodesInOrderFinish.length)\n\n            const nodesInShortestPathOrderFirst = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderStopFirst[visitedNodesInOrderStopFirst.length - 1],\n              false\n            )\n\n            const nodesInShortestPathOrderSecond = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStopSecond[visitedNodesInOrderStopSecond.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1],\n              true\n            )\n\n            const nodesInShortestPathOrder = [...nodesInShortestPathOrderFirst, ...nodesInShortestPathOrderSecond]\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderStopFirst,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed,\n                animationStall,\n                false\n              );\n            }, this.state.animationSpeed);\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStopSecond,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPathSecond,\n                this.state.animationSpeed,\n                animationStall,\n                true\n              );\n            }, this.state.animationSpeed*((visitedNodesInOrderStart.length-1)+(visitedNodesInOrderStopFirst.length-1)))\n\n        })\n\n      } else if(!this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0];\n            const visitedNodesInOrderFinish = message.data[1];\n            if(!visitedNodesInOrderFinish[0].isFinish) visitedNodesInOrderFinish.unshift(finishNode)\n  \n            const isShortedPath = message.data[2];\n            const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n            )\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed\n              );\n            }, this.state.animationSpeed);\n        })\n      }\n    }\n\n    //finish animations\n\n    animateShortestPath = (nodesInShortestPathOrder) => {\n\n      const startNode = this.state.grid[this.state.startNode[0]][this.state.startNode[1]]\n      const finishNode = this.state.grid[this.state.finishNode[0]][this.state.finishNode[1]]\n      const stopNode = this.state.isThereStop ? this.state.grid[this.state.prevStop[0]][this.state.prevStop[1]] : []\n      const stall = (nodesInShortestPathOrder.length*50)+2\n\n      setTimeout(() => {this.setState({visualizingAlgorithm: false})}, stall)\n\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n\n          var currObj = document.getElementById(`node-${node.row}-${node.col}`)\n\n          if(node.row === startNode.row && node.col === startNode.col) {\n            currObj.className = 'node node-shortest-path node-shortest-path-start node-no-gap-vert';\n          } else if(node.row === finishNode.row && node.col === finishNode.col){\n            currObj.className = 'node node-shortest-path node-shortest-path-finish';\n          } else if(this.state.isThereStop && (node.row === stopNode.row && node.col === stopNode.col)) {\n            currObj.className = 'node node-shortest-path node-shortest-path-stop';\n          } else if(document.getElementById(`node-${node.row}-${node.col}`).className.includes('node-shortest-path')) {\n            $(`#node-${node.row}-${node.col}`).replaceWith($(`#node-${node.row}-${node.col}`).clone(true))\n          } else {\n            currObj.className = 'node node-shortest-path';\n          }\n\n        }, 50 * i);\n      }\n    }\n\n    //generate mazes\n\n    animateMaze = (walls) => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {   \n          setTimeout(() => {\n            this.setState({ generatingMaze: false })\n          }, i * 10)      \n          return;\n        }\n        setTimeout(() => {\n\n          let wall = walls[i];\n          let node = this.state.grid[wall[0]][wall[1]];\n          node.isWall = true\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\"\n\n        }, i * 10);\n      }\n    };\n\n    getNewGridWithMaze = (walls) => {\n      let grid = this.state.grid\n      let newGrid = grid.slice();\n      for (let wall of walls) {\n        let node = grid[wall[0]][wall[1]];\n        let newNode = {\n          ...node,\n          isWall: true,\n        };\n        newGrid[wall[0]][wall[1]] = newNode;\n      }\n      this.setState({ grid: newGrid, generatingMaze: false })\n      return\n    };\n\n    generateRandomMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? randomMaze(grid, startNode, finishNode, true, stopNode) : randomMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateRecursiveDivisionMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? recursiveDivisionMaze(grid, startNode, finishNode, true, stopNode) : recursiveDivisionMaze(grid, startNode, finishNode, false, stopNode);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateVerticalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? verticalMaze(grid, startNode, finishNode, true, stopNode) : verticalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateHorizontalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? horizontalMaze(grid, startNode, finishNode, true, stopNode) : horizontalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n\n    render(){ \n\n        return(\n            <div className=\"main-container\">\n                <div className='grid-info-container'>\n                  <div className='grid-text-container'>\n                    <p className='grid-text'>Current-algorithim: <span className='grid-alg-text'>{this.state.currAlgObj.name}</span></p>\n                  </div>\n                  <div className=\"progress-bar-container\">\n                      <div className='progress progress-no-stop' id='progressBar'/>\n                  </div>\n                </div>\n                <NavTop state={this.state} handleMiniMazeTabs={this.handleMiniMazeTabs} handleMiniTabs={this.handleMiniTabs} clearGrid={this.clearGrid} resetGrid={this.resetGrid} toggleNav={this.handleNav} handleSpeedChange={this.handleSpeedChange} handleMazeTabs={this.handleMazeTabs} genMaze={this.generateMaze} play={this.playAnimation} handleTabs={this.handleTabs} handleItemChange={this.handleItemDescChange}/>\n                <div className=\"visualizer-container\">\n                    <Visualizer \n                        state={this.state} \n                        handleMouseDown={this.handleMouseDown} \n                        handleMouseEnter={this.handleMouseEnter} \n                        handleMouseUp={this.handleMouseUp}\n                    />\n                </div>\n                {window.innerWidth > 1000 && <Navbar state={this.state} toggleNav={this.handleNav} handleSpeedChange={this.handleSpeedChange} handleMazeTabs={this.handleMazeTabs} genMaze={this.generateMaze} play={this.playAnimation} handleTabs={this.handleTabs} handleItemChange={this.handleItemDescChange} visualizeDijkstra={this.visualizeDijkstra}/>}\n            </div>\n        )\n    }\n}\n\nconst renderGrid = (state, _rowNum, _colNum) => {\n    const grid = [];\n    var rowNum = _rowNum\n    var colNum = _colNum\n    for (let row = 0; row < rowNum; row++) {\n      const currentRow = []\n      for (let col = 0; col < colNum; col++) {\n        var node = createNode(col, row, state)\n        node.className = 'node'\n        currentRow.push(node)\n      }\n      grid.push(currentRow)\n    }\n    return grid;\n}\n\n\n\nconst createNode = (col, row, state) => {\n    const startNode = state.startNode\n    const finishNode = state.finishNode\n    const stopNode = state.prevStop\n    return {\n      col,\n      row,\n      isStart: row === startNode[0] && col === startNode[1],\n      isFinish: row === finishNode[0] && col === finishNode[1],\n      isStop: state.isThereStop ? row === stopNode[0] && col === stopNode[1] : false,\n      isWall: false,\n      previousNode: null,\n      previousNodeSecond: null,\n      isVisited: false,\n      isVisitedSecond: false,\n      distance: Infinity,\n      distanceSecond: Infinity\n    };\n  };\n\n  const getNewGridWithStart = (grid, row, col, prevStart) => {\n\n    const newGrid = grid.slice();\n    const newStart = newGrid[row][col]\n    const oldStart = newGrid[prevStart[0]][prevStart[1]]\n    const oldNode = {\n      ...oldStart,\n      isStart: !oldStart.isStart\n    }\n    const newNode = {\n      ...newStart,\n      isStart: !newStart.isStart,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStart[0]][prevStart[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithFinish = (grid, row, col, prevFinish) => {\n\n    const newGrid = grid.slice();\n    const newFinish = newGrid[row][col];\n    const oldFinish = newGrid[prevFinish[0]][prevFinish[1]]\n    const oldNode = {\n      ...oldFinish,\n      isFinish: !oldFinish.isFinish\n    }\n    const newNode = {\n      ...newFinish,\n      isFinish: !newFinish.isFinish,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevFinish[0]][prevFinish[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice()\n    const node = newGrid[row][col]\n    var newNode = {...node}\n    newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid\n  };\n\n  const getNewGridWithStopToggled = (grid, row, col, prevStop) => {\n\n    const newGrid = grid.slice()\n    const newStop = newGrid[row][col]\n    if(prevStop.length === 0){\n      const newNode = {\n        ...newStop,\n        isStop: !newStop.isStop,\n        isWall: false\n      };\n      newGrid[row][col] = newNode\n      return newGrid\n    }\n    const oldStop = newGrid[prevStop[0]][prevStop[1]]\n    const oldNode = {\n      ...oldStop,\n      isStop: !oldStop.isStop\n    }\n    const newNode = {\n      ...newStop,\n      isStop: !newStop.isStop,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStop[0]][prevStop[1]] = oldNode\n    return newGrid;\n  };\n\n  const getGridWithoutPath = (grid, minorReset=false) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n      for (let node of row) {\n        var wall = false\n        var stop = false\n        if(minorReset){\n          if(grid[node.row][node.col].isWall) wall = true\n\n          if(grid[node.row][node.col].isStop) stop = true\n        }\n        let newNode = {\n          ...node,\n          distance: Infinity,\n          distanceSecond: Infinity,\n          totalDistance: Infinity,\n          isVisited: false,\n          isVisitedSecond: false,\n          isShortest: false,\n          previousNode: null,\n          isWall: wall,\n          isWeight: false,\n          isStop: stop\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    return newGrid;\n  };\n\n  function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB,\n    second=false\n  ) {\n    let nodesInShortestPathOrder = []\n    let currentNode = nodeB\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    currentNode = nodeA\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    return nodesInShortestPathOrder\n  }","import MainContainer from \"./components/MainContainer.jsx\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MainContainer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}