[{"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/index.js":"1","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/App.js":"2","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/reportWebVitals.js":"3","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Node/Node.jsx":"4","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Visualizer.jsx":"5","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/Navbar.jsx":"6","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/item-data.js":"7","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/alg-data.js":"8","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/randomMaze.js":"9","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/verticalMaze.js":"10","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/HorizontalMaze.js":"11","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js":"12","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/MainContainer.jsx":"13","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/workerSetup.js":"14","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/dijkstraWorker.js":"15","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/pathGrabWorker.js":"16","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/aStarWorker.js":"17","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js":"18","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js":"19","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js":"20","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js":"21","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/sideNav.jsx":"22"},{"size":500,"mtime":1653054673509,"results":"23","hashOfConfig":"24"},{"size":178,"mtime":1652843661057,"results":"25","hashOfConfig":"24"},{"size":362,"mtime":1625667178580,"results":"26","hashOfConfig":"24"},{"size":1068,"mtime":1658603788374,"results":"27","hashOfConfig":"24"},{"size":1833,"mtime":1658565610420,"results":"28","hashOfConfig":"24"},{"size":7155,"mtime":1660907883104,"results":"29","hashOfConfig":"24"},{"size":1162,"mtime":1633901559330,"results":"30","hashOfConfig":"24"},{"size":1460,"mtime":1634681693937,"results":"31","hashOfConfig":"24"},{"size":717,"mtime":1659001458797,"results":"32","hashOfConfig":"24"},{"size":1599,"mtime":1658091448585,"results":"33","hashOfConfig":"24"},{"size":1600,"mtime":1658092258416,"results":"34","hashOfConfig":"24"},{"size":3705,"mtime":1658116384447,"results":"35","hashOfConfig":"24"},{"size":54093,"mtime":1660997653189,"results":"36","hashOfConfig":"24"},{"size":208,"mtime":1653157229999,"results":"37","hashOfConfig":"24"},{"size":7193,"mtime":1660999000957,"results":"38","hashOfConfig":"24"},{"size":2455,"mtime":1659002653107,"results":"39","hashOfConfig":"24"},{"size":6790,"mtime":1660999080010,"results":"40","hashOfConfig":"24"},{"size":7628,"mtime":1659002638099,"results":"41","hashOfConfig":"24"},{"size":6301,"mtime":1658204371449,"results":"42","hashOfConfig":"24"},{"size":6251,"mtime":1659002570789,"results":"43","hashOfConfig":"24"},{"size":11384,"mtime":1659001316852,"results":"44","hashOfConfig":"24"},{"size":9149,"mtime":1660997037610,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"mi99av",{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"48"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"48"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"48"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89","usedDeprecatedRules":"48"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92","usedDeprecatedRules":"48"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"48"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98","usedDeprecatedRules":"48"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101","usedDeprecatedRules":"48"},"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/index.js",[],["102","103"],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/App.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/reportWebVitals.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Node/Node.jsx",["104","105","106","107","108"],"import React, {Component} from 'react';\nimport './Node.css'\n\nclass Node extends Component {\n\n    render() {\n        const {\n          col,\n          isFinish,\n          isStart,\n          isVisited,\n          isVisitedSecond,\n          isWall,\n          isWeight,\n          isStop,\n          onMouseDown,\n          onMouseEnter,\n          onMouseUp,\n          row,\n          distance,\n          distanceSecond\n        } = this.props;\n        const extraClassName = \n          isFinish\n          ? 'node-finish'\n          : isStart\n          ? 'node-start'\n          : isStop\n          ? 'node-stop'\n          : isWall\n          ? 'node-wall'\n          : ''\n    \n        return (\n          <div\n            id={`node-${row}-${col}`}\n            className={`node node-gap-vert node-gap-horiz ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={(e) => {\n              \n              onMouseEnter(row, col)\n            }}\n            onMouseUp={() => onMouseUp()}>\n          </div>\n        );\n      }\n}\n\nexport default Node;","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Visualizer.jsx",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/Navbar.jsx",["109","110","111","112","113","114"],"import React, {Component} from 'react';\nimport algData from '../../data/alg-data'\nimport './nav.css'\nimport './navmini.css'\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\n\n\nexport default class Navbar extends Component {\n\n    useStyles = makeStyles(theme => ({\n        customHoverFocus: {\n          \"&:hover, &.Mui-focusVisible\": { backgroundColor: \"yellow\" }\n        }\n    }));    \n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n\n        return(\n                <div className={`nav-bar nav-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container'>\n                    <IconButton className=\"nav-btn\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"algs-container\">\n                    <div className=\"alg-selector\">\n                        <div className=\"alg-select-wrapper\">\n                        {\n                            algData.map((alg, val) => {\n                                return (\n                                    <button data-val={val} onClick={this.props.handleTabs}>{alg.name}</button>\n                                )\n                            })\n                        }\n                        </div>\n                    </div>\n                    <div className='alg-card'>\n                        <div className='alg-card-glass'>\n                            <h2 className=\"alg-card-title\">{currAlg.name}</h2>\n                            <div className=\"alg-card-text-container\">\n                                <p className=\"alg-card-desc\">{currAlg.description}</p>\n                            </div>\n                            <div className=\"play-btn-container\">\n                                <IconButton onClick={this.props.play}>\n                                    <PlayCircleFilledIcon className=\"play-btn\" size=\"10em\" fontSize=\"inherit\"/>\n                                </IconButton>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container\">\n                    <div className='speed-container'>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                            <RemoveIcon className='subtract-btn'/>\n                        </IconButton>\n                        <p className='speed-text'>{this.props.state.animationSpeed}</p>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                            <AddIcon className='add-btn'/>\n                        </IconButton>\n                    </div>\n                    <Button className=\"maze-btn\" onClick={this.props.genMaze} variant=\"contained\" fullWidth={true} color=\"primary\">\n                        <Typography className=\"maze-btn-text\">\n                            Generate\n                        </Typography>\n                    </Button>\n                    <div className=\"maze-selector\">\n                        <div className='maze-select-wrapper'>\n                        {mazeAlgs.map((title, val) => {\n                            return (\n                                <button data-val={val} onClick={this.props.handleMazeTabs}>{title}</button>\n                            )\n                        })}\n                        </div>\n                    </div>\n                </div>\n                <div className=\"items-container\">\n                    <div className={`item-card ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <h2 className=\"item-title\">{currItem.title}</h2>\n                        <div className=\"description-box\">\n                            <p className=\"item-description\">{currItem.description}</p>\n                        </div>\n                        {currItemPic}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/item-data.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/alg-data.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/randomMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/verticalMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/HorizontalMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/MainContainer.jsx",["115"],"import React, {Component} from 'react';\nimport $ from 'jquery' \nimport Visualizer from './PathFindingVisualizer/Visualizer'\nimport { randomMaze } from '../mazeAlgorithims/randomMaze';\nimport { verticalMaze } from '../mazeAlgorithims/verticalMaze';\nimport { horizontalMaze } from '../mazeAlgorithims/HorizontalMaze';\nimport { recursiveDivisionMaze } from '../mazeAlgorithims/recursiveDivisionMaze';\nimport Navbar from './navComponents/Navbar';\nimport NavTop from './navComponents/sideNav';\nimport itemData from '../data/item-data'\nimport algData from '../data/alg-data'\nimport pathGrabWorker from '../workers/pathGrabWorker';\nimport _dijkstraWorker from \"../workers/dijkstraWorker\";\nimport aStarWorker from '../workers/aStarWorker'\nimport greedyBestFirstSearchWorker from '../workers/greedyBestFirstSearchWorker';\nimport breadthFirstSearchWorker from '../workers/breadthFirstSearchWorker';\nimport depthFirstSearchWorker from '../workers/depthFirstSearchWorker';\nimport bidirectionalGreedySearchWorker from '../workers/bidirectionalGreedySearchWorker';\nimport WebWorker from \"../workers/workerSetup\";\nimport './mainContainer.css'\n\nexport default class MainContainer extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n            showNav: false,\n            currItemDesc: 'Start',\n            currItemObj: itemData[0],\n            currAlgObj: algData[0],\n            currAlgTab: 0,\n            currMazeAlg: 'Recursive Division Maze',\n            rowNum: 24,\n            colNum: 49,\n            currMazeTab: 0,\n            startNode: [9, 1],\n            finishNode: [9, 47],\n            startIsMoving: false,\n            finishIsMoving: false,\n            isThereStop: false,\n            stopIsMoving: false,\n            prevStop: [],\n            generatingMaze: false,\n            visualizingAlgorithm: false,\n            animationSpeed: 20,\n            gridClean: true,\n            maze: false\n        }\n    }\n    //reminder!!\n    // row is width\n    // col is height\n    componentDidMount() {\n\n      const handleResize = async () => {\n        var height = window.innerHeight\n        var width = window.innerWidth\n\n        if(width < 500) {\n          await this.setState({rowNum: 24, colNum: 12, startNode: [12,1], finishNode:[12, 10]})\n        } else if(width < 1000 && width > 500) {\n          await this.setState({rowNum: 30, colNum: 23, startNode: [15,1], finishNode:[15, 21]})\n        } else if(width < 1200 && width > 1000) {\n          await this.setState({rowNum: 24, colNum: 35, startNode: [15,1], finishNode:[15, 21]})\n        } else if(width > 1200) {\n          await this.setState({rowNum: 24, colNum: 49, startNode: [12,1], finishNode:[12, 47]})\n        }\n\n        const grid = renderGrid(this.state, this.state.rowNum, this.state.colNum)\n        this.setState({grid: grid});\n      }\n      \n      var resizeTimer;\n\n      window.addEventListener('resize', () => {\n\n        clearTimeout(resizeTimer);\n\n        resizeTimer = setTimeout(function() {\n      \n          handleResize()\n                  \n        }, 250);\n      })\n\n      // const grid = renderGrid(this.state, this.state.rowNum, this.state.colNum)\n      // this.setState({grid: grid});\n      handleResize()\n    }\n\n    handleMouseDown = (row, col) => {\n\n        var newGrid = this.state.grid\n        var node = newGrid[row][col]\n\n        if(this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.grid[row][col].isStart){\n          this.setState({startIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.grid[row][col].isFinish){\n          this.setState({finishIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.currItemDesc === 'Stop'){\n          this.setState({stopIsMoving: true, isThereStop: true})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col)   \n        }\n        this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n    \n    handleMouseEnter = (row, col) => {\n\n        if (!this.state.mouseIsPressed) return;\n\n        var newGrid = this.state.grid;\n        var node = newGrid[row][col]\n\n        if( node.isStart || node.isStop || node.isFinish || this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.startIsMoving){\n          newGrid = getNewGridWithStart(this.state.grid, row, col, this.state.startNode)\n          this.setState({startNode: [row, col]})\n        } else if(this.state.finishIsMoving){\n          newGrid = getNewGridWithFinish(this.state.grid, row, col, this.state.finishNode)\n          this.setState({finishNode: [row, col]})\n        } else if(this.state.currItemDesc === 'Stop'){\n          newGrid = getNewGridWithStopToggled(this.state.grid, row, col, this.state.prevStop);\n          this.setState({prevStop: [row, col]})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col);\n        }\n        this.setState({grid: newGrid});\n    }\n    \n    handleMouseUp = (row, col) => {\n        this.setState({mouseIsPressed: false, startIsMoving: false, finishIsMoving: false});\n    }\n\n    handleNav = () => {\n      this.setState({showNav: !this.state.showNav})\n    }\n\n    //navBar functions\n    handleItemDescChange = (e, item) => {\n      var newItem = `${item}`\n      itemData.map((_item) => {\n        if(item === _item.id) this.setState({currItemDesc: newItem, currItemObj: _item})\n\n        return _item\n      })\n    }\n\n    handleTabs = (e) => {\n      var val = e.target.dataset.val\n      this.setState({currAlgTab: val, currAlgObj: algData[val]})\n    }\n\n    handleMiniTabs = (e) => {\n      var val = this.state.currAlgTab\n      if(val+1 > algData.length-1){\n        val = 0\n      } else {\n        val++\n      }\n\n      this.setState({currAlgTab: val, currAlgObj: algData[val]})\n    }\n\n    handleMazeTabs = (e) => {\n      var val = parseInt(e.target.dataset.val)\n      this.setState({currMazeTab: val})\n    }\n\n    handleMiniMazeTabs = (up) => {\n      var val = this.state.currMazeTab\n\n      if(up) {\n        if(val <= 0) {\n          this.setState({currMazeTab: 3})\n          return\n        }\n        val--\n      } else {\n        if(val >= 3) {\n          this.setState({currMazeTab: 0})\n          return\n        }\n        val++\n      }\n\n      this.setState({currMazeTab: val})\n    }\n\n    handleSpeedChange = (e, val) => {\n      var currSpeed = this.state.animationSpeed\n\n      if(val && currSpeed > 5){\n        this.setState({animationSpeed: currSpeed-5})\n      } if(!val && currSpeed < 35){\n        this.setState({animationSpeed: currSpeed+5})\n      }\n    }\n\n    generateMaze = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean || this.state.maze) return\n\n      this.setState({maze: true})\n\n      var currAlg = this.state.currMazeTab\n \n      if(currAlg===0){\n        this.generateRecursiveDivisionMaze()\n      } else if(currAlg===1){\n        this.generateVerticalMaze()\n      } else if(currAlg===2){\n        this.generateHorizontalMaze()\n      } else if(currAlg===3){\n        this.generateRandomMaze()\n      }\n    }\n\n    resetGrid = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n\n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const grid = this.state.grid\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n      const stopNode = this.state.isThereStop ? this.state.prevStop : false\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else if(stopNode !== false && (row === stopNode[0] && col === stopNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-stop\";\n          } else if(grid[row][col].isWall)\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-wall\";\n          } else {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid, true);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    clearGrid = () => {\n\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n      \n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        prevStop: [],\n        isThereStop: false  ,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    // play animation\n\n    playAnimation = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean) return\n\n      var currAlg = this.state.currAlgObj.id\n      this.setState({\n        gridClean: false,\n        visualizingAlgorithm: true,\n        showNav: false\n      })\n      if(currAlg===0){\n        this.visualizeDijkstra()\n      } else if(currAlg===1){\n        this.visualizeaStar()\n      } else if(currAlg===4){\n        this.visualizbfs()\n      } else if(currAlg===2){\n        this.visualizegbfs()\n      } else if(currAlg===5){\n        this.visualizedfs()\n      } else if(currAlg===3){\n        this.visualizeBidirectionalGreedySearch()\n      }\n      return\n    }\n\n    handleProgressSetup = (\n      isThereStop, \n      isSecondAnimation, \n      animationSpeed,\n      animationDuration,\n    ) => {\n\n      const progressBar = document.getElementById(`progressBar`)\n      progressBar.className = 'progress progress-no-stop'\n      \n      if(!isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 100/animationDuration\n\n      } else if(!isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 50/animationDuration\n\n      } else if(isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-stop-anime')\n          progressBar.className = 'progress progress-stop'\n        })\n        return 50/animationDuration\n\n      }\n    }\n\n    //animte dijkstra\n\n    animateDijkstra = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed=10, \n      isThereStop=false,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor;\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progressTracker\n      const progress = $(\"#progressBar\")\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n    \n    visualizeDijkstra = () => {\n\n      this.dijkstraWorker = new WebWorker(_dijkstraWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      if(this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n            \n            const animateTiming = async (message) => {\n\n                this.pathGrabWorker.postMessage([message.data, true])\n\n                this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                    const animateTime = (message, messageTwo) => {\n\n                      var nodesInShortestPathOrder;\n\n                      if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                      } else if(messageTwo.data[0][0] === false) {\n                        nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                      } else if(messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                      } else {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                      }\n\n                      this.animateDijkstra(\n                        message.data[0], \n                        nodesInShortestPathOrder, \n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop,\n                        false\n                      )\n\n                      setTimeout(this.animateDijkstra, \n                        message.data[0].length * this.state.animationSpeed, \n                        message.data[1], \n                        nodesInShortestPathOrder,\n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop, \n                        true\n                      )\n                    }\n\n                    animateTime(message, messageTwo)\n                })\n            }\n            animateTiming(message)\n        })\n\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animateDijkstra(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop\n              )\n\n            })\n        })\n      }\n    }\n\n    //animate aStar\n\n    animateaStar = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed,\n      isThereStop, \n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizeaStar = () => {\n\n      this.aStarWorker = new WebWorker(aStarWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n        this.aStarWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.aStarWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animateaStar(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animateaStar, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n        }\n        animateTiming(message)\n    })\n          return\n          \n      } else if(!this.state.isThereStop){\n\n          this.aStarWorker.postMessage([grid, startNode, finishNode, false])\n\n          this.aStarWorker.addEventListener('message', (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, false])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n                this.animateaStar(\n                  message.data, \n                  nodesInShortestPathOrder, \n                  message.data.length,\n                  this.state.animationSpeed,\n                  this.state.isThereStop,\n                  false\n                )\n\n              })\n          })\n      }\n    }\n\n    //animate breadth first search \n\n    animatebfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n          \n          setTimeout(this.animateShortestPath, animationSpeed*animationStall, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          progress.width(`+=${integralVal}%`)\n        }, animationSpeed * i);\n      }\n    }\n\n    visualizbfs = () => {\n      \n      this.breadthFirstSearchWorker = new WebWorker(breadthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n                       \n            const animateTiming = async (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, true])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                  const animateTime = (message, messageTwo) => {\n\n                    var nodesInShortestPathOrder;\n\n                    if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                    } else if(messageTwo.data[0][0] === false) {\n                      nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                    } else if(messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                    } else {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                    }\n\n                    this.animatebfs(\n                      message.data[0], \n                      nodesInShortestPathOrder, \n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      false\n                    )\n\n                    setTimeout(this.animatebfs, \n                      message.data[0].length * this.state.animationSpeed, \n                      message.data[1], \n                      nodesInShortestPathOrder,\n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      true\n                    )\n                  }\n\n                  animateTime(message, messageTwo)\n              })\n            }\n          animateTiming(message)\n      })\n      return\n\n      } else if(!this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatebfs(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                false\n              )\n            })\n        })\n      }\n    }\n\n    // greedy best first search\n\n    animategbfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizegbfs = () => {\n      \n      this.greedyBestFirstSearchWorker = new WebWorker(greedyBestFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n\n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animategbfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animategbfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n      \n      } else if(!this.state.isThereStop) {\n        \n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animategbfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop,\n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // depth first search\n\n    animatedfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizedfs = () => {\n            \n      this.depthFirstSearchWorker = new WebWorker(depthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      \n      if(this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animatedfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(\n                    this.animatedfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatedfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed,\n                this.state.isThereStop, \n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // bidirectional greedy first search\n\n    animateBidirectionalAlgorithm = (\n      visitedNodesInOrderStart,\n      visitedNodesInOrderFinish,\n      nodesInShortestPathOrder,\n      isShortedPath,\n      animationSpeed,\n      animationStall,\n      isSecondAnimation=false\n    ) => {\n\n      this.setState({visualizingAlgorithm: true})\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        this.state.isThereStop,\n        false,\n        animationSpeed,\n        visitedNodesInOrderStart.length\n      )\n\n      let len = Math.max(\n        visitedNodesInOrderStart.length,\n        visitedNodesInOrderFinish.length\n      );\n\n      for (let i = 1; i <= len; i++) {\n        let nodeA = visitedNodesInOrderStart[i];\n        let nodeB = visitedNodesInOrderFinish[i];\n        if (i === visitedNodesInOrderStart.length) {\n\n          if(isSecondAnimation && this.state.isThereStop) return\n\n          setTimeout(() => {\n            if (isShortedPath) {\n              this.animateShortestPath(\n                nodesInShortestPathOrder\n              );\n            } else {\n              this.setState({ visualizingAlgorithm: false });\n            }\n          }, animationStall * animationSpeed);\n          return;\n        }\n        setTimeout(() => {\n          //visited nodes\n          if (nodeA !== undefined) {\n            document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          if (nodeB !== undefined) {\n            document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          progress.width(`+=${integralVal*2}%`)\n\n        }, i * animationSpeed);\n      }\n    }\n\n    visualizeBidirectionalGreedySearch = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n\n      this.bidirectionalGreedySearchWorker = new WebWorker(bidirectionalGreedySearchWorker)\n\n      const { grid } = this.state;\n      const _startNode = this.state.startNode\n      const _finishNode = this.state.finishNode\n      const _stopNode = this.state.prevStop\n      const startNode = grid[_startNode[0]][_startNode[1]];\n      const finishNode = grid[_finishNode[0]][_finishNode[1]];\n      const stopNode = this.state.isThereStop ? grid[_stopNode[0]][_stopNode[1]] : false\n\n      if(this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode, true])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0][0];\n            const visitedNodesInOrderStopFirst = message.data[0][1];\n            const isShortedPath = message.data[0][2];\n\n            const visitedNodesInOrderStopSecond = message.data[1][0]\n            const visitedNodesInOrderFinish = message.data[1][1]\n            const isShortedPathSecond = message.data[1][2]\n\n            if(visitedNodesInOrderStart[0] !== startNode) visitedNodesInOrderStart.unshift(startNode)\n\n            if(visitedNodesInOrderStopFirst[0] !== stopNode) visitedNodesInOrderStopFirst.unshift(stopNode)\n\n            if(visitedNodesInOrderFinish[0] !== finishNode) visitedNodesInOrderFinish.unshift(finishNode)\n\n            const animationStall = (visitedNodesInOrderStart.length+visitedNodesInOrderStopFirst.length+visitedNodesInOrderStopSecond.length+visitedNodesInOrderFinish.length)\n\n            const nodesInShortestPathOrderFirst = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderStopFirst[visitedNodesInOrderStopFirst.length - 1],\n              false\n            )\n\n            const nodesInShortestPathOrderSecond = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStopSecond[visitedNodesInOrderStopSecond.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1],\n              true\n            )\n\n            const nodesInShortestPathOrder = [...nodesInShortestPathOrderFirst, ...nodesInShortestPathOrderSecond]\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderStopFirst,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed,\n                animationStall,\n                false\n              );\n            }, this.state.animationSpeed);\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStopSecond,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPathSecond,\n                this.state.animationSpeed,\n                animationStall,\n                true\n              );\n            }, this.state.animationSpeed*((visitedNodesInOrderStart.length-1)+(visitedNodesInOrderStopFirst.length-1)))\n\n        })\n\n      } else if(!this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0];\n            const visitedNodesInOrderFinish = message.data[1];\n            if(!visitedNodesInOrderFinish[0].isFinish) visitedNodesInOrderFinish.unshift(finishNode)\n  \n            const isShortedPath = message.data[2];\n            const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n            )\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed\n              );\n            }, this.state.animationSpeed);\n        })\n      }\n    }\n\n    //finish animations\n\n    animateShortestPath = (nodesInShortestPathOrder) => {\n\n      const startNode = this.state.grid[this.state.startNode[0]][this.state.startNode[1]]\n      const finishNode = this.state.grid[this.state.finishNode[0]][this.state.finishNode[1]]\n      const stopNode = this.state.isThereStop ? this.state.grid[this.state.prevStop[0]][this.state.prevStop[1]] : []\n      const stall = (nodesInShortestPathOrder.length*50)+2\n\n      setTimeout(() => {this.setState({visualizingAlgorithm: false})}, stall)\n\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n\n          var currObj = document.getElementById(`node-${node.row}-${node.col}`)\n\n          if(node.row === startNode.row && node.col === startNode.col) {\n            currObj.className = 'node node-shortest-path node-shortest-path-start node-no-gap-vert';\n          } else if(node.row === finishNode.row && node.col === finishNode.col){\n            currObj.className = 'node node-shortest-path node-shortest-path-finish';\n          } else if(this.state.isThereStop && (node.row === stopNode.row && node.col === stopNode.col)) {\n            currObj.className = 'node node-shortest-path node-shortest-path-stop';\n          } else if(document.getElementById(`node-${node.row}-${node.col}`).className.includes('node-shortest-path')) {\n            $(`#node-${node.row}-${node.col}`).replaceWith($(`#node-${node.row}-${node.col}`).clone(true))\n          } else {\n            currObj.className = 'node node-shortest-path';\n          }\n\n        }, 50 * i);\n      }\n    }\n\n    //generate mazes\n\n    animateMaze = (walls) => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {   \n          setTimeout(() => {\n            this.setState({ generatingMaze: false })\n          }, i * 10)      \n          return;\n        }\n        setTimeout(() => {\n\n          let wall = walls[i];\n          let node = this.state.grid[wall[0]][wall[1]];\n          node.isWall = true\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\"\n\n        }, i * 10);\n      }\n    };\n\n    getNewGridWithMaze = (walls) => {\n      let grid = this.state.grid\n      let newGrid = grid.slice();\n      for (let wall of walls) {\n        let node = grid[wall[0]][wall[1]];\n        let newNode = {\n          ...node,\n          isWall: true,\n        };\n        newGrid[wall[0]][wall[1]] = newNode;\n      }\n      this.setState({ grid: newGrid, generatingMaze: false })\n      return\n    };\n\n    generateRandomMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? randomMaze(grid, startNode, finishNode, true, stopNode) : randomMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateRecursiveDivisionMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? recursiveDivisionMaze(grid, startNode, finishNode, true, stopNode) : recursiveDivisionMaze(grid, startNode, finishNode, false, stopNode);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateVerticalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? verticalMaze(grid, startNode, finishNode, true, stopNode) : verticalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateHorizontalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? horizontalMaze(grid, startNode, finishNode, true, stopNode) : horizontalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n\n    render(){ \n\n        return(\n            <div className=\"main-container\">\n                <div className='grid-info-container'>\n                  <div className='grid-text-container'>\n                    <p className='grid-text'>Current-algorithim: <span className='grid-alg-text'>{this.state.currAlgObj.name}</span></p>\n                  </div>\n                  <div className=\"progress-bar-container\">\n                      <div className='progress progress-no-stop' id='progressBar'/>\n                  </div>\n                </div>\n                <NavTop state={this.state} handleMiniMazeTabs={this.handleMiniMazeTabs} handleMiniTabs={this.handleMiniTabs} clearGrid={this.clearGrid} resetGrid={this.resetGrid} toggleNav={this.handleNav} handleSpeedChange={this.handleSpeedChange} handleMazeTabs={this.handleMazeTabs} genMaze={this.generateMaze} play={this.playAnimation} handleTabs={this.handleTabs} handleItemChange={this.handleItemDescChange}/>\n                <div className=\"visualizer-container\">\n                    <Visualizer \n                        state={this.state} \n                        handleMouseDown={this.handleMouseDown} \n                        handleMouseEnter={this.handleMouseEnter} \n                        handleMouseUp={this.handleMouseUp}\n                    />\n                </div>\n                {window.innerWidth > 1000 && <Navbar state={this.state} toggleNav={this.handleNav} handleSpeedChange={this.handleSpeedChange} handleMazeTabs={this.handleMazeTabs} genMaze={this.generateMaze} play={this.playAnimation} handleTabs={this.handleTabs} handleItemChange={this.handleItemDescChange} visualizeDijkstra={this.visualizeDijkstra}/>}\n            </div>\n        )\n    }\n}\n\nconst renderGrid = (state, _rowNum, _colNum) => {\n    const grid = [];\n    var rowNum = _rowNum\n    var colNum = _colNum\n    for (let row = 0; row < rowNum; row++) {\n      const currentRow = []\n      for (let col = 0; col < colNum; col++) {\n        var node = createNode(col, row, state)\n        node.className = 'node'\n        currentRow.push(node)\n      }\n      grid.push(currentRow)\n    }\n    return grid;\n}\n\n\n\nconst createNode = (col, row, state) => {\n    const startNode = state.startNode\n    const finishNode = state.finishNode\n    const stopNode = state.prevStop\n    return {\n      col,\n      row,\n      isStart: row === startNode[0] && col === startNode[1],\n      isFinish: row === finishNode[0] && col === finishNode[1],\n      isStop: state.isThereStop ? row === stopNode[0] && col === stopNode[1] : false,\n      isWall: false,\n      previousNode: null,\n      previousNodeSecond: null,\n      isVisited: false,\n      isVisitedSecond: false,\n      distance: Infinity,\n      distanceSecond: Infinity\n    };\n  };\n\n  const getNewGridWithStart = (grid, row, col, prevStart) => {\n\n    const newGrid = grid.slice();\n    const newStart = newGrid[row][col]\n    const oldStart = newGrid[prevStart[0]][prevStart[1]]\n    const oldNode = {\n      ...oldStart,\n      isStart: !oldStart.isStart\n    }\n    const newNode = {\n      ...newStart,\n      isStart: !newStart.isStart,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStart[0]][prevStart[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithFinish = (grid, row, col, prevFinish) => {\n\n    const newGrid = grid.slice();\n    const newFinish = newGrid[row][col];\n    const oldFinish = newGrid[prevFinish[0]][prevFinish[1]]\n    const oldNode = {\n      ...oldFinish,\n      isFinish: !oldFinish.isFinish\n    }\n    const newNode = {\n      ...newFinish,\n      isFinish: !newFinish.isFinish,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevFinish[0]][prevFinish[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice()\n    const node = newGrid[row][col]\n    var newNode = {...node}\n    newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid\n  };\n\n  const getNewGridWithStopToggled = (grid, row, col, prevStop) => {\n\n    const newGrid = grid.slice()\n    const newStop = newGrid[row][col]\n    if(prevStop.length === 0){\n      const newNode = {\n        ...newStop,\n        isStop: !newStop.isStop,\n        isWall: false\n      };\n      newGrid[row][col] = newNode\n      return newGrid\n    }\n    const oldStop = newGrid[prevStop[0]][prevStop[1]]\n    const oldNode = {\n      ...oldStop,\n      isStop: !oldStop.isStop\n    }\n    const newNode = {\n      ...newStop,\n      isStop: !newStop.isStop,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStop[0]][prevStop[1]] = oldNode\n    return newGrid;\n  };\n\n  const getGridWithoutPath = (grid, minorReset=false) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n      for (let node of row) {\n        var wall = false\n        var stop = false\n        if(minorReset){\n          if(grid[node.row][node.col].isWall) wall = true\n\n          if(grid[node.row][node.col].isStop) stop = true\n        }\n        let newNode = {\n          ...node,\n          distance: Infinity,\n          distanceSecond: Infinity,\n          totalDistance: Infinity,\n          isVisited: false,\n          isVisitedSecond: false,\n          isShortest: false,\n          previousNode: null,\n          isWall: wall,\n          isWeight: false,\n          isStop: stop\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    return newGrid;\n  };\n\n  function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB,\n    second=false\n  ) {\n    let nodesInShortestPathOrder = []\n    let currentNode = nodeB\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    currentNode = nodeA\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    return nodesInShortestPathOrder\n  }","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/workerSetup.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/dijkstraWorker.js",["116","117","118","119"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function dijkstra(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n            console.log(stopNode)\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else {\n                node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){     \n                sortNodesByDistance(unvisitedNodes, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            } else if(isStop){\n            //going to repeat normal function yet twice for stop\n            const visitedNodesInOrder = [[],[]]\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n        \n            var unvisitedNodesSecond = getAllNodes(grid)\n              \n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else if(node === stopNode) {\n                node.distanceSecond = 0\n                } else {\n                node.distance = Infinity\n                node.distanceSecond = Infinity\n                }\n            })\n        \n            //getting path from start to stop\n            while(!!unvisitedNodes) {\n                sortNodesByDistance(unvisitedNodes, false)\n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) break\n        \n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder[0].push(closestNode)\n        \n                //checking to see is closest node is the finishnode\n                if(closestNode === stopNode) break\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            \n            //getting path from stop to finish\n            while(!!unvisitedNodesSecond) {\n                \n                sortNodesByDistance(unvisitedNodesSecond, true)\n\n                const closestNode = unvisitedNodesSecond.shift()\n        \n                if(closestNode.isWall) continue\n        \n                if(closestNode.distanceSecond === Infinity) break\n\n                closestNode.isVisitedSecond = true\n                visitedNodesInOrder[1].push(closestNode)\n        \n                if(closestNode === finishNode) break\n        \n                updateUnvisitedNeighbors(closestNode, grid, true)\n            }\n            return visitedNodesInOrder\n        }\n    }\n\n        function sortNodesByDistance(unvisitedNodes, isStop) {\n            //it is not calculating second distace correctly stays at infinity\n            unvisitedNodes.sort((nodeA, nodeB) => {\n              if(isStop===true) {\n\n                return nodeA.distanceSecond - nodeB.distanceSecond\n              } else {\n                \n                return nodeA.distance - nodeB.distance\n              }\n            });\n            var distanceCheck = []\n            if(isStop){\n              unvisitedNodes.forEach((node) => {\n                if(node.distanceSecond !== Infinity) distanceCheck.push(node)\n              })\n            }\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop)\n            for (const neighbor of unvisitedNeighbors) {\n              isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1\n        \n              isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node\n            }\n        }\n          \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node\n            if (row > 0) neighbors.push(grid[row - 1][col])\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\n            if (col > 0) neighbors.push(grid[row][col - 1])\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\n            return neighbors.filter((neighbor) => {\n              //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n              if(isStop===true){\n                return !neighbor.isVisitedSecond\n              } else {\n                return !neighbor.isVisited\n              }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = []\n            for (const row of grid) {\n              for (const node of row) {\n                nodes.push(node)\n              }\n            }\n            return nodes\n        }\n\n\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = dijkstra(grid, startNode, finishNode, stopNode)\n  \n        postMessage(visitedNodesInorder)\n    });\n};\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode, stop=false) {\n      const nodesInShortestPathOrder = []\n      let currentNode = finishNode\n      while (currentNode !== null) {\n\n        if(currentNode.isStart===true && stop===false || typeof currentNode.previousNode !== 'object') break\n\n        if(currentNode.isStop===true && stop===true) break\n\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n      }\n      return nodesInShortestPathOrder\n  }","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/pathGrabWorker.js",["120"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n\n        if (!message) return;\n\n        var stopNode=false, finishNode=false, startNode=false\n\n        const stop = message.data[1]\n        const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0]\n\n        nodes.map((node) => {\n\n            if(node.isStop === true) stopNode = node\n\n            if(node.isFinish === true) finishNode = node\n\n            if(node.isStart === true) startNode = node\n\n            return node\n        })\n\n        var nodesInShortestPathOrder = [];\n\n        if(!stop) {\n\n            if(finishNode === false) postMessage(false)\n\n            let currentNode = finishNode\n\n            while (currentNode !== null) {\n\n                if(currentNode.isStart===true) break\n\n                nodesInShortestPathOrder.unshift(currentNode)\n\n                currentNode = currentNode.previousNode\n            }\n\n            if(!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode)\n\n            postMessage(nodesInShortestPathOrder)\n\n        } else if(stop) {\n\n            var startToStop=[], stopToFinish=[]\n            let currentNodeFin = finishNode\n            let currentNodeStop = stopNode\n\n            if (message.data[0][1].filter(node => node.isFinish === true).length > 0) {\n                while (currentNodeFin !== null) {\n\n                    if(currentNodeFin.isStop===true) break;\n    \n                    stopToFinish.unshift(currentNodeFin);\n    \n                    currentNodeFin = currentNodeFin.previousNodeSecond;\n                }\n                if(!stopToFinish[0].isStop) stopToFinish.unshift(stopNode)\n            } else {\n                stopToFinish.unshift(false)\n            }\n\n            if (message.data[0][0].filter(node => node.isStop === true).length > 0) {\n                while (currentNodeStop !== null) {\n\n                    if(currentNodeStop.isStart===true) break;\n\n                    startToStop.unshift(currentNodeStop);\n\n                    currentNodeStop = currentNodeStop.previousNode;\n                }\n                if(!startToStop[0].isStart) startToStop.unshift(startNode)\n\n            } else {\n                startToStop.unshift(false)\n            }\n\n            postMessage([startToStop, stopToFinish])\n        }\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/aStarWorker.js",["121","122"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n\n        function aStar(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                    node.distance = 0\n                } else {\n                    node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){\n\n                sortNodesByDistance(unvisitedNodes, finishNode, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false);\n            }\n            } else if(isStop){\n                //going to repeat normal function yet twice for stop\n                const visitedNodesInOrder = [[],[]]\n                //grabbing all nodes   \n                var unvisitedNodes = getAllNodes(grid)\n                     \n                var unvisitedNodesSecond = getAllNodes(grid)\n            \n                unvisitedNodes.forEach((node) => {\n                    if(node === startNode){\n                        node.distance = 0\n                    } else if(node === stopNode) {\n                        node.distanceSecond = 0\n                    } else {\n                        node.distance = Infinity\n                        node.distanceSecond = Infinity\n                    }\n                })\n            \n                //getting path from start to stop\n                while(!!unvisitedNodes) {\n                    sortNodesByDistance(unvisitedNodes, stopNode, false)\n                    const closestNode = unvisitedNodes.shift()\n            \n                    //checking if current node is a wall\n                    if(closestNode.isWall) continue\n            \n                    //checking if node has no where to venture to\n                    if(closestNode.distance === Infinity) break\n            \n                    //update current node as visited then pushing it to visitednodes array\n                    closestNode.isVisited = true\n                    visitedNodesInOrder[0].push(closestNode)\n            \n                    //checking to see is closest node is the finishnode\n                    if(closestNode === stopNode) break\n            \n                    //get current nodes neighbors\n                    updateUnvisitedNeighbors(closestNode, grid, false);\n                }\n                \n                //getting path from stop to finish\n                while(!!unvisitedNodesSecond) {\n                    \n                    sortNodesByDistance(unvisitedNodesSecond, finishNode, true)\n\n                    const closestNode = unvisitedNodesSecond.shift()\n            \n                    if(closestNode.isWall) continue\n            \n                    if(closestNode.distanceSecond === Infinity) break\n\n                    closestNode.isVisitedSecond = true\n                    visitedNodesInOrder[1].push(closestNode)\n            \n                    if(closestNode === finishNode) break\n            \n                    updateUnvisitedNeighbors(closestNode, grid, true)\n                }\n                return visitedNodesInOrder\n            }\n        }\n\n        function sortNodesByDistance(unvisitedNodes, finishNode, isStop) {\n            // calculating f\n            const f = finishNode\n            unvisitedNodes.sort((nodeA, nodeB) => {\n                const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n                const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n\n                if(isStop){\n                    return (nodeA.distanceSecond+af) - (nodeB.distanceSecond+bf)\n                } else {\n                    return (nodeA.distance+af) - (nodeB.distance+bf)\n                }\n            });\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop);\n            for (const neighbor of unvisitedNeighbors) {\n                \n                isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1;\n        \n                isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node;\n            }\n        }\n        \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node;\n            if (row > 0) neighbors.push(grid[row - 1][col]);\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n            if (col > 0) neighbors.push(grid[row][col - 1]);\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n            return neighbors.filter((neighbor) => {\n            //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n            if(isStop===true){\n                return !neighbor.isVisitedSecond\n            } else {\n                return !neighbor.isVisited\n            }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = [];\n            for (const row of grid) {\n            for (const node of row) {\n                nodes.push(node);\n            }\n            }\n            return nodes;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = aStar(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js",["123"],"var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                \n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = []\n                let unvisitedNodesSecond = []\n                let firstSearch = []\n                let secondSearch = []\n                startNode.distance = 0\n                unvisitedNodes.push(startNode)\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance)\n                  let closestNode = unvisitedNodes.shift()\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour)\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                  let closestNode = unvisitedNodesSecond.shift()\n                  if (closestNode === finishNode) {\n                    secondSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisitedSecond = true\n                  secondSearch.push(closestNode)\n              \n                  let neighbours = getNeighbours(closestNode, grid, true)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n                      unvisitedNodesSecond.unshift(neighbour)\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    } else if (distance < neighbour.distanceSecond) {\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    }\n                  }\n                }\n\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            }\n            return neighbour.filter(\n              (node) => {\n                  if(isStop){\n                    return !node.isWall && !node.isVisitedSecond\n                  } else {\n                    return !node.isWall && !node.isVisited\n                  }\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row)\n            let y = Math.abs(node.col - finishNode.col)\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false\n              }\n            }\n            return true\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = []\n    let currentNode = finishNode\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js",["124"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                let queueSecond = [];\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode);\n                queueSecond.push(stopNode)\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        visitedNodesInOrder[0].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                while (queueSecond.length) {\n                    const currNode = queueSecond.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder[1].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n                return visitedNodesInOrder\n\n            } else if(!isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode);\n                        return visitedNodesInOrder;\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                return visitedNodesInOrder\n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js",["125"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js",["126"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n\n            let unvisitedNodesStart = []\n            let visitedNodesInOrderStart = []\n            let unvisitedNodesFinish = []\n            let visitedNodesInOrderFinish = []\n            startNode.distance = 0\n            finishNode.distance = 0\n            unvisitedNodesStart.push(startNode)\n            unvisitedNodesFinish.push(finishNode)\n        \n            while (\n                unvisitedNodesStart.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                let closestNodeStart = unvisitedNodesStart.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n        \n                closestNodeStart.isVisited = true;\n                closestNodeFinish.isVisited = true;\n                visitedNodesInOrderStart.push(closestNodeStart);\n                visitedNodesInOrderFinish.push(closestNodeFinish);\n                if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                }\n            \n                //Start side search\n                let neighbours = getNeighbours(closestNodeStart, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStart.push(closestNodeStart);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeStart.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        unvisitedNodesStart.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    }\n                }\n            \n                //Finish side search\n                neighbours = getNeighbours(closestNodeFinish, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStart.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                    }\n                }\n            }\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n                      \n        }\n\n        function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n\n            let unvisitedNodesStop = [];\n            let visitedNodesInOrderStop = [];\n            let unvisitedNodesFinish = [];\n            let visitedNodesInOrderFinish = [];\n            stopNode.distanceSecond = 0\n            finishNode.distanceSecond = 0\n            unvisitedNodesStop.push(stopNode)\n            unvisitedNodesFinish.push(finishNode)\n\n            while (\n                unvisitedNodesStop.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStop = unvisitedNodesStop.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStop.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStop.push(closestNodeStop)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                    return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStop, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStop.push(closestNodeStop);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true]\n                    }\n                    let distance = closestNodeStop.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        unvisitedNodesStop.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStop\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStop;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStop.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        var visitedNodesInorder = []\n\n        if (isStop) {\n\n            visitedNodesInorder = [bidirectionalGreedySearch(grid, startNode, stopNode), bidirectionalGreedySearchSecond(grid, stopNode, finishNode)]\n            postMessage(visitedNodesInorder)\n        } else {\n\n            visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n            postMessage(visitedNodesInorder);\n        }\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/sideNav.jsx",["127","128","129","130","131","132","133","134","135","136","137","138"],"import React, {Component} from \"react\";\nimport algData from '../../data/alg-data'\nimport './navmini.css'\nimport IconButton from '@material-ui/core/IconButton';\nimport ReplayIcon from '@material-ui/icons/Replay';\nimport CloseIcon from '@mui/icons-material/Close';\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';\nimport KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';\nimport KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\nimport { FaAngleDoubleRight } from 'react-icons/fa'\n\nclass NavTop extends Component {\n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture-mini start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture-mini target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture-mini'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture-mini stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n\n    algChange = (e) => {\n        var val = e.target.dataset.val\n        console.log(val)\n    }\n\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n        const screenHeight = window.innerHeight\n\n        if(window.innerWidth > 1000) {\n            return(\n                <div className='side-nav-container'>\n                    <div className='reset-options-container'>\n                        <div className='reset-container'>\n                            <IconButton onClick={this.props.clearGrid} color=\"primary\">\n                                    <CloseIcon className=\"erase-btn\" />\n                            </IconButton>\n                        </div>\n                        <div className='erase-container'>\n                            <IconButton onClick={this.props.resetGrid} color=\"primary\">\n                                    <ReplayIcon className=\"reset-btn\" />\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n            )\n        }\n\n        return(\n            <div className={`nav-bar-mini nav-mini-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container-mini'>\n                    <IconButton className=\"nav-btn-mini\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"top-container-mini\">\n                    <div className=\"alg-selector-mini\">\n                        <div className=\"alg-select-wrapper-mini\">\n                            {\n                                algData.map((alg, val) => {\n                                    if(alg.id === currAlg.id) return ( <h4 className='title-mini'>{alg.name}</h4> )\n                                })\n                            }\n                            <IconButton onClick={this.props.handleMiniTabs}>\n                                <ArrowForwardIosIcon className=\"next-btn\" fontSize=\"inherit\"/>\n                            </IconButton>\n                        </div>\n                    </div>\n                    <div className=\"alg-card-mini\">\n                        <div className=\"alg-text-mini\">\n                            <h2>{currAlg.name}</h2>\n                            <p>{currAlg.description}</p>\n                        </div>\n                        <div className=\"alg-play-mini\">\n                            <IconButton onClick={this.props.play}>\n                                <PlayCircleFilledIcon className=\"play-mini\" size=\"10em\" fontSize=\"inherit\"/>\n                            </IconButton>\n                            <IconButton onClick={this.props.clearGrid} color=\"primary\">\n                                <CloseIcon className=\"erase-mini\" />\n                            </IconButton>\n                            <IconButton onClick={this.props.resetGrid} color=\"primary\">\n                                <ReplayIcon className=\"reset-mini\" />\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container-mini\">\n                    <button className='generate-btn-mini' onClick={this.props.genMaze}>Generate Maze</button>\n                    <div className=\"card-container-mini\">\n                        <div className=\"maze-alg-selector-mini\">\n                            <IconButton onClick={() => this.props.handleMiniMazeTabs(true)}>\n                                <KeyboardArrowUpIcon className='arrow-btn-up'/>\n                            </IconButton>\n                            {\n                                mazeAlgs.map((alg, val) => {\n                                    if(val === this.props.state.currMazeTab) return (\n                                        <div className=\"maze-title-mini\"><h4 className='title-mini'>{alg}</h4></div>\n                                    )\n                                })\n                            }\n                            <IconButton onClick={() => this.props.handleMiniMazeTabs(false)}>\n                                <KeyboardArrowDownIcon className='arrow-btn-down'/>\n                            </IconButton>\n                        </div>\n                        <div className=\"speed-controls-container-mini\">\n                            <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                                <RemoveIcon className='subtract-btn'/>\n                            </IconButton>\n                            <p className='speed-text-mini'>{this.props.state.animationSpeed}</p>\n                            <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                                <AddIcon className='add-btn'/>\n                            </IconButton>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"bottom-container-mini\">\n                    <div className={`item-card-mini ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <div className='item-info-mini'>\n                            <h2>{currItem.title}</h2>\n                            <div className=\"item-text-mini\">\n                                <p>{currItem.description}</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default NavTop",{"ruleId":"139","replacedBy":"140"},{"ruleId":"141","replacedBy":"142"},{"ruleId":"143","severity":1,"message":"144","line":11,"column":11,"nodeType":"145","messageId":"146","endLine":11,"endColumn":20},{"ruleId":"143","severity":1,"message":"147","line":12,"column":11,"nodeType":"145","messageId":"146","endLine":12,"endColumn":26},{"ruleId":"143","severity":1,"message":"148","line":14,"column":11,"nodeType":"145","messageId":"146","endLine":14,"endColumn":19},{"ruleId":"143","severity":1,"message":"149","line":20,"column":11,"nodeType":"145","messageId":"146","endLine":20,"endColumn":19},{"ruleId":"143","severity":1,"message":"150","line":21,"column":11,"nodeType":"145","messageId":"146","endLine":21,"endColumn":25},{"ruleId":"143","severity":1,"message":"151","line":8,"column":8,"nodeType":"145","messageId":"146","endLine":8,"endColumn":12},{"ruleId":"143","severity":1,"message":"152","line":9,"column":8,"nodeType":"145","messageId":"146","endLine":9,"endColumn":11},{"ruleId":"153","severity":1,"message":"154","line":34,"column":27,"nodeType":"155","endLine":34,"endColumn":124},{"ruleId":"153","severity":1,"message":"154","line":39,"column":27,"nodeType":"155","endLine":39,"endColumn":127},{"ruleId":"153","severity":1,"message":"154","line":49,"column":27,"nodeType":"155","endLine":49,"endColumn":123},{"ruleId":"156","severity":1,"message":"157","line":129,"column":37,"nodeType":"155","endLine":130,"endColumn":93},{"ruleId":"143","severity":1,"message":"158","line":57,"column":13,"nodeType":"145","messageId":"146","endLine":57,"endColumn":19},{"ruleId":"159","severity":1,"message":"160","line":4,"column":1,"nodeType":"161","endLine":179,"endColumn":3},{"ruleId":"162","severity":1,"message":"163","line":55,"column":17,"nodeType":"145","messageId":"164","endLine":55,"endColumn":31},{"ruleId":"165","severity":1,"message":"166","line":188,"column":39,"nodeType":"167","messageId":"168","endLine":188,"endColumn":41},{"ruleId":"165","severity":1,"message":"166","line":188,"column":55,"nodeType":"167","messageId":"168","endLine":188,"endColumn":57},{"ruleId":"159","severity":1,"message":"160","line":3,"column":1,"nodeType":"161","endLine":84,"endColumn":2},{"ruleId":"159","severity":1,"message":"160","line":4,"column":1,"nodeType":"161","endLine":176,"endColumn":2},{"ruleId":"162","severity":1,"message":"163","line":57,"column":21,"nodeType":"145","messageId":"164","endLine":57,"endColumn":35},{"ruleId":"159","severity":1,"message":"160","line":2,"column":1,"nodeType":"161","endLine":174,"endColumn":2},{"ruleId":"159","severity":1,"message":"160","line":4,"column":1,"nodeType":"161","endLine":160,"endColumn":2},{"ruleId":"159","severity":1,"message":"160","line":3,"column":1,"nodeType":"161","endLine":163,"endColumn":2},{"ruleId":"159","severity":1,"message":"160","line":3,"column":1,"nodeType":"161","endLine":221,"endColumn":2},{"ruleId":"143","severity":1,"message":"169","line":10,"column":8,"nodeType":"145","messageId":"146","endLine":10,"endColumn":18},{"ruleId":"143","severity":1,"message":"170","line":11,"column":8,"nodeType":"145","messageId":"146","endLine":11,"endColumn":14},{"ruleId":"143","severity":1,"message":"171","line":12,"column":10,"nodeType":"145","messageId":"146","endLine":12,"endColumn":20},{"ruleId":"143","severity":1,"message":"172","line":21,"column":10,"nodeType":"145","messageId":"146","endLine":21,"endColumn":28},{"ruleId":"153","severity":1,"message":"154","line":30,"column":27,"nodeType":"155","endLine":30,"endColumn":129},{"ruleId":"153","severity":1,"message":"154","line":35,"column":27,"nodeType":"155","endLine":35,"endColumn":132},{"ruleId":"153","severity":1,"message":"154","line":45,"column":27,"nodeType":"155","endLine":45,"endColumn":128},{"ruleId":"143","severity":1,"message":"173","line":59,"column":15,"nodeType":"145","messageId":"146","endLine":59,"endColumn":26},{"ruleId":"143","severity":1,"message":"174","line":66,"column":15,"nodeType":"145","messageId":"146","endLine":66,"endColumn":27},{"ruleId":"175","severity":1,"message":"176","line":98,"column":56,"nodeType":"177","messageId":"178","endLine":98,"endColumn":58},{"ruleId":"175","severity":1,"message":"176","line":133,"column":57,"nodeType":"177","messageId":"178","endLine":133,"endColumn":59},{"ruleId":"156","severity":1,"message":"157","line":160,"column":37,"nodeType":"155","endLine":161,"endColumn":93},"no-native-reassign",["179"],"no-negated-in-lhs",["180"],"no-unused-vars","'isVisited' is assigned a value but never used.","Identifier","unusedVar","'isVisitedSecond' is assigned a value but never used.","'isWeight' is assigned a value but never used.","'distance' is assigned a value but never used.","'distanceSecond' is assigned a value but never used.","'Tabs' is defined but never used.","'Tab' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","'height' is assigned a value but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-redeclare","'unvisitedNodes' is already defined.","redeclared","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","'Typography' is defined but never used.","'Button' is defined but never used.","'makeStyles' is defined but never used.","'FaAngleDoubleRight' is defined but never used.","'currItemPic' is assigned a value but never used.","'screenHeight' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-global-assign","no-unsafe-negation"]