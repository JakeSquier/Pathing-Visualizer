[{"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/index.js":"1","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/App.js":"2","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/reportWebVitals.js":"3","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Node/Node.jsx":"4","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Visualizer.jsx":"5","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/Navbar.jsx":"6","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/item-data.js":"7","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/alg-data.js":"8","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/randomMaze.js":"9","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/verticalMaze.js":"10","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/HorizontalMaze.js":"11","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js":"12","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/MainContainer.jsx":"13","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/workerSetup.js":"14","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/dijkstraWorker.js":"15","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/pathGrabWorker.js":"16","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/aStarWorker.js":"17","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js":"18","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js":"19","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js":"20","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/topNav.jsx":"21","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js":"22"},{"size":500,"mtime":1653054673509,"results":"23","hashOfConfig":"24"},{"size":178,"mtime":1652843661057,"results":"25","hashOfConfig":"24"},{"size":362,"mtime":1625667178580,"results":"26","hashOfConfig":"24"},{"size":1068,"mtime":1658603788374,"results":"27","hashOfConfig":"24"},{"size":1833,"mtime":1658565610420,"results":"28","hashOfConfig":"24"},{"size":7701,"mtime":1659001980229,"results":"29","hashOfConfig":"24"},{"size":1162,"mtime":1633901559330,"results":"30","hashOfConfig":"24"},{"size":1460,"mtime":1634681693937,"results":"31","hashOfConfig":"24"},{"size":717,"mtime":1659001458797,"results":"32","hashOfConfig":"24"},{"size":1599,"mtime":1658091448585,"results":"33","hashOfConfig":"24"},{"size":1600,"mtime":1658092258416,"results":"34","hashOfConfig":"24"},{"size":3705,"mtime":1658116384447,"results":"35","hashOfConfig":"24"},{"size":51976,"mtime":1659002714836,"results":"36","hashOfConfig":"24"},{"size":208,"mtime":1653157229999,"results":"37","hashOfConfig":"24"},{"size":7102,"mtime":1659002446012,"results":"38","hashOfConfig":"24"},{"size":2455,"mtime":1659002653107,"results":"39","hashOfConfig":"24"},{"size":6718,"mtime":1659002177900,"results":"40","hashOfConfig":"24"},{"size":7628,"mtime":1659002638099,"results":"41","hashOfConfig":"24"},{"size":6301,"mtime":1658204371449,"results":"42","hashOfConfig":"24"},{"size":6251,"mtime":1659002570789,"results":"43","hashOfConfig":"24"},{"size":996,"mtime":1659002076309,"results":"44","hashOfConfig":"24"},{"size":11384,"mtime":1659001316852,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"mi99av",{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"48"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"48"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"97","messages":"98","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"48"},"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/index.js",[],["100","101"],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/App.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/reportWebVitals.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Node/Node.jsx",["102","103","104","105","106"],"import React, {Component} from 'react';\nimport './Node.css'\n\nclass Node extends Component {\n\n    render() {\n        const {\n          col,\n          isFinish,\n          isStart,\n          isVisited,\n          isVisitedSecond,\n          isWall,\n          isWeight,\n          isStop,\n          onMouseDown,\n          onMouseEnter,\n          onMouseUp,\n          row,\n          distance,\n          distanceSecond\n        } = this.props;\n        const extraClassName = \n          isFinish\n          ? 'node-finish'\n          : isStart\n          ? 'node-start'\n          : isStop\n          ? 'node-stop'\n          : isWall\n          ? 'node-wall'\n          : ''\n    \n        return (\n          <div\n            id={`node-${row}-${col}`}\n            className={`node node-gap-vert node-gap-horiz ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={(e) => {\n              \n              onMouseEnter(row, col)\n            }}\n            onMouseUp={() => onMouseUp()}>\n          </div>\n        );\n      }\n}\n\nexport default Node;","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/PathFindingVisualizer/Visualizer.jsx",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/Navbar.jsx",["107","108","109","110"],"import React, {Component} from 'react';\nimport algData from '../../data/alg-data'\nimport './nav.css'\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\n\n\nexport default class Navbar extends Component {\n\n    useStyles = makeStyles(theme => ({\n        customHoverFocus: {\n          \"&:hover, &.Mui-focusVisible\": { backgroundColor: \"yellow\" }\n        }\n    }));    \n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n        \n\n        return(\n            <div className={`nav-bar nav-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container'>\n                    <IconButton className=\"nav-btn\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"algs-container\">\n                    <div className=\"alg-selector\">\n                        <Tabs\n                            orientation=\"vertical\"\n                            TabIndicatorProps={{style: {background:'rgb(100, 255, 218)'}}}\n                            value={this.props.state.currAlgTab}\n                            onChange={this.props.handleTabs}\n                            variant=\"scrollable\"\n                            \n                        >\n                            {algData.map((alg, val) => {\n                                return <Tab className=\"alg-tab\" label={<span className=\"alg-tab-text\">{`${alg.name}`}</span>} value={val} />\n                            })}\n                        </Tabs>\n                    </div>\n                    <div className='alg-card'>\n                        <div className='alg-card-glass'>\n                            <h2 className=\"alg-card-title\">{currAlg.name}</h2>\n                            <div className=\"alg-card-text-container\">\n                                <p className=\"alg-card-desc\">{currAlg.description}</p>\n                            </div>\n                            <div className=\"play-btn-container\">\n                                <IconButton onClick={this.props.play}>\n                                    <PlayCircleFilledIcon className=\"play-btn\" size=\"10em\" fontSize=\"inherit\"/>\n                                </IconButton>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container\">\n                    <div className='speed-container'>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                            <RemoveIcon className='subtract-btn'/>\n                        </IconButton>\n                        <p className='speed-text'>{this.props.state.animationSpeed}</p>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                            <AddIcon className='add-btn'/>\n                        </IconButton>\n                    </div>\n                    <Button className=\"maze-btn\" onClick={this.props.genMaze} variant=\"contained\" fullWidth={true} color=\"primary\">\n                        <Typography className=\"maze-btn-text\" >\n                            Generate\n                        </Typography>\n                    </Button>\n                    <div className=\"maze-selector\">\n                        <Tabs\n                            orientation=\"vertical\"\n                            TabIndicatorProps={{style: {background: 'rgb(100, 255, 218)'}}}\n                            value={this.props.state.currMazeTab}\n                            onChange={this.props.handleMazeTabs}\n                            variant=\"scrollable\"\n                            \n                        >\n                            {mazeAlgs.map((title, val) => {\n                                return <Tab className=\"alg-tab\" label={<span className=\"alg-tab-text\">{`${title}`}</span>} value={val} />\n                            })}\n                        </Tabs>\n                    </div>\n                </div>\n                <div className=\"items-container\">\n                    <div className={`item-card ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <h2 className=\"item-title\">{currItem.title}</h2>\n                        <div className=\"description-box\">\n                            <p className=\"item-description\">{currItem.description}</p>\n                        </div>\n                        {currItemPic}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/item-data.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/data/alg-data.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/randomMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/verticalMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/HorizontalMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/MainContainer.jsx",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/workerSetup.js",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/dijkstraWorker.js",["111","112","113"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function dijkstra(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else {\n                node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){     \n                sortNodesByDistance(unvisitedNodes, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            } else if(isStop){\n            //going to repeat normal function yet twice for stop\n            const visitedNodesInOrder = [[],[]]\n            //grabbing all nodes\n        \n            var unvisitedNodesSecond = getAllNodes(grid)\n        \n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else if(node === stopNode) {\n                node.distanceSecond = 0\n                } else {\n                node.distance = Infinity\n                node.distanceSecond = Infinity\n                }\n            })\n        \n            //getting path from start to stop\n            while(!!unvisitedNodes) {\n                sortNodesByDistance(unvisitedNodes, false)\n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) break\n        \n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder[0].push(closestNode)\n        \n                //checking to see is closest node is the finishnode\n                if(closestNode === stopNode) break\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            \n            //getting path from stop to finish\n            while(!!unvisitedNodesSecond) {\n                \n                sortNodesByDistance(unvisitedNodesSecond, true)\n\n                const closestNode = unvisitedNodesSecond.shift()\n        \n                if(closestNode.isWall) continue\n        \n                if(closestNode.distanceSecond === Infinity) break\n\n                closestNode.isVisitedSecond = true\n                visitedNodesInOrder[1].push(closestNode)\n        \n                if(closestNode === finishNode) break\n        \n                updateUnvisitedNeighbors(closestNode, grid, true)\n            }\n            return visitedNodesInOrder\n        }\n    }\n\n        function sortNodesByDistance(unvisitedNodes, isStop) {\n            //it is not calculating second distace correctly stays at infinity\n            unvisitedNodes.sort((nodeA, nodeB) => {\n              if(isStop===true) {\n\n                return nodeA.distanceSecond - nodeB.distanceSecond\n              } else {\n                \n                return nodeA.distance - nodeB.distance\n              }\n            });\n            var distanceCheck = []\n            if(isStop){\n              unvisitedNodes.forEach((node) => {\n                if(node.distanceSecond !== Infinity) distanceCheck.push(node)\n              })\n            }\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop)\n            for (const neighbor of unvisitedNeighbors) {\n              isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1\n        \n              isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node\n            }\n        }\n          \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node\n            if (row > 0) neighbors.push(grid[row - 1][col])\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\n            if (col > 0) neighbors.push(grid[row][col - 1])\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\n            return neighbors.filter((neighbor) => {\n              //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n              if(isStop===true){\n                return !neighbor.isVisitedSecond\n              } else {\n                return !neighbor.isVisited\n              }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = []\n            for (const row of grid) {\n              for (const node of row) {\n                nodes.push(node)\n              }\n            }\n            return nodes\n        }\n\n\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = dijkstra(grid, startNode, finishNode, stopNode)\n  \n        postMessage(visitedNodesInorder)\n    });\n};\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode, stop=false) {\n      const nodesInShortestPathOrder = []\n      let currentNode = finishNode\n      while (currentNode !== null) {\n\n        if(currentNode.isStart===true && stop===false || typeof currentNode.previousNode !== 'object') break\n\n        if(currentNode.isStop===true && stop===true) break\n\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n      }\n      return nodesInShortestPathOrder\n  }","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/pathGrabWorker.js",["114"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n\n        if (!message) return;\n\n        var stopNode=false, finishNode=false, startNode=false\n\n        const stop = message.data[1]\n        const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0]\n\n        nodes.map((node) => {\n\n            if(node.isStop === true) stopNode = node\n\n            if(node.isFinish === true) finishNode = node\n\n            if(node.isStart === true) startNode = node\n\n            return node\n        })\n\n        var nodesInShortestPathOrder = [];\n\n        if(!stop) {\n\n            if(finishNode === false) postMessage(false)\n\n            let currentNode = finishNode\n\n            while (currentNode !== null) {\n\n                if(currentNode.isStart===true) break\n\n                nodesInShortestPathOrder.unshift(currentNode)\n\n                currentNode = currentNode.previousNode\n            }\n\n            if(!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode)\n\n            postMessage(nodesInShortestPathOrder)\n\n        } else if(stop) {\n\n            var startToStop=[], stopToFinish=[]\n            let currentNodeFin = finishNode\n            let currentNodeStop = stopNode\n\n            if (message.data[0][1].filter(node => node.isFinish === true).length > 0) {\n                while (currentNodeFin !== null) {\n\n                    if(currentNodeFin.isStop===true) break;\n    \n                    stopToFinish.unshift(currentNodeFin);\n    \n                    currentNodeFin = currentNodeFin.previousNodeSecond;\n                }\n                if(!stopToFinish[0].isStop) stopToFinish.unshift(stopNode)\n            } else {\n                stopToFinish.unshift(false)\n            }\n\n            if (message.data[0][0].filter(node => node.isStop === true).length > 0) {\n                while (currentNodeStop !== null) {\n\n                    if(currentNodeStop.isStart===true) break;\n\n                    startToStop.unshift(currentNodeStop);\n\n                    currentNodeStop = currentNodeStop.previousNode;\n                }\n                if(!startToStop[0].isStart) startToStop.unshift(startNode)\n\n            } else {\n                startToStop.unshift(false)\n            }\n\n            postMessage([startToStop, stopToFinish])\n        }\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/aStarWorker.js",["115"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n\n        function aStar(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                    node.distance = 0\n                } else {\n                    node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){\n\n                sortNodesByDistance(unvisitedNodes, finishNode, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false);\n            }\n            } else if(isStop){\n                //going to repeat normal function yet twice for stop\n                const visitedNodesInOrder = [[],[]]\n                //grabbing all nodes        \n                var unvisitedNodesSecond = getAllNodes(grid)\n            \n                unvisitedNodes.forEach((node) => {\n                    if(node === startNode){\n                        node.distance = 0\n                    } else if(node === stopNode) {\n                        node.distanceSecond = 0\n                    } else {\n                        node.distance = Infinity\n                        node.distanceSecond = Infinity\n                    }\n                })\n            \n                //getting path from start to stop\n                while(!!unvisitedNodes) {\n                    sortNodesByDistance(unvisitedNodes, stopNode, false)\n                    const closestNode = unvisitedNodes.shift()\n            \n                    //checking if current node is a wall\n                    if(closestNode.isWall) continue\n            \n                    //checking if node has no where to venture to\n                    if(closestNode.distance === Infinity) break\n            \n                    //update current node as visited then pushing it to visitednodes array\n                    closestNode.isVisited = true\n                    visitedNodesInOrder[0].push(closestNode)\n            \n                    //checking to see is closest node is the finishnode\n                    if(closestNode === stopNode) break\n            \n                    //get current nodes neighbors\n                    updateUnvisitedNeighbors(closestNode, grid, false);\n                }\n                \n                //getting path from stop to finish\n                while(!!unvisitedNodesSecond) {\n                    \n                    sortNodesByDistance(unvisitedNodesSecond, finishNode, true)\n\n                    const closestNode = unvisitedNodesSecond.shift()\n            \n                    if(closestNode.isWall) continue\n            \n                    if(closestNode.distanceSecond === Infinity) break\n\n                    closestNode.isVisitedSecond = true\n                    visitedNodesInOrder[1].push(closestNode)\n            \n                    if(closestNode === finishNode) break\n            \n                    updateUnvisitedNeighbors(closestNode, grid, true)\n                }\n                return visitedNodesInOrder\n            }\n        }\n\n        function sortNodesByDistance(unvisitedNodes, finishNode, isStop) {\n            // calculating f\n            const f = finishNode\n            unvisitedNodes.sort((nodeA, nodeB) => {\n                const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n                const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n\n                if(isStop){\n                    return (nodeA.distanceSecond+af) - (nodeB.distanceSecond+bf)\n                } else {\n                    return (nodeA.distance+af) - (nodeB.distance+bf)\n                }\n            });\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop);\n            for (const neighbor of unvisitedNeighbors) {\n                \n                isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1;\n        \n                isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node;\n            }\n        }\n        \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node;\n            if (row > 0) neighbors.push(grid[row - 1][col]);\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n            if (col > 0) neighbors.push(grid[row][col - 1]);\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n            return neighbors.filter((neighbor) => {\n            //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n            if(isStop===true){\n                return !neighbor.isVisitedSecond\n            } else {\n                return !neighbor.isVisited\n            }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = [];\n            for (const row of grid) {\n            for (const node of row) {\n                nodes.push(node);\n            }\n            }\n            return nodes;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = aStar(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js",["116"],"var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                \n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = []\n                let unvisitedNodesSecond = []\n                let firstSearch = []\n                let secondSearch = []\n                startNode.distance = 0\n                unvisitedNodes.push(startNode)\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance)\n                  let closestNode = unvisitedNodes.shift()\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour)\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                  let closestNode = unvisitedNodesSecond.shift()\n                  if (closestNode === finishNode) {\n                    secondSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisitedSecond = true\n                  secondSearch.push(closestNode)\n              \n                  let neighbours = getNeighbours(closestNode, grid, true)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n                      unvisitedNodesSecond.unshift(neighbour)\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    } else if (distance < neighbour.distanceSecond) {\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    }\n                  }\n                }\n\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            }\n            return neighbour.filter(\n              (node) => {\n                  if(isStop){\n                    return !node.isWall && !node.isVisitedSecond\n                  } else {\n                    return !node.isWall && !node.isVisited\n                  }\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row)\n            let y = Math.abs(node.col - finishNode.col)\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false\n              }\n            }\n            return true\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = []\n    let currentNode = finishNode\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js",["117"],"\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                let queueSecond = [];\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode);\n                queueSecond.push(stopNode)\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        visitedNodesInOrder[0].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                while (queueSecond.length) {\n                    const currNode = queueSecond.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder[1].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n                return visitedNodesInOrder\n\n            } else if(!isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode);\n                        return visitedNodesInOrder;\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                return visitedNodesInOrder\n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js",["118"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/components/navComponents/topNav.jsx",[],"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js",["119"],"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n\n            let unvisitedNodesStart = []\n            let visitedNodesInOrderStart = []\n            let unvisitedNodesFinish = []\n            let visitedNodesInOrderFinish = []\n            startNode.distance = 0\n            finishNode.distance = 0\n            unvisitedNodesStart.push(startNode)\n            unvisitedNodesFinish.push(finishNode)\n        \n            while (\n                unvisitedNodesStart.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                let closestNodeStart = unvisitedNodesStart.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n        \n                closestNodeStart.isVisited = true;\n                closestNodeFinish.isVisited = true;\n                visitedNodesInOrderStart.push(closestNodeStart);\n                visitedNodesInOrderFinish.push(closestNodeFinish);\n                if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                }\n            \n                //Start side search\n                let neighbours = getNeighbours(closestNodeStart, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStart.push(closestNodeStart);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeStart.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        unvisitedNodesStart.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    }\n                }\n            \n                //Finish side search\n                neighbours = getNeighbours(closestNodeFinish, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStart.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                    }\n                }\n            }\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n                      \n        }\n\n        function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n\n            let unvisitedNodesStop = [];\n            let visitedNodesInOrderStop = [];\n            let unvisitedNodesFinish = [];\n            let visitedNodesInOrderFinish = [];\n            stopNode.distanceSecond = 0\n            finishNode.distanceSecond = 0\n            unvisitedNodesStop.push(stopNode)\n            unvisitedNodesFinish.push(finishNode)\n\n            while (\n                unvisitedNodesStop.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStop = unvisitedNodesStop.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStop.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStop.push(closestNodeStop)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                    return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStop, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStop.push(closestNodeStop);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true]\n                    }\n                    let distance = closestNodeStop.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        unvisitedNodesStop.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStop\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStop;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStop.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        var visitedNodesInorder = []\n\n        if (isStop) {\n\n            visitedNodesInorder = [bidirectionalGreedySearch(grid, startNode, stopNode), bidirectionalGreedySearchSecond(grid, stopNode, finishNode)]\n            postMessage(visitedNodesInorder)\n        } else {\n\n            visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n            postMessage(visitedNodesInorder);\n        }\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}",{"ruleId":"120","replacedBy":"121"},{"ruleId":"122","replacedBy":"123"},{"ruleId":"124","severity":1,"message":"125","line":11,"column":11,"nodeType":"126","messageId":"127","endLine":11,"endColumn":20},{"ruleId":"124","severity":1,"message":"128","line":12,"column":11,"nodeType":"126","messageId":"127","endLine":12,"endColumn":26},{"ruleId":"124","severity":1,"message":"129","line":14,"column":11,"nodeType":"126","messageId":"127","endLine":14,"endColumn":19},{"ruleId":"124","severity":1,"message":"130","line":20,"column":11,"nodeType":"126","messageId":"127","endLine":20,"endColumn":19},{"ruleId":"124","severity":1,"message":"131","line":21,"column":11,"nodeType":"126","messageId":"127","endLine":21,"endColumn":25},{"ruleId":"132","severity":1,"message":"133","line":33,"column":27,"nodeType":"134","endLine":33,"endColumn":124},{"ruleId":"132","severity":1,"message":"133","line":38,"column":27,"nodeType":"134","endLine":38,"endColumn":127},{"ruleId":"132","severity":1,"message":"133","line":48,"column":27,"nodeType":"134","endLine":48,"endColumn":123},{"ruleId":"135","severity":1,"message":"136","line":137,"column":37,"nodeType":"134","endLine":138,"endColumn":93},{"ruleId":"137","severity":1,"message":"138","line":4,"column":1,"nodeType":"139","endLine":177,"endColumn":3},{"ruleId":"140","severity":1,"message":"141","line":186,"column":39,"nodeType":"142","messageId":"143","endLine":186,"endColumn":41},{"ruleId":"140","severity":1,"message":"141","line":186,"column":55,"nodeType":"142","messageId":"143","endLine":186,"endColumn":57},{"ruleId":"137","severity":1,"message":"138","line":3,"column":1,"nodeType":"139","endLine":84,"endColumn":2},{"ruleId":"137","severity":1,"message":"138","line":4,"column":1,"nodeType":"139","endLine":174,"endColumn":2},{"ruleId":"137","severity":1,"message":"138","line":2,"column":1,"nodeType":"139","endLine":174,"endColumn":2},{"ruleId":"137","severity":1,"message":"138","line":4,"column":1,"nodeType":"139","endLine":160,"endColumn":2},{"ruleId":"137","severity":1,"message":"138","line":3,"column":1,"nodeType":"139","endLine":163,"endColumn":2},{"ruleId":"137","severity":1,"message":"138","line":3,"column":1,"nodeType":"139","endLine":221,"endColumn":2},"no-native-reassign",["144"],"no-negated-in-lhs",["145"],"no-unused-vars","'isVisited' is assigned a value but never used.","Identifier","unusedVar","'isVisitedSecond' is assigned a value but never used.","'isWeight' is assigned a value but never used.","'distance' is assigned a value but never used.","'distanceSecond' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","no-global-assign","no-unsafe-negation"]