{"version":3,"sources":["mazeAlgorithims/verticalMaze.js","mazeAlgorithims/HorizontalMaze.js","mazeAlgorithims/recursiveDivisionMaze.js","components/PathFindingVisualizer/Node/Node.jsx","components/PathFindingVisualizer/Visualizer.jsx","mazeAlgorithims/randomMaze.js","data/alg-data.js","media/right-arrow.png","media/dart-board.png","media/stop.png","components/navComponents/Navbar.jsx","components/navComponents/topNav.jsx","data/item-data.js","workers/pathGrabWorker.js","workers/dijkstraWorker.js","workers/aStarWorker.js","workers/greedyBestFirstSearchWorker.js","workers/breadthFirstSearchWorker.js","workers/depthFirstSearchWorker.js","workers/bidirectionalGreedySearchWorker.js","workers/workerSetup.js","components/MainContainer.jsx","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","this","props","col","isFinish","isStart","isWall","isVisited","isVisitedSecond","isStop","isWeight","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","distance","distanceSecond","id","className","e","Component","PathfindingVisualizer","state","grid","map","rowIdx","node","nodeIdx","mouseIsPressed","handleMouseDown","handleMouseEnter","handleMouseUp","on","randomMaze","startNode","finishNode","isThereStop","stopNode","length","Math","random","push","sort","verticalMaze","vertical","range","horizontal","getVerticalWalls","len","result","i","choice","floor","num","addWall","isStartFinish","tempWalls","temp","splice","wall","horizontalMaze","getHorizontalWalls","recursiveDivisionMaze","getRecursiveWalls","dir","generateOddRandomNumber","slice","indexOf","array","max","randomNum","generateRandomNumber","algData","name","description","Navbar","useStyles","makeStyles","theme","customHoverFocus","backgroundColor","getWaves","currItem","currItemDesc","style","height","width","src","Start","Finish","Stop","info","wave","currItemPic","currBtnColor","showNav","items","currItemObj","currAlg","currAlgObj","IconButton","onClick","toggleNav","Tabs","orientation","TabIndicatorProps","background","value","currAlgTab","onChange","handleTabs","variant","alg","val","Tab","label","play","size","fontSize","handleSpeedChange","animationSpeed","Button","genMaze","fullWidth","color","Typography","currMazeTab","handleMazeTabs","title","item","isCurrItem","handleItemChange","NavTop","clearGrid","resetGrid","itemData","self","addEventListener","message","stop","data","nodesInShortestPathOrder","startToStop","stopToFinish","currentNodeFin","currentNodeStop","filter","unshift","previousNodeSecond","previousNode","postMessage","currentNode","visitedNodesInorder","visitedNodesInOrder","unvisitedNodesSecond","getAllNodes","unvisitedNodes","forEach","Infinity","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","dijkstra","nodeA","nodeB","distanceCheck","unvisitedNeighbors","neighbors","neighbor","getUnvisitedNeighbors","nodes","aStar","f","af","abs","bf","a","b","totalDistance","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","firstSearch","secondSearch","totalDistanceSecond","greedyBFS","queue","queueSecond","currNode","updateUnvisitedNeighbours","bfs","next","pop","depthFirstSearch","bidirectionalGreedySearch","unvisitedNodesStop","visitedNodesInOrderStop","unvisitedNodesFinish","visitedNodesInOrderFinish","closestNodeStop","closestNodeFinish","isNeighbour","bidirectionalGreedySearchSecond","unvisitedNodesStart","visitedNodesInOrderStart","closestNodeStart","rowStart","colStart","rowFinish","colFinish","WebWorker","worker","code","toString","blob","Blob","Worker","URL","createObjectURL","MainContainer","newGrid","visualizingAlgorithm","generatingMaze","setState","startIsMoving","finishIsMoving","stopIsMoving","getNewGridWithWallToggled","getNewGridWithStart","getNewGridWithFinish","getNewGridWithStopToggled","prevStop","handleNav","handleItemDescChange","newItem","_item","currSpeed","generateMaze","gridClean","maze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","generateRandomMaze","document","getElementsByClassName","rowNum","colNum","getElementById","getGridWithoutPath","playAnimation","visualizeDijkstra","visualizeaStar","visualizbfs","visualizegbfs","visualizedfs","visualizeBidirectionalGreedySearch","handleProgressSetup","isSecondAnimation","animationDuration","progressBar","classList","remove","animateDijkstra","animationStall","animationColor","progress","$","integralVal","setTimeout","animateShortestPath","dijkstraWorker","_dijkstraWorker","pathGrabWorker","START_NODE","FINISH_NODE","STOP_NODE","animateTiming","messageTwo","animateTime","animateaStar","replaceWith","clone","aStarWorker","animatebfs","breadthFirstSearchWorker","animategbfs","greedyBestFirstSearchWorker","animatedfs","depthFirstSearchWorker","animateBidirectionalAlgorithm","isShortedPath","undefined","bidirectionalGreedySearchWorker","_startNode","_finishNode","_stopNode","visitedNodesInOrderStopFirst","visitedNodesInOrderStopSecond","isShortedPathSecond","nodesInShortestPathOrderFirst","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrderSecond","stall","currObj","includes","animateMaze","getNewGridWithMaze","newNode","lcurrMazeAlg","renderGrid","_rowNum","_colNum","currentRow","createNode","prevStart","newStart","oldStart","oldNode","prevFinish","newFinish","oldFinish","newStop","oldStop","minorReset","isShortest","second","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.90a39ff7.chunk.js","sourcesContent":["let walls;\nexport function verticalMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col) ||\n      (isThereStop && (temp === stopNode.row && num === stopNode.col))\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function horizontalMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode, isThereStop, stopNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode, isThereStop, stopNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode, isThereStop, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col) ||\n      (isThereStop && (num === stopNode.row && temp === stopNode.col))\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, isThereStop, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, isThereStop, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode,\n      isThereStop,\n      stopNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode, isThereStop, stopNode) {\n  \n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col) ||\n        (isThereStop && (temp === stopNode.row && num === stopNode.col))\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col) ||\n        (isThereStop && (num === stopNode.row && temp === stopNode.col))\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}","import React, {Component} from 'react';\nimport './Node.css'\n\nclass Node extends Component {\n\n    render() {\n        const {\n          col,\n          isFinish,\n          isStart,\n          isVisited,\n          isVisitedSecond,\n          isWall,\n          isWeight,\n          isStop,\n          onMouseDown,\n          onMouseEnter,\n          onMouseUp,\n          row,\n          distance,\n          distanceSecond\n        } = this.props;\n        const extraClassName = \n          isFinish\n          ? 'node-finish'\n          : isStart\n          ? 'node-start'\n          : isStop\n          ? 'node-stop'\n          : isWall\n          ? 'node-wall'\n          : ''\n    \n        return (\n          <div\n            id={`node-${row}-${col}`}\n            className={`node node-gap-vert node-gap-horiz ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={(e) => {\n              \n              onMouseEnter(row, col)\n            }}\n            onMouseUp={() => onMouseUp()}>\n          </div>\n        );\n      }\n}\n\nexport default Node;","import React, {Component} from 'react';\nimport './visualizer.css'\nimport Node from './Node/Node.jsx'\n\nexport default class PathfindingVisualizer extends Component{\n\n    render() {\n\n        return (\n            <div className=\"grid\">\n                {this.props.state.grid.map((row, rowIdx) => {\n                    return(\n                        <div key={rowIdx} className='grid-row'>\n                            {row.map((node, nodeIdx) => {\n                                const {row, col, isFinish, isStart, isWall, isWeight=false, isStop=false} = node;\n                                return (\n                                    <Node\n                                        key={nodeIdx}\n                                        col={col}\n                                        isFinish={isFinish}\n                                        isStart={isStart}\n                                        isWall={isWall}\n                                        isWeight={isWeight}\n                                        isStop={isStop}\n                                        mouseIsPressed={this.props.state.mouseIsPressed}\n                                        onMouseDown={(row, col) => this.props.handleMouseDown(row, col)}\n                                        onMouseEnter={(row, col) =>\n                                            this.props.handleMouseEnter(row, col)\n                                        }\n                                        onMouseUp={(row, col) => this.props.handleMouseUp(row, col)}\n                                        on\n                                        row={row}\n                                    />\n                                );\n                            })}\n                        </div>\n                    )\n                })}\n            </div>\n        )\n    }\n}\n\n","export function randomMaze(grid, startNode, finishNode, isThereStop, stopNode=false) {\n\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let walls = [];    \n\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          (row === startNode.row && col === startNode.col) ||\n          (row === finishNode.row && col === finishNode.col) ||\n          ( isThereStop && (row === stopNode.row && col === stopNode.col))\n        )\n          continue;\n\n        if (Math.random() < 0.33) {\n          walls.push([row, col]);\n        }\n      }\n    }\n    \n    walls.sort(() => Math.random() - 0.5);\n    return walls;\n  }","const algData = [\n    {\n        name: \"Dijkstra's algorithim\",\n        description: \"Dijkstra's Algorithm starts at the chosen source node and continues to expand outwards calculating distance up until the target node has been reached.\",\n        id: 0\n    },\n    {\n        name: \"A* search\",\n        description: \"A* search is identical to Dijkstra's but, it has brains. A* search calculates the theoretical distance from source to target using the pythagorean theorem.\",\n        id: 1\n    },\n    {\n        name: \"Greedy Best-first Search\",\n        description: \"Greedy Best-first Search is an algorithim which takes after depth-first search and breadth-first search, it uses the heuristic function and search.\",\n        id: 2\n    },\n    {\n        name: \"Bidirectional Greedy Search\",\n        description: \"Bidirectional Greedy Search is Greedy Best-first Search but rather than it searching from just the source it searches from the target as well.\",\n        id: 3\n    },\n    {\n        name: \"Breadth-first search\",\n        description: \"Breadth-first search searches every node in an organized manner until target has been reached but it does not calculate distance like Dijkstra's algorithim.\",\n        id: 4\n    },\n    {\n        name: \"Depth-first search\",\n        description: \"Depth-first search begins at the source node then explores along each branch before backtracking and starting on the next branch.\",\n        id: 5\n    }\n]\n\nexport default algData","export default \"data:image/png;base64,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\"","export default __webpack_public_path__ + \"static/media/dart-board.6357f04e.png\";","export default __webpack_public_path__ + \"static/media/stop.1934617d.png\";","import React, {Component} from 'react';\nimport algData from '../../data/alg-data'\nimport './nav.css'\nimport Start from '../../media/right-arrow.png'\nimport Finish from '../../media/dart-board.png'\nimport Stop from '../../media/stop.png'\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayCircleFilledIcon from '@material-ui/icons/PlayCircleFilled';\nimport ArrowCircleUpIcon from '@mui/icons-material/ArrowCircleUp';\nimport ArrowCircleDownIcon from '@mui/icons-material/ArrowCircleDown';\n\n\nexport default class Navbar extends Component {\n\n    useStyles = makeStyles(theme => ({\n        customHoverFocus: {\n          \"&:hover, &.Mui-focusVisible\": { backgroundColor: \"yellow\" }\n        }\n    }));    \n\n    getWaves = () => {\n        var wave, currItemPic, currBtnColor;\n        var currItem = this.props.state.currItemDesc\n        if(currItem === 'Start'){\n            wave = 'start-item-back'\n            currItemPic = <img className='item-picture start-picture' style={{height: '40px', width: '40px'}} src={Start}/>\n            currBtnColor = 'active-start'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Target'){\n            wave = 'target-item-back'\n            currItemPic = <img className='item-picture target-picture' style={{height: '40px', width: '40px'}} src={Finish} />\n            currBtnColor = 'active-target'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Wall'){\n            wave = 'wall-item-back'\n            currItemPic = <div className='wall-picture'></div>\n            currBtnColor = 'active-wall'\n            return [wave, currItemPic, currBtnColor]\n        } else if(currItem === 'Stop'){\n            wave = 'stop-item-back'\n            currItemPic = <img className='item-picture stop-picture' style={{height: '45px', width: '45px'}} src={Stop} />\n            currBtnColor = 'active-stop'\n            return [wave, currItemPic, currBtnColor]\n        }\n    }\n    render(){\n        const info = this.getWaves()\n        const wave = info[0]\n        const currItemPic = info[1]\n        const currBtnColor = info[2]\n        const showNav = this.props.state.showNav\n        const items = ['Start', 'Target', 'Wall', 'Stop']\n        const mazeAlgs = ['Recursive Division Maze', 'Vertical Division Maze', 'Horizontal Divsion Maze', 'Random Maze']\n        const currItem = this.props.state.currItemObj\n        const currAlg = this.props.state.currAlgObj\n        \n\n        return(\n            <div className={`nav-bar nav-${showNav ? 'active' : 'inactive'}`}>\n                <div className='nav-toggle-container'>\n                    <IconButton className=\"nav-btn\" onClick={this.props.toggleNav}>\n                        {this.props.state.showNav ? <ArrowCircleDownIcon /> : <ArrowCircleUpIcon />}\n                    </IconButton>\n                </div>\n                <div className=\"algs-container\">\n                    <div className=\"alg-selector\">\n                        <Tabs\n                            orientation=\"vertical\"\n                            TabIndicatorProps={{style: {background:'rgb(100, 255, 218)'}}}\n                            value={this.props.state.currAlgTab}\n                            onChange={this.props.handleTabs}\n                            variant=\"scrollable\"\n                            \n                        >\n                            {algData.map((alg, val) => {\n                                return <Tab className=\"alg-tab\" label={<span className=\"alg-tab-text\">{`${alg.name}`}</span>} value={val} />\n                            })}\n                        </Tabs>\n                    </div>\n                    <div className='alg-card'>\n                        <div className='alg-card-glass'>\n                            <h2 className=\"alg-card-title\">{currAlg.name}</h2>\n                            <div className=\"alg-card-text-container\">\n                                <p className=\"alg-card-desc\">{currAlg.description}</p>\n                            </div>\n                            <div className=\"play-btn-container\">\n                                <IconButton onClick={this.props.play}>\n                                    <PlayCircleFilledIcon className=\"play-btn\" size=\"10em\" fontSize=\"inherit\"/>\n                                </IconButton>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <div className=\"middle-container\">\n                    <div className='speed-container'>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, true)}}>\n                            <RemoveIcon className='subtract-btn'/>\n                        </IconButton>\n                        <p className='speed-text'>{this.props.state.animationSpeed}</p>\n                        <IconButton onClick={(e) => {this.props.handleSpeedChange(e, false)}}>\n                            <AddIcon className='add-btn'/>\n                        </IconButton>\n                    </div>\n                    <Button className=\"maze-btn\" onClick={this.props.genMaze} variant=\"contained\" fullWidth={true} color=\"primary\">\n                        <Typography className=\"maze-btn-text\" >\n                            Generate\n                        </Typography>\n                    </Button>\n                    <div className=\"maze-selector\">\n                        <Tabs\n                            orientation=\"vertical\"\n                            TabIndicatorProps={{style: {background: 'rgb(100, 255, 218)'}}}\n                            value={this.props.state.currMazeTab}\n                            onChange={this.props.handleMazeTabs}\n                            variant=\"scrollable\"\n                            \n                        >\n                            {mazeAlgs.map((title, val) => {\n                                return <Tab className=\"alg-tab\" label={<span className=\"alg-tab-text\">{`${title}`}</span>} value={val} />\n                            })}\n                        </Tabs>\n                    </div>\n                </div>\n                <div className=\"items-container\">\n                    <div className={`item-card ${wave}`}>\n                        <div className=\"items-selector\">\n                            {items.map((item, i) => {\n                                const isCurrItem = this.props.state.currItemDesc === item\n                                return (\n                                    <a className={`item-btn item-btn-${isCurrItem ? `${currBtnColor}` : 'inactive'} ${i===0 ? 'first-btn' : ''} ${i===(items.length-1) ? 'last-btn' : ''}`} id={`${item}-btn`}\n                                    onClick={(e) => {this.props.handleItemChange(e, item)}}>\n                                        <p className=\"item-btn-text\">{item}</p>\n                                    </a>\n                                );\n                            })}\n                        </div>\n                        <h2 className=\"item-title\">{currItem.title}</h2>\n                        <div className=\"description-box\">\n                            <p className=\"item-description\">{currItem.description}</p>\n                        </div>\n                        {currItemPic}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","import React, {Component} from \"react\";\nimport IconButton from '@material-ui/core/IconButton';\nimport ReplayIcon from '@material-ui/icons/Replay';\nimport CloseIcon from '@mui/icons-material/Close';\n\nclass NavTop extends Component {\n\n    render(){\n\n        return(\n            <div className='side-nav-container'>\n                <div className='reset-options-container'>\n                    <div className='reset-container'>\n                        <IconButton onClick={this.props.clearGrid} color=\"primary\">\n                                <CloseIcon className=\"erase-btn\" />\n                        </IconButton>\n                    </div>\n                    <div className='erase-container'>\n                        <IconButton onClick={this.props.resetGrid} color=\"primary\">\n                                <ReplayIcon className=\"reset-btn\" />\n                        </IconButton>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default NavTop","const itemData = [\n    {\n        id: 'Start',\n        title: 'Start Node',\n        description: 'The Start node represents where we will start. You can click and drag the start node around anywhere on the grid to create a new starting point.'\n    },\n    {\n        id: 'Target',\n        title: 'Target Node',\n        description: 'The target node represents the desired destination. You can click and drag the target node around anywhere on the grid to create a new destination.'\n    },\n    {\n        id: 'Wall',\n        title: 'Wall',\n        description: 'Walls represent obstructions that stand in the way of you and your destination. Click and drag anywhere on the grid to create walls.'\n    },\n    // {\n    //     id: 'Weight',\n    //     title: 'Wheight',\n    //     description: 'Wheights represent a node that will take longer to travel through than a regular node. Click and drag to drop wheights on the grid.'\n    // },\n    {\n        id: 'Stop',\n        title: 'Stop',\n        description: 'A stop node represents a sub destination. This means that we must find the shortest route that includes a stop at the stop node.'\n    }\n]\n\nexport default itemData","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n\n        if (!message) return;\n\n        var stopNode=false, finishNode=false, startNode=false\n\n        const stop = message.data[1]\n        const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0]\n\n        nodes.map((node) => {\n\n            if(node.isStop === true) stopNode = node\n\n            if(node.isFinish === true) finishNode = node\n\n            if(node.isStart === true) startNode = node\n\n            return node\n        })\n\n        var nodesInShortestPathOrder = [];\n\n        if(!stop) {\n\n            if(finishNode === false) postMessage(false)\n\n            let currentNode = finishNode\n\n            while (currentNode !== null) {\n\n                if(currentNode.isStart===true) break\n\n                nodesInShortestPathOrder.unshift(currentNode)\n\n                currentNode = currentNode.previousNode\n            }\n\n            if(!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode)\n\n            postMessage(nodesInShortestPathOrder)\n\n        } else if(stop) {\n\n            var startToStop=[], stopToFinish=[]\n            let currentNodeFin = finishNode\n            let currentNodeStop = stopNode\n\n            if (message.data[0][1].filter(node => node.isFinish === true).length > 0) {\n                while (currentNodeFin !== null) {\n\n                    if(currentNodeFin.isStop===true) break;\n    \n                    stopToFinish.unshift(currentNodeFin);\n    \n                    currentNodeFin = currentNodeFin.previousNodeSecond;\n                }\n                if(!stopToFinish[0].isStop) stopToFinish.unshift(stopNode)\n            } else {\n                stopToFinish.unshift(false)\n            }\n\n            if (message.data[0][0].filter(node => node.isStop === true).length > 0) {\n                while (currentNodeStop !== null) {\n\n                    if(currentNodeStop.isStart===true) break;\n\n                    startToStop.unshift(currentNodeStop);\n\n                    currentNodeStop = currentNodeStop.previousNode;\n                }\n                if(!startToStop[0].isStart) startToStop.unshift(startNode)\n\n            } else {\n                startToStop.unshift(false)\n            }\n\n            postMessage([startToStop, stopToFinish])\n        }\n    })\n}","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function dijkstra(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else {\n                node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){     \n                sortNodesByDistance(unvisitedNodes, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            } else if(isStop){\n            //going to repeat normal function yet twice for stop\n            const visitedNodesInOrder = [[],[]]\n            //grabbing all nodes\n        \n            var unvisitedNodesSecond = getAllNodes(grid)\n        \n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                node.distance = 0\n                } else if(node === stopNode) {\n                node.distanceSecond = 0\n                } else {\n                node.distance = Infinity\n                node.distanceSecond = Infinity\n                }\n            })\n        \n            //getting path from start to stop\n            while(!!unvisitedNodes) {\n                sortNodesByDistance(unvisitedNodes, false)\n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) break\n        \n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder[0].push(closestNode)\n        \n                //checking to see is closest node is the finishnode\n                if(closestNode === stopNode) break\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false)\n            }\n            \n            //getting path from stop to finish\n            while(!!unvisitedNodesSecond) {\n                \n                sortNodesByDistance(unvisitedNodesSecond, true)\n\n                const closestNode = unvisitedNodesSecond.shift()\n        \n                if(closestNode.isWall) continue\n        \n                if(closestNode.distanceSecond === Infinity) break\n\n                closestNode.isVisitedSecond = true\n                visitedNodesInOrder[1].push(closestNode)\n        \n                if(closestNode === finishNode) break\n        \n                updateUnvisitedNeighbors(closestNode, grid, true)\n            }\n            return visitedNodesInOrder\n        }\n    }\n\n        function sortNodesByDistance(unvisitedNodes, isStop) {\n            //it is not calculating second distace correctly stays at infinity\n            unvisitedNodes.sort((nodeA, nodeB) => {\n              if(isStop===true) {\n\n                return nodeA.distanceSecond - nodeB.distanceSecond\n              } else {\n                \n                return nodeA.distance - nodeB.distance\n              }\n            });\n            var distanceCheck = []\n            if(isStop){\n              unvisitedNodes.forEach((node) => {\n                if(node.distanceSecond !== Infinity) distanceCheck.push(node)\n              })\n            }\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop)\n            for (const neighbor of unvisitedNeighbors) {\n              isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1\n        \n              isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node\n            }\n        }\n          \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node\n            if (row > 0) neighbors.push(grid[row - 1][col])\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\n            if (col > 0) neighbors.push(grid[row][col - 1])\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\n            return neighbors.filter((neighbor) => {\n              //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n              if(isStop===true){\n                return !neighbor.isVisitedSecond\n              } else {\n                return !neighbor.isVisited\n              }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = []\n            for (const row of grid) {\n              for (const node of row) {\n                nodes.push(node)\n              }\n            }\n            return nodes\n        }\n\n\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = dijkstra(grid, startNode, finishNode, stopNode)\n  \n        postMessage(visitedNodesInorder)\n    });\n};\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode, stop=false) {\n      const nodesInShortestPathOrder = []\n      let currentNode = finishNode\n      while (currentNode !== null) {\n\n        if(currentNode.isStart===true && stop===false || typeof currentNode.previousNode !== 'object') break\n\n        if(currentNode.isStop===true && stop===true) break\n\n        nodesInShortestPathOrder.unshift(currentNode)\n        currentNode = currentNode.previousNode\n      }\n      return nodesInShortestPathOrder\n  }","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n\n        function aStar(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                    node.distance = 0\n                } else {\n                    node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){\n\n                sortNodesByDistance(unvisitedNodes, finishNode, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false);\n            }\n            } else if(isStop){\n                //going to repeat normal function yet twice for stop\n                const visitedNodesInOrder = [[],[]]\n                //grabbing all nodes        \n                var unvisitedNodesSecond = getAllNodes(grid)\n            \n                unvisitedNodes.forEach((node) => {\n                    if(node === startNode){\n                        node.distance = 0\n                    } else if(node === stopNode) {\n                        node.distanceSecond = 0\n                    } else {\n                        node.distance = Infinity\n                        node.distanceSecond = Infinity\n                    }\n                })\n            \n                //getting path from start to stop\n                while(!!unvisitedNodes) {\n                    sortNodesByDistance(unvisitedNodes, stopNode, false)\n                    const closestNode = unvisitedNodes.shift()\n            \n                    //checking if current node is a wall\n                    if(closestNode.isWall) continue\n            \n                    //checking if node has no where to venture to\n                    if(closestNode.distance === Infinity) break\n            \n                    //update current node as visited then pushing it to visitednodes array\n                    closestNode.isVisited = true\n                    visitedNodesInOrder[0].push(closestNode)\n            \n                    //checking to see is closest node is the finishnode\n                    if(closestNode === stopNode) break\n            \n                    //get current nodes neighbors\n                    updateUnvisitedNeighbors(closestNode, grid, false);\n                }\n                \n                //getting path from stop to finish\n                while(!!unvisitedNodesSecond) {\n                    \n                    sortNodesByDistance(unvisitedNodesSecond, finishNode, true)\n\n                    const closestNode = unvisitedNodesSecond.shift()\n            \n                    if(closestNode.isWall) continue\n            \n                    if(closestNode.distanceSecond === Infinity) break\n\n                    closestNode.isVisitedSecond = true\n                    visitedNodesInOrder[1].push(closestNode)\n            \n                    if(closestNode === finishNode) break\n            \n                    updateUnvisitedNeighbors(closestNode, grid, true)\n                }\n                return visitedNodesInOrder\n            }\n        }\n\n        function sortNodesByDistance(unvisitedNodes, finishNode, isStop) {\n            // calculating f\n            const f = finishNode\n            unvisitedNodes.sort((nodeA, nodeB) => {\n                const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n                const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n\n                if(isStop){\n                    return (nodeA.distanceSecond+af) - (nodeB.distanceSecond+bf)\n                } else {\n                    return (nodeA.distance+af) - (nodeB.distance+bf)\n                }\n            });\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop);\n            for (const neighbor of unvisitedNeighbors) {\n                \n                isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1;\n        \n                isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node;\n            }\n        }\n        \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node;\n            if (row > 0) neighbors.push(grid[row - 1][col]);\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n            if (col > 0) neighbors.push(grid[row][col - 1]);\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n            return neighbors.filter((neighbor) => {\n            //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n            if(isStop===true){\n                return !neighbor.isVisitedSecond\n            } else {\n                return !neighbor.isVisited\n            }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = [];\n            for (const row of grid) {\n            for (const node of row) {\n                nodes.push(node);\n            }\n            }\n            return nodes;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = aStar(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}","var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                \n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = []\n                let unvisitedNodesSecond = []\n                let firstSearch = []\n                let secondSearch = []\n                startNode.distance = 0\n                unvisitedNodes.push(startNode)\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance)\n                  let closestNode = unvisitedNodes.shift()\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour)\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                  let closestNode = unvisitedNodesSecond.shift()\n                  if (closestNode === finishNode) {\n                    secondSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisitedSecond = true\n                  secondSearch.push(closestNode)\n              \n                  let neighbours = getNeighbours(closestNode, grid, true)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n                      unvisitedNodesSecond.unshift(neighbour)\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    } else if (distance < neighbour.distanceSecond) {\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                      neighbour.previousNodeSecond = closestNode\n                    }\n                  }\n                }\n\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col])\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1])\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col])\n                if (col !== 0) neighbour.push(grid[row][col - 1])\n            }\n            return neighbour.filter(\n              (node) => {\n                  if(isStop){\n                    return !node.isWall && !node.isVisitedSecond\n                  } else {\n                    return !node.isWall && !node.isVisited\n                  }\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row)\n            let y = Math.abs(node.col - finishNode.col)\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false\n              }\n            }\n            return true\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = []\n    let currentNode = finishNode\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder\n}","\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                let queueSecond = [];\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode);\n                queueSecond.push(stopNode)\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        visitedNodesInOrder[0].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                while (queueSecond.length) {\n                    const currNode = queueSecond.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder[1].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n                return visitedNodesInOrder\n\n            } else if(!isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode);\n                        return visitedNodesInOrder;\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                return visitedNodesInOrder\n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}","// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n\n            let unvisitedNodesStart = []\n            let visitedNodesInOrderStart = []\n            let unvisitedNodesFinish = []\n            let visitedNodesInOrderFinish = []\n            startNode.distance = 0\n            finishNode.distance = 0\n            unvisitedNodesStart.push(startNode)\n            unvisitedNodesFinish.push(finishNode)\n        \n            while (\n                unvisitedNodesStart.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                let closestNodeStart = unvisitedNodesStart.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n        \n                closestNodeStart.isVisited = true;\n                closestNodeFinish.isVisited = true;\n                visitedNodesInOrderStart.push(closestNodeStart);\n                visitedNodesInOrderFinish.push(closestNodeFinish);\n                if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                }\n            \n                //Start side search\n                let neighbours = getNeighbours(closestNodeStart, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStart.push(closestNodeStart);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeStart.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        unvisitedNodesStart.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNode = closestNodeStart;\n                    }\n                }\n            \n                //Finish side search\n                neighbours = getNeighbours(closestNodeFinish, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStart.push(neighbour);\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    } else if (distance < neighbour.distance) {\n                        neighbour.distance = distance;\n                        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                    }\n                }\n            }\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n                      \n        }\n\n        function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n\n            let unvisitedNodesStop = [];\n            let visitedNodesInOrderStop = [];\n            let unvisitedNodesFinish = [];\n            let visitedNodesInOrderFinish = [];\n            stopNode.distanceSecond = 0\n            finishNode.distanceSecond = 0\n            unvisitedNodesStop.push(stopNode)\n            unvisitedNodesFinish.push(finishNode)\n\n            while (\n                unvisitedNodesStop.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStop = unvisitedNodesStop.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStop.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStop.push(closestNodeStop)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                    return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStop, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStop.push(closestNodeStop);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true]\n                    }\n                    let distance = closestNodeStop.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        unvisitedNodesStop.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStop\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStop;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStop.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        var visitedNodesInorder = []\n\n        if (isStop) {\n\n            visitedNodesInorder = [bidirectionalGreedySearch(grid, startNode, stopNode), bidirectionalGreedySearchSecond(grid, stopNode, finishNode)]\n            postMessage(visitedNodesInorder)\n        } else {\n\n            visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n            postMessage(visitedNodesInorder);\n        }\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","\nexport default class WebWorker {\n    constructor(worker) {\n      const code = worker.toString();\n      const blob = new Blob([\"(\" + code + \")()\"]);\n      return new Worker(URL.createObjectURL(blob));\n    }\n}","import React, {Component} from 'react';\nimport $ from 'jquery' \nimport Visualizer from './PathFindingVisualizer/Visualizer'\nimport { randomMaze } from '../mazeAlgorithims/randomMaze';\nimport { verticalMaze } from '../mazeAlgorithims/verticalMaze';\nimport { horizontalMaze } from '../mazeAlgorithims/HorizontalMaze';\nimport { recursiveDivisionMaze } from '../mazeAlgorithims/recursiveDivisionMaze';\nimport Navbar from './navComponents/Navbar';\nimport NavTop from './navComponents/topNav';\nimport itemData from '../data/item-data'\nimport algData from '../data/alg-data'\nimport pathGrabWorker from '../workers/pathGrabWorker';\nimport _dijkstraWorker from \"../workers/dijkstraWorker\";\nimport aStarWorker from '../workers/aStarWorker'\nimport greedyBestFirstSearchWorker from '../workers/greedyBestFirstSearchWorker';\nimport breadthFirstSearchWorker from '../workers/breadthFirstSearchWorker';\nimport depthFirstSearchWorker from '../workers/depthFirstSearchWorker';\nimport bidirectionalGreedySearchWorker from '../workers/bidirectionalGreedySearchWorker';\nimport WebWorker from \"../workers/workerSetup\";\nimport './mainContainer.css'\n\nexport default class MainContainer extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n            showNav: false,\n            currItemDesc: 'Start',\n            currItemObj: itemData[0],\n            currAlgObj: algData[0],\n            currAlgTab: 0,\n            lcurrMazeAlg: 'Recursive Division Maze',\n            rowNum: 24,\n            colNum: 49,\n            currMazeTab: 0,\n            startNode: [9, 1],\n            finishNode: [9, 47],\n            startIsMoving: false,\n            finishIsMoving: false,\n            isThereStop: false,\n            stopIsMoving: false,\n            prevStop: [],\n            generatingMaze: false,\n            visualizingAlgorithm: false,\n            animationSpeed: 20,\n            gridClean: true,\n            maze: false\n        }\n    }\n    //reminder!!\n    // row is width\n    // col is height\n    componentDidMount() {\n      const grid = renderGrid(this.state, this.state.rowNum, this.state.colNum)\n      this.setState({grid: grid});\n    }\n\n    handleMouseDown = (row, col) => {\n\n        var newGrid = this.state.grid\n        var node = newGrid[row][col]\n\n        if(this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.grid[row][col].isStart){\n          this.setState({startIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.grid[row][col].isFinish){\n          this.setState({finishIsMoving: true})\n          newGrid = this.state.grid\n        } else if(this.state.currItemDesc === 'Stop'){\n          this.setState({stopIsMoving: true, isThereStop: true})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col)   \n        }\n        this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n    \n    handleMouseEnter = (row, col) => {\n\n        if (!this.state.mouseIsPressed) return;\n\n        var newGrid = this.state.grid;\n        var node = newGrid[row][col]\n\n        if( node.isStart || node.isStop || node.isFinish || this.state.visualizingAlgorithm || this.state.generatingMaze) return\n\n        if(this.state.startIsMoving){\n          newGrid = getNewGridWithStart(this.state.grid, row, col, this.state.startNode)\n          this.setState({startNode: [row, col]})\n        } else if(this.state.finishIsMoving){\n          newGrid = getNewGridWithFinish(this.state.grid, row, col, this.state.finishNode)\n          this.setState({finishNode: [row, col]})\n        } else if(this.state.currItemDesc === 'Stop'){\n          newGrid = getNewGridWithStopToggled(this.state.grid, row, col, this.state.prevStop);\n          this.setState({prevStop: [row, col]})\n        } else if(this.state.currItemDesc === 'Wall' && (!node.isStart && !node.isFinish && !node.isStop)) {\n          newGrid = getNewGridWithWallToggled( newGrid, row, col);\n        }\n        this.setState({grid: newGrid});\n    }\n    \n    handleMouseUp = (row, col) => {\n        this.setState({mouseIsPressed: false, startIsMoving: false, finishIsMoving: false});\n    }\n\n    handleNav = () => {\n      this.setState({showNav: !this.state.showNav})\n    }\n\n    //navBar functions\n    handleItemDescChange = (e, item) => {\n      var newItem = `${item}`\n      itemData.map((_item) => {\n        if(item === _item.id) this.setState({currItemDesc: newItem, currItemObj: _item})\n\n        return _item\n      })\n    }\n\n    handleTabs = (e, val) => {\n      this.setState({currAlgTab: val, currAlgObj: algData[val]})\n    }\n\n    handleMazeTabs = (e, val) => {\n      this.setState({currMazeTab: val})\n    }\n\n    handleSpeedChange = (e, val) => {\n      var currSpeed = this.state.animationSpeed\n\n      if(val && currSpeed > 5){\n        this.setState({animationSpeed: currSpeed-5})\n      } if(!val && currSpeed < 35){\n        this.setState({animationSpeed: currSpeed+5})\n      }\n    }\n\n    generateMaze = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean || this.state.maze) return\n\n      this.setState({maze: true})\n\n      var currAlg = this.state.currMazeTab\n \n      if(currAlg===0){\n        this.generateRecursiveDivisionMaze()\n      } else if(currAlg===1){\n        this.generateVerticalMaze()\n      } else if(currAlg===2){\n        this.generateHorizontalMaze()\n      } else if(currAlg===3){\n        this.generateRandomMaze()\n      }\n    }\n\n    resetGrid = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n\n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const grid = this.state.grid\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n      const stopNode = this.state.isThereStop ? this.state.prevStop : false\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else if(stopNode !== false && (row === stopNode[0] && col === stopNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-stop\";\n          } else if(grid[row][col].isWall)\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-wall\";\n          } else {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid, true);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    clearGrid = () => {\n\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      document.getElementsByClassName('progress')[0].style.width = '0%'\n      \n      var rowNum = this.state.rowNum\n      var colNum = this.state.colNum\n\n      const startNode = this.state.startNode\n      const finishNode = this.state.finishNode\n\n      for (let row = 0; row < rowNum; row++) {\n        for (let col = 0; col < colNum; col++) {\n          if ( (row === startNode[0] && col === startNode[1])) \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n          } else if((row === finishNode[0] && col === finishNode[1]))\n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n          } else \n          {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid);\n      this.setState({\n        grid: newGrid,\n        visualizingAlgorithm: false,\n        generatingMaze: false,\n        prevStop: [],\n        isThereStop: false  ,\n        gridClean: true,\n        maze: false\n      });\n    }\n\n    // play animation\n\n    playAnimation = (e) => {\n\n      if(this.state.generatingMaze || this.state.visualizingAlgorithm || !this.state.gridClean) return\n\n      var currAlg = this.state.currAlgObj.id\n      this.setState({\n        gridClean: false,\n        visualizingAlgorithm: true\n      })\n      if(currAlg===0){\n        this.visualizeDijkstra()\n      } else if(currAlg===1){\n        this.visualizeaStar()\n      } else if(currAlg===4){\n        this.visualizbfs()\n      } else if(currAlg===2){\n        this.visualizegbfs()\n      } else if(currAlg===5){\n        this.visualizedfs()\n      } else if(currAlg===3){\n        this.visualizeBidirectionalGreedySearch()\n      }\n      return\n    }\n\n    handleProgressSetup = (\n      isThereStop, \n      isSecondAnimation, \n      animationSpeed,\n      animationDuration,\n    ) => {\n\n      const progressBar = document.getElementById(`progressBar`)\n      progressBar.className = 'progress progress-no-stop'\n      \n      if(!isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 100/animationDuration\n\n      } else if(!isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-no-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-no-stop-anime')\n          progressBar.className = 'progress progress-no-stop'\n        })\n        return 50/animationDuration\n\n      } else if(isSecondAnimation && isThereStop) {\n\n        progressBar.className = 'progress progress-stop-anime'\n        progressBar.style.animationDuration = `${(animationDuration*animationSpeed/1000)}s`\n        progressBar.addEventListener('animationend', () => {\n          progressBar.classList.remove('progress-stop-anime')\n          progressBar.className = 'progress progress-stop'\n        })\n        return 50/animationDuration\n\n      }\n    }\n\n    //animte dijkstra\n\n    animateDijkstra = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed=10, \n      isThereStop=false,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor;\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progressTracker\n      const progress = $(\"#progressBar\")\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n    \n    visualizeDijkstra = () => {\n\n      this.dijkstraWorker = new WebWorker(_dijkstraWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      if(this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n            \n            const animateTiming = async (message) => {\n\n                this.pathGrabWorker.postMessage([message.data, true])\n\n                this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                    const animateTime = (message, messageTwo) => {\n\n                      var nodesInShortestPathOrder;\n\n                      if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                      } else if(messageTwo.data[0][0] === false) {\n                        nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                      } else if(messageTwo.data[1][0] === false) {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                      } else {\n                        nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                      }\n\n                      this.animateDijkstra(\n                        message.data[0], \n                        nodesInShortestPathOrder, \n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop,\n                        false\n                      )\n\n                      setTimeout(this.animateDijkstra, \n                        message.data[0].length * this.state.animationSpeed, \n                        message.data[1], \n                        nodesInShortestPathOrder,\n                        (message.data[0].length+message.data[1].length), \n                        this.state.animationSpeed, \n                        this.state.isThereStop, \n                        true\n                      )\n                    }\n\n                    animateTime(message, messageTwo)\n                })\n            }\n            animateTiming(message)\n        })\n\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.dijkstraWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.dijkstraWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animateDijkstra(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop\n              )\n\n            })\n        })\n      }\n    }\n\n    //animate aStar\n\n    animateaStar = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed,\n      isThereStop, \n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n        }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizeaStar = () => {\n\n      this.aStarWorker = new WebWorker(aStarWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n        this.aStarWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.aStarWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animateaStar(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animateaStar, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n        }\n        animateTiming(message)\n    })\n          return\n          \n      } else if(!this.state.isThereStop){\n\n          this.aStarWorker.postMessage([grid, startNode, finishNode, false])\n\n          this.aStarWorker.addEventListener('message', (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, false])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n                this.animateaStar(\n                  message.data, \n                  nodesInShortestPathOrder, \n                  message.data.length,\n                  this.state.animationSpeed,\n                  this.state.isThereStop,\n                  false\n                )\n\n              })\n          })\n      }\n    }\n\n    //animate breadth first search \n\n    animatebfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall,\n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n          \n          setTimeout(this.animateShortestPath, animationSpeed*animationStall, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          progress.width(`+=${integralVal}%`)\n        }, animationSpeed * i);\n      }\n    }\n\n    visualizbfs = () => {\n      \n      this.breadthFirstSearchWorker = new WebWorker(breadthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n                       \n            const animateTiming = async (message) => {\n\n              this.pathGrabWorker.postMessage([message.data, true])\n\n              this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                  const animateTime = (message, messageTwo) => {\n\n                    var nodesInShortestPathOrder;\n\n                    if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                    } else if(messageTwo.data[0][0] === false) {\n                      nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                    } else if(messageTwo.data[1][0] === false) {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                    } else {\n                      nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                    }\n\n                    this.animatebfs(\n                      message.data[0], \n                      nodesInShortestPathOrder, \n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      false\n                    )\n\n                    setTimeout(this.animatebfs, \n                      message.data[0].length * this.state.animationSpeed, \n                      message.data[1], \n                      nodesInShortestPathOrder,\n                      (message.data[0].length+message.data[1].length), \n                      this.state.animationSpeed, \n                      this.state.isThereStop,\n                      true\n                    )\n                  }\n\n                  animateTime(message, messageTwo)\n              })\n            }\n          animateTiming(message)\n      })\n      return\n\n      } else if(!this.state.isThereStop){\n\n        this.breadthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.breadthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatebfs(\n                message.data, \n                nodesInShortestPathOrder, \n                message.data.length, \n                this.state.animationSpeed, \n                false\n              )\n            })\n        })\n      }\n    }\n\n    // greedy best first search\n\n    animategbfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder,\n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizegbfs = () => {\n      \n      this.greedyBestFirstSearchWorker = new WebWorker(greedyBestFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n\n      if(this.state.isThereStop) {\n\n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animategbfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(this.animategbfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n      \n      } else if(!this.state.isThereStop) {\n        \n        this.greedyBestFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.greedyBestFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animategbfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed, \n                this.state.isThereStop,\n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // depth first search\n\n    animatedfs = (\n      visitedNodesInOrder, \n      nodesInShortestPathOrder, \n      animationStall, \n      animationSpeed, \n      isThereStop,\n      isSecondAnimation=false\n    ) => {\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        isThereStop,\n        isSecondAnimation,\n        animationSpeed,\n        visitedNodesInOrder.length\n      )\n\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n\n          if(isSecondAnimation && isThereStop) return\n\n          setTimeout(this.animateShortestPath, animationStall*animationSpeed, nodesInShortestPathOrder)\n\n          return;\n          }\n        setTimeout(() => {\n            const node = visitedNodesInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n            progress.width(`+=${integralVal}%`)\n          }, animationSpeed * i);\n      }\n    }\n\n    visualizedfs = () => {\n            \n      this.depthFirstSearchWorker = new WebWorker(depthFirstSearchWorker)\n\n      this.pathGrabWorker = new WebWorker(pathGrabWorker)\n\n      var grid = this.state.grid;\n      const START_NODE = this.state.startNode\n      const FINISH_NODE = this.state.finishNode\n      const STOP_NODE = this.state.prevStop\n      const startNode = grid[START_NODE[0]][START_NODE[1]];\n      const finishNode = grid[FINISH_NODE[0]][FINISH_NODE[1]];\n      const stopNode = this.state.isThereStop ? grid[STOP_NODE[0]][STOP_NODE[1]] : []\n      \n      if(this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n            \n          const animateTiming = async (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, true])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n                const animateTime = (message, messageTwo) => {\n\n                  var nodesInShortestPathOrder;\n\n                  if(messageTwo.data[0][0] === false && messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [startNode, stopNode, finishNode]\n                  } else if(messageTwo.data[0][0] === false) {\n                    nodesInShortestPathOrder = [startNode, ...messageTwo.data[1]]\n                  } else if(messageTwo.data[1][0] === false) {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], finishNode]\n                  } else {\n                    nodesInShortestPathOrder = [...messageTwo.data[0], ...messageTwo.data[1]]\n                  }\n\n                  this.animatedfs(\n                    message.data[0], \n                    nodesInShortestPathOrder, \n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop,\n                    false\n                  )\n\n                  setTimeout(\n                    this.animatedfs, \n                    message.data[0].length * this.state.animationSpeed, \n                    message.data[1], \n                    nodesInShortestPathOrder,\n                    (message.data[0].length+message.data[1].length), \n                    this.state.animationSpeed, \n                    this.state.isThereStop, \n                    true\n                  )\n                }\n\n                animateTime(message, messageTwo)\n            })\n          }\n          animateTiming(message)\n      })\n        return\n\n      } else if(!this.state.isThereStop){\n\n        this.depthFirstSearchWorker.postMessage([grid, startNode, finishNode, false])\n\n        this.depthFirstSearchWorker.addEventListener('message', (message) => {\n\n            this.pathGrabWorker.postMessage([message.data, false])\n\n            this.pathGrabWorker.addEventListener('message', (messageTwo) => {\n\n              var nodesInShortestPathOrder = messageTwo.data === false ? [startNode, finishNode] : messageTwo.data\n\n              this.animatedfs(\n                message.data, \n                nodesInShortestPathOrder,\n                message.data.length, \n                this.state.animationSpeed,\n                this.state.isThereStop, \n                false\n              )\n\n            })\n        })\n      }\n    }\n\n    // bidirectional greedy first search\n\n    animateBidirectionalAlgorithm = (\n      visitedNodesInOrderStart,\n      visitedNodesInOrderFinish,\n      nodesInShortestPathOrder,\n      isShortedPath,\n      animationSpeed,\n      animationStall,\n      isSecondAnimation=false\n    ) => {\n\n      this.setState({visualizingAlgorithm: true})\n\n      var animationColor\n\n      animationColor = isSecondAnimation ? animationColor = 'node-target-visited' : animationColor = 'node-visited'\n\n      //progress tracker\n      const progress = $(\"#progressBar\")\n      progress.replaceWith($(\"#progressBar\")).clone(true)\n\n      var integralVal = this.handleProgressSetup(\n        this.state.isThereStop,\n        false,\n        animationSpeed,\n        visitedNodesInOrderStart.length\n      )\n\n      let len = Math.max(\n        visitedNodesInOrderStart.length,\n        visitedNodesInOrderFinish.length\n      );\n\n      for (let i = 1; i <= len; i++) {\n        let nodeA = visitedNodesInOrderStart[i];\n        let nodeB = visitedNodesInOrderFinish[i];\n        if (i === visitedNodesInOrderStart.length) {\n\n          if(isSecondAnimation && this.state.isThereStop) return\n\n          setTimeout(() => {\n            if (isShortedPath) {\n              this.animateShortestPath(\n                nodesInShortestPathOrder\n              );\n            } else {\n              this.setState({ visualizingAlgorithm: false });\n            }\n          }, animationStall * animationSpeed);\n          return;\n        }\n        setTimeout(() => {\n          //visited nodes\n          if (nodeA !== undefined) {\n            document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          if (nodeB !== undefined) {\n            document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = `node ${animationColor} node-gap-vert node-gap-horiz`;\n          }\n          progress.width(`+=${integralVal*2}%`)\n\n        }, i * animationSpeed);\n      }\n    }\n\n    visualizeBidirectionalGreedySearch = () => {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n\n      this.bidirectionalGreedySearchWorker = new WebWorker(bidirectionalGreedySearchWorker)\n\n      const { grid } = this.state;\n      const _startNode = this.state.startNode\n      const _finishNode = this.state.finishNode\n      const _stopNode = this.state.prevStop\n      const startNode = grid[_startNode[0]][_startNode[1]];\n      const finishNode = grid[_finishNode[0]][_finishNode[1]];\n      const stopNode = this.state.isThereStop ? grid[_stopNode[0]][_stopNode[1]] : false\n\n      if(this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode, true])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0][0];\n            const visitedNodesInOrderStopFirst = message.data[0][1];\n            const isShortedPath = message.data[0][2];\n\n            const visitedNodesInOrderStopSecond = message.data[1][0]\n            const visitedNodesInOrderFinish = message.data[1][1]\n            const isShortedPathSecond = message.data[1][2]\n\n            if(visitedNodesInOrderStart[0] !== startNode) visitedNodesInOrderStart.unshift(startNode)\n\n            if(visitedNodesInOrderStopFirst[0] !== stopNode) visitedNodesInOrderStopFirst.unshift(stopNode)\n\n            if(visitedNodesInOrderFinish[0] !== finishNode) visitedNodesInOrderFinish.unshift(finishNode)\n\n            const animationStall = (visitedNodesInOrderStart.length+visitedNodesInOrderStopFirst.length+visitedNodesInOrderStopSecond.length+visitedNodesInOrderFinish.length)\n\n            const nodesInShortestPathOrderFirst = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderStopFirst[visitedNodesInOrderStopFirst.length - 1],\n              false\n            )\n\n            const nodesInShortestPathOrderSecond = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStopSecond[visitedNodesInOrderStopSecond.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1],\n              true\n            )\n\n            const nodesInShortestPathOrder = [...nodesInShortestPathOrderFirst, ...nodesInShortestPathOrderSecond]\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderStopFirst,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed,\n                animationStall,\n                false\n              );\n            }, this.state.animationSpeed);\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStopSecond,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPathSecond,\n                this.state.animationSpeed,\n                animationStall,\n                true\n              );\n            }, this.state.animationSpeed*((visitedNodesInOrderStart.length-1)+(visitedNodesInOrderStopFirst.length-1)))\n\n        })\n\n      } else if(!this.state.isThereStop) {\n\n        this.bidirectionalGreedySearchWorker.postMessage([grid, startNode, finishNode, stopNode])\n\n        this.bidirectionalGreedySearchWorker.addEventListener('message', (message) => {\n\n            const visitedNodesInOrderStart = message.data[0];\n            const visitedNodesInOrderFinish = message.data[1];\n            if(!visitedNodesInOrderFinish[0].isFinish) visitedNodesInOrderFinish.unshift(finishNode)\n  \n            const isShortedPath = message.data[2];\n            const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\n              visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n              visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n            )\n\n            setTimeout(() => {\n              this.animateBidirectionalAlgorithm(\n                visitedNodesInOrderStart,\n                visitedNodesInOrderFinish,\n                nodesInShortestPathOrder,\n                isShortedPath,\n                this.state.animationSpeed\n              );\n            }, this.state.animationSpeed);\n        })\n      }\n    }\n\n    //finish animations\n\n    animateShortestPath = (nodesInShortestPathOrder) => {\n\n      const startNode = this.state.grid[this.state.startNode[0]][this.state.startNode[1]]\n      const finishNode = this.state.grid[this.state.finishNode[0]][this.state.finishNode[1]]\n      const stopNode = this.state.isThereStop ? this.state.grid[this.state.prevStop[0]][this.state.prevStop[1]] : []\n      const stall = (nodesInShortestPathOrder.length*50)+2\n\n      setTimeout(() => {this.setState({visualizingAlgorithm: false})}, stall)\n\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n\n          var currObj = document.getElementById(`node-${node.row}-${node.col}`)\n\n          if(node.row === startNode.row && node.col === startNode.col) {\n            currObj.className = 'node node-shortest-path node-shortest-path-start node-no-gap-vert';\n          } else if(node.row === finishNode.row && node.col === finishNode.col){\n            currObj.className = 'node node-shortest-path node-shortest-path-finish';\n          } else if(this.state.isThereStop && (node.row === stopNode.row && node.col === stopNode.col)) {\n            currObj.className = 'node node-shortest-path node-shortest-path-stop';\n          } else if(document.getElementById(`node-${node.row}-${node.col}`).className.includes('node-shortest-path')) {\n            $(`#node-${node.row}-${node.col}`).replaceWith($(`#node-${node.row}-${node.col}`).clone(true))\n          } else {\n            currObj.className = 'node node-shortest-path';\n          }\n\n        }, 50 * i);\n      }\n    }\n\n    //generate mazes\n\n    animateMaze = (walls) => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {   \n          setTimeout(() => {\n            this.setState({ generatingMaze: false })\n          }, i * 10)      \n          return;\n        }\n        setTimeout(() => {\n\n          let wall = walls[i];\n          let node = this.state.grid[wall[0]][wall[1]];\n          node.isWall = true\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\"\n\n        }, i * 10);\n      }\n    };\n\n    getNewGridWithMaze = (walls) => {\n      let grid = this.state.grid\n      let newGrid = grid.slice();\n      for (let wall of walls) {\n        let node = grid[wall[0]][wall[1]];\n        let newNode = {\n          ...node,\n          isWall: true,\n        };\n        newGrid[wall[0]][wall[1]] = newNode;\n      }\n      this.setState({ grid: newGrid, generatingMaze: false })\n      return\n    };\n\n    generateRandomMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? randomMaze(grid, startNode, finishNode, true, stopNode) : randomMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateRecursiveDivisionMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? recursiveDivisionMaze(grid, startNode, finishNode, true, stopNode) : recursiveDivisionMaze(grid, startNode, finishNode, false, stopNode);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateVerticalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? verticalMaze(grid, startNode, finishNode, true, stopNode) : verticalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n  \n    generateHorizontalMaze() {\n      if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\n        return;\n      }\n      this.setState({ generatingMaze: true });\n      setTimeout(() => {\n        const { grid } = this.state;\n        const _startNode = this.state.startNode\n        const _finishNode = this.state.finishNode\n        const startNode = grid[_startNode[0]][_startNode[1]]\n        const finishNode = grid[_finishNode[0]][_finishNode[1]]\n        const stopNode = this.state.isThereStop ? grid[this.state.prevStop[0]][this.state.prevStop[1]] : false\n        const walls = this.state.isThereStop ? horizontalMaze(grid, startNode, finishNode, true, stopNode) : horizontalMaze(grid, startNode, finishNode, false);\n        this.animateMaze(walls);\n      }, 10);\n    }\n\n    render(){ \n\n        return(\n            <div className=\"main-container\">\n                <div className='grid-info-container'>\n                  <div className='grid-text-container'>\n                    <p className='grid-text'>Current-algorithim: <span className='grid-alg-text'>{this.state.currAlgObj.name}</span></p>\n                  </div>\n                  <div className=\"progress-bar-container\">\n                      <div className='progress progress-no-stop' id='progressBar'/>\n                  </div>\n                </div>\n                <NavTop state={this.state} clearGrid={this.clearGrid} resetGrid={this.resetGrid}/>\n                <div className=\"visualizer-container\">\n                    <Visualizer \n                        state={this.state} \n                        handleMouseDown={this.handleMouseDown} \n                        handleMouseEnter={this.handleMouseEnter} \n                        handleMouseUp={this.handleMouseUp}\n                    />\n                </div>\n                <Navbar state={this.state} toggleNav={this.handleNav} handleSpeedChange={this.handleSpeedChange} handleMazeTabs={this.handleMazeTabs} genMaze={this.generateMaze} play={this.playAnimation} handleTabs={this.handleTabs} handleItemChange={this.handleItemDescChange} visualizeDijkstra={this.visualizeDijkstra}/>\n            </div>\n        )\n    }\n}\n\nconst renderGrid = (state, _rowNum, _colNum) => {\n    const grid = [];\n    var rowNum = _rowNum\n    var colNum = _colNum\n    for (let row = 0; row < rowNum; row++) {\n      const currentRow = []\n      for (let col = 0; col < colNum; col++) {\n        var node = createNode(col, row, state)\n        node.className = 'node'\n        currentRow.push(node)\n      }\n      grid.push(currentRow)\n    }\n    return grid;\n}\n\n\n\nconst createNode = (col, row, state) => {\n    const startNode = state.startNode\n    const finishNode = state.finishNode\n    const stopNode = state.prevStop\n    return {\n      col,\n      row,\n      isStart: row === startNode[0] && col === startNode[1],\n      isFinish: row === finishNode[0] && col === finishNode[1],\n      isStop: state.isThereStop ? row === stopNode[0] && col === stopNode[1] : false,\n      isWall: false,\n      previousNode: null,\n      previousNodeSecond: null,\n      isVisited: false,\n      isVisitedSecond: false,\n      distance: Infinity,\n      distanceSecond: Infinity\n    };\n  };\n\n  const getNewGridWithStart = (grid, row, col, prevStart) => {\n\n    const newGrid = grid.slice();\n    const newStart = newGrid[row][col]\n    const oldStart = newGrid[prevStart[0]][prevStart[1]]\n    const oldNode = {\n      ...oldStart,\n      isStart: !oldStart.isStart\n    }\n    const newNode = {\n      ...newStart,\n      isStart: !newStart.isStart,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStart[0]][prevStart[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithFinish = (grid, row, col, prevFinish) => {\n\n    const newGrid = grid.slice();\n    const newFinish = newGrid[row][col];\n    const oldFinish = newGrid[prevFinish[0]][prevFinish[1]]\n    const oldNode = {\n      ...oldFinish,\n      isFinish: !oldFinish.isFinish\n    }\n    const newNode = {\n      ...newFinish,\n      isFinish: !newFinish.isFinish,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevFinish[0]][prevFinish[1]] = oldNode\n    return newGrid;\n  }\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice()\n    const node = newGrid[row][col]\n    var newNode = {...node}\n    newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid\n  };\n\n  const getNewGridWithStopToggled = (grid, row, col, prevStop) => {\n\n    const newGrid = grid.slice()\n    const newStop = newGrid[row][col]\n    if(prevStop.length === 0){\n      const newNode = {\n        ...newStop,\n        isStop: !newStop.isStop,\n        isWall: false\n      };\n      newGrid[row][col] = newNode\n      return newGrid\n    }\n    const oldStop = newGrid[prevStop[0]][prevStop[1]]\n    const oldNode = {\n      ...oldStop,\n      isStop: !oldStop.isStop\n    }\n    const newNode = {\n      ...newStop,\n      isStop: !newStop.isStop,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    newGrid[prevStop[0]][prevStop[1]] = oldNode\n    return newGrid;\n  };\n\n  const getGridWithoutPath = (grid, minorReset=false) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n      for (let node of row) {\n        var wall = false\n        var stop = false\n        if(minorReset){\n          if(grid[node.row][node.col].isWall) wall = true\n\n          if(grid[node.row][node.col].isStop) stop = true\n        }\n        let newNode = {\n          ...node,\n          distance: Infinity,\n          distanceSecond: Infinity,\n          totalDistance: Infinity,\n          isVisited: false,\n          isVisitedSecond: false,\n          isShortest: false,\n          previousNode: null,\n          isWall: wall,\n          isWeight: false,\n          isStop: stop\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    return newGrid;\n  };\n\n  function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB,\n    second=false\n  ) {\n    let nodesInShortestPathOrder = []\n    let currentNode = nodeB\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    currentNode = nodeA\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode)\n      if(second){\n        currentNode = currentNode.previousNodeSecond\n      } else {\n        currentNode = currentNode.previousNode\n      }\n    }\n    return nodesInShortestPathOrder\n  }","import MainContainer from \"./components/MainContainer.jsx\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MainContainer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}