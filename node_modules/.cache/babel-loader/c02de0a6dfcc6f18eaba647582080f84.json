{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode) {\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      isStop = stopNode === false ? false : true;\n    }\n\n    function isNeighbour(closestNodeStart, closestNodeFinish) {\n      let rowStart = closestNodeStart.row;\n      let colStart = closestNodeStart.col;\n      let rowFinish = closestNodeFinish.row;\n      let colFinish = closestNodeFinish.col;\n      if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n      if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n      return false;\n    }\n\n    function getNeighbours(node, grid) {\n      let neighbours = [];\n      let {\n        row,\n        col\n      } = node;\n      if (row !== 0) neighbours.push(grid[row - 1][col]);\n      if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n      if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n      if (col !== 0) neighbours.push(grid[row][col - 1]);\n      return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n    }\n\n    function manhattenDistance(nodeA, nodeB) {\n      let x = Math.abs(nodeA.row - nodeB.row);\n      let y = Math.abs(nodeA.col - nodeB.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2]; //const stopNode = message.data[3]\n\n    const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode);\n    postMessage(visitedNodesInorder);\n  });\n});\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","bidirectionalGreedySearch","grid","startNode","finishNode","stopNode","isStop","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","row","colStart","col","rowFinish","colFinish","getNeighbours","node","neighbours","push","length","filter","neighbour","isWall","isVisited","manhattenDistance","nodeA","nodeB","x","Math","abs","y","neighbourNotInUnvisitedNodes","unvisitedNodes","data","visitedNodesInorder","postMessage","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode","previousNode","unshift"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n            isStop = stopNode === false ? false : true\n            \n            \n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            return neighbours.filter(\n            (neighbour) => !neighbour.isWall && !neighbour.isVisited\n            );\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n            if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false;\n            }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        //const stopNode = message.data[3]\n        const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}