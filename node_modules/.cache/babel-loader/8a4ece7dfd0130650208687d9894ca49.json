{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode) {\n      let isStop = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      if (isStop) {\n        let unvisitedNodesStart = [];\n        let visitedNodesInOrderStart = [];\n        let unvisitedNodesStopFirst = [];\n        let visitedNodesInOrderStopFirst = [];\n        let unvisitedNodesStopSecond = [];\n        let visitedNodesInOrderStopSecond = [];\n        let unvisitedNodesFinish = [];\n        let visitedNodesInOrderFinish = [];\n        startNode.distance = 0;\n        stopNode.distance = 0;\n        stopNode.distanceSecond = 0;\n        finishNode.distanceSecond = 0;\n        unvisitedNodesStart.push(startNode);\n        unvisitedNodesStopFirst.push(stopNode);\n        unvisitedNodesStopSecond.push(stopNode);\n        unvisitedNodesFinish.push(finishNode);\n\n        while (unvisitedNodesStart.length !== 0 && unvisitedNodesStopFirst.length !== 0) {\n          unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n          unvisitedNodesStopFirst.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNodeStart = unvisitedNodesStart.shift();\n          let closestNodeStop = unvisitedNodesStopFirst.shift();\n          closestNodeStart.isVisited = true;\n          closestNodeStop.isVisited = true;\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderStopFirst.push(closestNodeStop);\n\n          if (isNeighbour(closestNodeStart, closestNodeStop)) {\n            return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n          } //start side search\n\n\n          let neighbours = getNeighbours(closestNodeStart, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n              visitedNodesInOrderStart.push(closestNodeStart);\n              visitedNodesInOrderStopFirst.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n            }\n\n            let distance = closestNodeStart.distance + 1;\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              unvisitedNodesStart.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNodeStart;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNodeStart;\n            }\n          } //stop side search\n\n\n          neighbours = getNeighbours(closestNodeStop, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              visitedNodesInOrderStopFirst.push(closestNodeStop);\n              visitedNodesInOrderStart.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n            }\n\n            let distance = closestNodeStop.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n              unvisitedNodesStopFirst.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeStop;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeStop;\n            }\n          }\n        }\n\n        while (unvisitedNodesStopSecond.length !== 0 && unvisitedNodesFinish.length !== 0) {\n          unvisitedNodesStopSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n          unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n          let closestNodeStopSecond = unvisitedNodesStopSecond.shift();\n          let closestNodeFinish = unvisitedNodesFinish.shift();\n          closestNodeStopSecond.isVisitedSecond = true;\n          closestNodeFinish.isVisitedSecond = true;\n          visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n          visitedNodesInOrderFinish.push(closestNodeFinish);\n\n          if (isNeighbour(closestNodeStopSecond, closestNodeFinish)) {\n            return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '1'];\n          }\n\n          let neighbours = getNeighbours(closestNodeStopSecond, grid, true);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n              visitedNodesInOrderFinish.push(neighbour);\n              console.log(visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, neighbour);\n              return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '2'];\n            }\n\n            let distance = closestNodeStopSecond.distanceSecond + 1;\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n              unvisitedNodesStopSecond.unshift(neighbour);\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNodeSecond = closestNodeStopSecond;\n            } else if (distance < neighbour.distanceSecond) {\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNodeSecond = closestNodeStopSecond;\n            }\n          }\n\n          neighbours = getNeighbours(closestNodeFinish, grid, true);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n              visitedNodesInOrderFinish.push(closestNodeFinish);\n              visitedNodesInOrderStopSecond.push(neighbour);\n              return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true];\n            }\n\n            let distance = closestNodeFinish.distanceSecond + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              unvisitedNodesFinish.unshift(neighbour);\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNodeSecond = closestNodeFinish;\n            } else if (distance < neighbour.distanceSecond) {\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNodeSecond = closestNodeFinish;\n            }\n          }\n        }\n\n        return [visitedNodesInOrderStart, visitedNodesInOrderStart, false];\n      } else {\n        let unvisitedNodesStart = [];\n        let visitedNodesInOrderStart = [];\n        let unvisitedNodesFinish = [];\n        let visitedNodesInOrderFinish = [];\n        startNode.distance = 0;\n        finishNode.distance = 0;\n        unvisitedNodesStart.push(startNode);\n        unvisitedNodesFinish.push(finishNode);\n\n        while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n          unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n          unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNodeStart = unvisitedNodesStart.shift();\n          let closestNodeFinish = unvisitedNodesFinish.shift();\n          closestNodeStart.isVisited = true;\n          closestNodeFinish.isVisited = true;\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderFinish.push(closestNodeFinish);\n\n          if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n          } //Start side search\n\n\n          let neighbours = getNeighbours(closestNodeStart, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              visitedNodesInOrderStart.push(closestNodeStart);\n              visitedNodesInOrderFinish.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n            }\n\n            let distance = closestNodeStart.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              unvisitedNodesStart.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNodeStart;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNodeStart;\n            }\n          } //Finish side search\n\n\n          neighbours = getNeighbours(closestNodeFinish, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              visitedNodesInOrderFinish.push(closestNodeFinish);\n              visitedNodesInOrderStart.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n            }\n\n            let distance = closestNodeFinish.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              unvisitedNodesFinish.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeFinish;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeFinish;\n            }\n          }\n        }\n\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n      }\n    }\n\n    function bidirectionalGreedySearchSecond() {\n      while (unvisitedNodesStopSecond.length !== 0 && unvisitedNodesFinish.length !== 0) {\n        unvisitedNodesStopSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n        unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n        let closestNodeStopSecond = unvisitedNodesStopSecond.shift();\n        let closestNodeFinish = unvisitedNodesFinish.shift();\n        closestNodeStopSecond.isVisitedSecond = true;\n        closestNodeFinish.isVisitedSecond = true;\n        visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n        visitedNodesInOrderFinish.push(closestNodeFinish);\n\n        if (isNeighbour(closestNodeStopSecond, closestNodeFinish)) {\n          return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '1'];\n        }\n\n        let neighbours = getNeighbours(closestNodeStopSecond, grid, true);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n            visitedNodesInOrderFinish.push(neighbour);\n            console.log(visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, neighbour);\n            return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '2'];\n          }\n\n          let distance = closestNodeStopSecond.distanceSecond + 1;\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n            unvisitedNodesStopSecond.unshift(neighbour);\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNodeSecond = closestNodeStopSecond;\n          } else if (distance < neighbour.distanceSecond) {\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNodeSecond = closestNodeStopSecond;\n          }\n        }\n\n        neighbours = getNeighbours(closestNodeFinish, grid, true);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n            visitedNodesInOrderFinish.push(closestNodeFinish);\n            visitedNodesInOrderStopSecond.push(neighbour);\n            return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true];\n          }\n\n          let distance = closestNodeFinish.distanceSecond + 1; //f(n) = h(n)\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            unvisitedNodesFinish.unshift(neighbour);\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n            neighbour.previousNodeSecond = closestNodeFinish;\n          } else if (distance < neighbour.distanceSecond) {\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n            neighbour.previousNodeSecond = closestNodeFinish;\n          }\n        }\n      }\n    }\n\n    function isNeighbour(closestNodeStart, closestNodeFinish) {\n      let rowStart = closestNodeStart.row;\n      let colStart = closestNodeStart.col;\n      let rowFinish = closestNodeFinish.row;\n      let colFinish = closestNodeFinish.col;\n      if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n      if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n      return false;\n    }\n\n    function getNeighbours(node, grid) {\n      let isStop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let neighbours = [];\n      let {\n        row,\n        col\n      } = node;\n      if (row !== 0) neighbours.push(grid[row - 1][col]);\n      if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n      if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n      if (col !== 0) neighbours.push(grid[row][col - 1]);\n\n      if (isStop) {\n        console.log('true');\n        return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisitedSecond);\n      } else {\n        console.log('else');\n        return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n      }\n    }\n\n    function manhattenDistance(nodeA, nodeB) {\n      let x = Math.abs(nodeA.row - nodeB.row);\n      let y = Math.abs(nodeA.col - nodeB.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const isStop = message.data[4];\n    const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode, stopNode, isStop);\n    postMessage(visitedNodesInorder);\n  });\n});\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","bidirectionalGreedySearch","grid","startNode","finishNode","stopNode","isStop","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesStopFirst","visitedNodesInOrderStopFirst","unvisitedNodesStopSecond","visitedNodesInOrderStopSecond","unvisitedNodesFinish","visitedNodesInOrderFinish","distance","distanceSecond","push","length","sort","a","b","totalDistance","closestNodeStart","shift","closestNodeStop","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","totalDistanceSecond","closestNodeStopSecond","closestNodeFinish","isVisitedSecond","console","log","previousNodeSecond","bidirectionalGreedySearchSecond","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","data","visitedNodesInorder","postMessage","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode, isStop=false) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n\n            if(isStop) {\n\n                let unvisitedNodesStart = [];\n                let visitedNodesInOrderStart = [];\n                let unvisitedNodesStopFirst = [];\n                let visitedNodesInOrderStopFirst = [];\n                let unvisitedNodesStopSecond = [];\n                let visitedNodesInOrderStopSecond = [];\n                let unvisitedNodesFinish = [];\n                let visitedNodesInOrderFinish = [];\n                startNode.distance = 0\n                stopNode.distance = 0\n                stopNode.distanceSecond = 0\n                finishNode.distanceSecond = 0\n                unvisitedNodesStart.push(startNode)\n                unvisitedNodesStopFirst.push(stopNode)\n                unvisitedNodesStopSecond.push(stopNode)\n                unvisitedNodesFinish.push(finishNode)\n\n                while (\n                    unvisitedNodesStart.length !== 0 &&\n                    unvisitedNodesStopFirst.length !== 0\n                ) {\n                    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                    unvisitedNodesStopFirst.sort((a, b) => a.totalDistance - b.totalDistance)\n                    let closestNodeStart = unvisitedNodesStart.shift()\n                    let closestNodeStop = unvisitedNodesStopFirst.shift()\n\n                    closestNodeStart.isVisited = true\n                    closestNodeStop.isVisited = true\n                    visitedNodesInOrderStart.push(closestNodeStart)\n                    visitedNodesInOrderStopFirst.push(closestNodeStop)\n                    if (isNeighbour(closestNodeStart, closestNodeStop)) {\n                        return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n                    }\n\n                    //start side search\n                    let neighbours = getNeighbours(closestNodeStart, grid)\n                    for(let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n                            visitedNodesInOrderStart.push(closestNodeStart);\n                            visitedNodesInOrderStopFirst.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n                        }\n                        let distance = closestNodeStart.distance + 1\n\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            unvisitedNodesStart.unshift(neighbour)\n                            neighbour.distance = distance\n                            neighbour.totalDistance = manhattenDistance(neighbour, stopNode)\n                            neighbour.previousNode = closestNodeStart\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                            neighbour.previousNode = closestNodeStart;\n                        }\n                    }\n\n                    //stop side search\n                    neighbours = getNeighbours(closestNodeStop, grid);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            visitedNodesInOrderStopFirst.push(closestNodeStop);\n                            visitedNodesInOrderStart.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n                        }\n                        let distance = closestNodeStop.distance + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n                            unvisitedNodesStopFirst.unshift(neighbour);\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                            neighbour.previousNode = closestNodeStop;\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                            neighbour.previousNode = closestNodeStop;\n                        }\n                    }\n                }\n\n                while (\n                    unvisitedNodesStopSecond.length !== 0 &&\n                    unvisitedNodesFinish.length !== 0\n                ) {\n                    unvisitedNodesStopSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                    unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                    let closestNodeStopSecond = unvisitedNodesStopSecond.shift()\n                    let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                    closestNodeStopSecond.isVisitedSecond = true\n                    closestNodeFinish.isVisitedSecond = true\n                    visitedNodesInOrderStopSecond.push(closestNodeStopSecond)\n                    visitedNodesInOrderFinish.push(closestNodeFinish)\n                    if (isNeighbour(closestNodeStopSecond, closestNodeFinish)) {\n                        return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '1']\n                    }\n\n                    let neighbours = getNeighbours(closestNodeStopSecond, grid, true)\n                    for(let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n                            visitedNodesInOrderFinish.push(neighbour);\n                            console.log(visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, neighbour)\n                            return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '2']\n                        }\n                        let distance = closestNodeStopSecond.distanceSecond + 1\n                        \n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n                            unvisitedNodesStopSecond.unshift(neighbour)\n                            neighbour.distanceSecond = distance\n                            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                            neighbour.previousNodeSecond = closestNodeStopSecond\n                        } else if (distance < neighbour.distanceSecond) {\n                            neighbour.distanceSecond = distance;\n                            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                            neighbour.previousNodeSecond = closestNodeStopSecond;\n                        }\n                    }\n\n                    neighbours = getNeighbours(closestNodeFinish, grid, true);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n                            visitedNodesInOrderFinish.push(closestNodeFinish);\n                            visitedNodesInOrderStopSecond.push(neighbour);\n                            return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true];\n                        }\n                        let distance = closestNodeFinish.distanceSecond + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            unvisitedNodesFinish.unshift(neighbour);\n                            neighbour.distanceSecond = distance;\n                            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                            neighbour.previousNodeSecond = closestNodeFinish;\n                        } else if (distance < neighbour.distanceSecond) {\n                            neighbour.distanceSecond = distance;\n                            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                            neighbour.previousNodeSecond = closestNodeFinish;\n                        }\n                    }\n                }\n                return [visitedNodesInOrderStart, visitedNodesInOrderStart, false]\n\n            } else {\n\n                let unvisitedNodesStart = []\n                let visitedNodesInOrderStart = []\n                let unvisitedNodesFinish = []\n                let visitedNodesInOrderFinish = []\n                startNode.distance = 0\n                finishNode.distance = 0\n                unvisitedNodesStart.push(startNode)\n                unvisitedNodesFinish.push(finishNode)\n            \n                while (\n                    unvisitedNodesStart.length !== 0 &&\n                    unvisitedNodesFinish.length !== 0\n                ) {\n                    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                    let closestNodeStart = unvisitedNodesStart.shift()\n                    let closestNodeFinish = unvisitedNodesFinish.shift()\n            \n                    closestNodeStart.isVisited = true;\n                    closestNodeFinish.isVisited = true;\n                    visitedNodesInOrderStart.push(closestNodeStart);\n                    visitedNodesInOrderFinish.push(closestNodeFinish);\n                    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                \n                    //Start side search\n                    let neighbours = getNeighbours(closestNodeStart, grid);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            visitedNodesInOrderStart.push(closestNodeStart);\n                            visitedNodesInOrderFinish.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                        }\n                        let distance = closestNodeStart.distance + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            unvisitedNodesStart.unshift(neighbour);\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                            neighbour.previousNode = closestNodeStart;\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                            neighbour.previousNode = closestNodeStart;\n                        }\n                    }\n                \n                    //Finish side search\n                    neighbours = getNeighbours(closestNodeFinish, grid);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            visitedNodesInOrderFinish.push(closestNodeFinish);\n                            visitedNodesInOrderStart.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                        }\n                        let distance = closestNodeFinish.distance + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            unvisitedNodesFinish.unshift(neighbour);\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                            neighbour.previousNode = closestNodeFinish;\n                        }\n                    }\n                }\n                return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n            }\n            \n            \n        }\n\n        function bidirectionalGreedySearchSecond() {\n\n            while (\n                unvisitedNodesStopSecond.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStopSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStopSecond = unvisitedNodesStopSecond.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStopSecond.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStopSecond.push(closestNodeStopSecond)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStopSecond, closestNodeFinish)) {\n                    return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStopSecond, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStopSecond.push(closestNodeStopSecond);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        console.log(visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, neighbour)\n                        return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true, '2']\n                    }\n                    let distance = closestNodeStopSecond.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n                        unvisitedNodesStopSecond.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStopSecond\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStopSecond;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopSecond)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStopSecond.push(neighbour);\n                        return [visitedNodesInOrderStopSecond, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                console.log('true')\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                console.log('else')\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode, stopNode, isStop)\n\n        postMessage(visitedNodesInorder);\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}