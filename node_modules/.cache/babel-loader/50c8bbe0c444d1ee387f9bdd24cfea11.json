{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self=this;export default(function(){// eslint-disable-line no-restricted-globals\nself.addEventListener(\"message\",function(message){if(!message)return;function depthFirstSearch(grid,startNode,finishNode){var stopNode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var isStop;if(stopNode===false){isStop=false;}else{isStop=true;}if(!isStop){var _visitedNodesInOrder=[];// queue to keep track of the visited nodes\nvar queue=[];queue.push(startNode);while(queue.length){var currNode=queue.pop();// if the finsih node is reached then we return the visitedNodes array\nif(currNode===finishNode){_visitedNodesInOrder.push(currNode);return _visitedNodesInOrder;}// we skip the nodes which are walls, start node or finish node\nif(!currNode.isWall&&(currNode.isStart||!currNode.isVisited)){currNode.isVisited=true;_visitedNodesInOrder.push(currNode);var row=currNode.row,col=currNode.col;updateUnvisitedNeighbours(row,col,queue,grid,currNode,false);}}return _visitedNodesInOrder;}else if(isStop){var firstSearch=[];var secondSearch=[];var _queue=[];var queueSecond=[];_queue.push(startNode);queueSecond.push(stopNode);while(_queue.length){var _currNode=_queue.pop();// if the finsih node is reached then we return the visitedNodes array\nif(_currNode===stopNode){firstSearch.push(_currNode);break;}// we skip the nodes which are walls, start node or finish node\nif(!_currNode.isWall&&(_currNode.isStart||!_currNode.isVisited)){_currNode.isVisited=true;firstSearch.push(_currNode);var _row=_currNode.row,_col=_currNode.col;updateUnvisitedNeighbours(_row,_col,_queue,grid,_currNode,false);}}while(queueSecond.length){var _currNode2=queueSecond.pop();// if the finish node is reached then we return the visitedNodes array\nif(_currNode2===finishNode){secondSearch.push(_currNode2);break;}// we skip the nodes which are walls, start node or finish node\nif(!_currNode2.isWall&&(_currNode2.isStart||!_currNode2.isVisitedSecond)){_currNode2.isVisitedSecond=true;secondSearch.push(_currNode2);var _row2=_currNode2.row,_col2=_currNode2.col;updateUnvisitedNeighbours(_row2,_col2,queueSecond,grid,_currNode2,true);}}return[firstSearch,secondSearch];}}function updateUnvisitedNeighbours(row,col,queue,grid,currNode,isStop){var next;if(isStop){if(row>0){next=grid[row-1][col];if(!next.isVisitedSecond){next.previousNodeSecond=currNode;queue.push(next);}}if(row<grid.length-1){next=grid[row+1][col];if(!next.isVisitedSecond){next.previousNodeSecond=currNode;queue.push(next);}}if(col<grid[0].length-1){next=grid[row][col+1];if(!next.isVisitedSecond){next.previousNodeSecond=currNode;queue.push(next);}}if(col>0){next=grid[row][col-1];if(!next.isVisitedSecond){next.previousNodeSecond=currNode;queue.push(next);}}return;}else if(!isStop){if(row>0){next=grid[row-1][col];if(!next.isVisited){next.previousNode=currNode;queue.push(next);}}if(row<grid.length-1){next=grid[row+1][col];if(!next.isVisited){next.previousNode=currNode;queue.push(next);}}if(col<grid[0].length-1){next=grid[row][col+1];if(!next.isVisited){next.previousNode=currNode;queue.push(next);}}if(col>0){next=grid[row][col-1];if(!next.isVisited){next.previousNode=currNode;queue.push(next);}}return;}}var grid=message.data[0];var startNode=message.data[1];var finishNode=message.data[2];var stopNode=message.data[3];var visitedNodesInOrder=depthFirstSearch(grid,startNode,finishNode,stopNode);postMessage(visitedNodesInOrder);});});","map":{"version":3,"names":["self","addEventListener","message","depthFirstSearch","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","queue","push","length","currNode","pop","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","firstSearch","secondSearch","queueSecond","isVisitedSecond","next","previousNodeSecond","previousNode","data","postMessage"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}