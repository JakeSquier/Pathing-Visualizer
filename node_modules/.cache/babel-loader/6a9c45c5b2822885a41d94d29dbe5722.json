{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bfs(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var isStop;\n\n      if (stopNode !== false) {\n        isStop = true;\n      } else {\n        isStop = false;\n      }\n\n      let visitedNodesInOrder = [];\n\n      if (isStop) {}\n    } // updates the neighbours,\n    // in correspondance to the algorithm \n\n\n    function updateUnvisitedNeighbours(row, col, queue, grid, currNode) {\n      let isStop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n      if (isStop) {\n        let next;\n\n        if (row > 0) {\n          next = grid[row - 1][col];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNodeSecond = currNode;\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNodeSecond = currNode;\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNodeSecond = currNode;\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNodeSecond = currNode;\n          }\n        }\n      } else if (!isStop) {\n        let next;\n\n        if (row > 0) {\n          next = grid[row - 1][col];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n      }\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode);\n    postMessage(visitedNodesInOrder);\n  });\n});","map":{"version":3,"names":["self","addEventListener","message","bfs","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","updateUnvisitedNeighbours","row","col","queue","currNode","next","isVisitedSecond","push","previousNodeSecond","length","isVisited","previousNode","data","postMessage"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js"],"sourcesContent":["\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode!==false){\n                isStop = true\n            } else {\n                isStop = false\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                \n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}