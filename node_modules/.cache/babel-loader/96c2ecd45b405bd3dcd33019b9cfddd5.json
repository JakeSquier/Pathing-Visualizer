{"ast":null,"code":"export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodesStart = [];\n  let visitedNodesInOrderStart = [];\n  let unvisitedNodesFinish = [];\n  let visitedNodesInOrderFinish = [];\n  startNode.distance = 0;\n  finishNode.distance = 0;\n  unvisitedNodesStart.push(startNode);\n  unvisitedNodesFinish.push(finishNode);\n\n  while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNodeStart = unvisitedNodesStart.shift();\n    let closestNodeFinish = unvisitedNodesFinish.shift();\n    closestNodeStart.isVisited = true;\n    closestNodeFinish.isVisited = true;\n    visitedNodesInOrderStart.push(closestNodeStart);\n    visitedNodesInOrderFinish.push(closestNodeFinish);\n\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n    } //Start side search\n\n\n    let neighbours = getNeighbours(closestNodeStart, grid);\n\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderFinish.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n\n      let distance = closestNodeStart.distance + 1; //f(n) = h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        unvisitedNodesStart.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      }\n    } //Finish side search\n\n\n    neighbours = getNeighbours(closestNodeFinish, grid);\n\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        visitedNodesInOrderStart.push(closestNodeFinish);\n        visitedNodesInOrderStart.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n\n      let distance = closestNodeFinish.distance + 1; //f(n) = h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        unvisitedNodesFinish.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      }\n    }\n  }\n\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n}\n\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\n  let rowStart = closestNodeStart.row;\n  let colStart = closestNodeStart.col;\n  let rowFinish = closestNodeFinish.row;\n  let colFinish = closestNodeFinish.col;\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n  return false;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\n\nfunction manhattenDistance(nodeA, nodeB) {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["bidirectionalGreedySearch","grid","startNode","finishNode","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","distance","push","length","sort","a","b","totalDistance","closestNodeStart","shift","closestNodeFinish","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/algorithims/bidirectionalGreedySearch.js"],"sourcesContent":["export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodesStart = [];\n    let visitedNodesInOrderStart = [];\n    let unvisitedNodesFinish = [];\n    let visitedNodesInOrderFinish = [];\n    startNode.distance = 0;\n    finishNode.distance = 0;\n    unvisitedNodesStart.push(startNode);\n    unvisitedNodesFinish.push(finishNode);\n  \n    while (\n      unvisitedNodesStart.length !== 0 &&\n      unvisitedNodesFinish.length !== 0\n    ) {\n      unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n      unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNodeStart = unvisitedNodesStart.shift();\n      let closestNodeFinish = unvisitedNodesFinish.shift();\n  \n      closestNodeStart.isVisited = true;\n      closestNodeFinish.isVisited = true;\n      visitedNodesInOrderStart.push(closestNodeStart);\n      visitedNodesInOrderFinish.push(closestNodeFinish);\n      if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n  \n      //Start side search\n      let neighbours = getNeighbours(closestNodeStart, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderFinish.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeStart.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          unvisitedNodesStart.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        }\n      }\n  \n      //Finish side search\n      neighbours = getNeighbours(closestNodeFinish, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          visitedNodesInOrderStart.push(closestNodeFinish);\n          visitedNodesInOrderStart.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeFinish.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          unvisitedNodesFinish.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        }\n      }\n    }\n    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n  }\n  \n  function isNeighbour(closestNodeStart, closestNodeFinish) {\n    let rowStart = closestNodeStart.row;\n    let colStart = closestNodeStart.col;\n    let rowFinish = closestNodeFinish.row;\n    let colFinish = closestNodeFinish.col;\n    if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n    if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n    return false;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(nodeA, nodeB) {\n    let x = Math.abs(nodeA.row - nodeB.row);\n    let y = Math.abs(nodeA.col - nodeB.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB,\n    \n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }"],"mappings":"AAAA,OAAO,SAASA,yBAAT,CAAmCC,IAAnC,EAAyCC,SAAzC,EAAoDC,UAApD,EAAgE;EACnE,IAAI,CAACD,SAAD,IAAc,CAACC,UAAf,IAA6BD,SAAS,KAAKC,UAA/C,EAA2D;IACzD,OAAO,KAAP;EACD;;EACD,IAAIC,mBAAmB,GAAG,EAA1B;EACA,IAAIC,wBAAwB,GAAG,EAA/B;EACA,IAAIC,oBAAoB,GAAG,EAA3B;EACA,IAAIC,yBAAyB,GAAG,EAAhC;EACAL,SAAS,CAACM,QAAV,GAAqB,CAArB;EACAL,UAAU,CAACK,QAAX,GAAsB,CAAtB;EACAJ,mBAAmB,CAACK,IAApB,CAAyBP,SAAzB;EACAI,oBAAoB,CAACG,IAArB,CAA0BN,UAA1B;;EAEA,OACEC,mBAAmB,CAACM,MAApB,KAA+B,CAA/B,IACAJ,oBAAoB,CAACI,MAArB,KAAgC,CAFlC,EAGE;IACAN,mBAAmB,CAACO,IAApB,CAAyB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,aAAF,GAAkBD,CAAC,CAACC,aAAvD;IACAR,oBAAoB,CAACK,IAArB,CAA0B,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,aAAF,GAAkBD,CAAC,CAACC,aAAxD;IACA,IAAIC,gBAAgB,GAAGX,mBAAmB,CAACY,KAApB,EAAvB;IACA,IAAIC,iBAAiB,GAAGX,oBAAoB,CAACU,KAArB,EAAxB;IAEAD,gBAAgB,CAACG,SAAjB,GAA6B,IAA7B;IACAD,iBAAiB,CAACC,SAAlB,GAA8B,IAA9B;IACAb,wBAAwB,CAACI,IAAzB,CAA8BM,gBAA9B;IACAR,yBAAyB,CAACE,IAA1B,CAA+BQ,iBAA/B;;IACA,IAAIE,WAAW,CAACJ,gBAAD,EAAmBE,iBAAnB,CAAf,EAAsD;MACpD,OAAO,CAACZ,wBAAD,EAA2BE,yBAA3B,EAAsD,IAAtD,CAAP;IACD,CAZD,CAcA;;;IACA,IAAIa,UAAU,GAAGC,aAAa,CAACN,gBAAD,EAAmBd,IAAnB,CAA9B;;IACA,KAAK,IAAIqB,SAAT,IAAsBF,UAAtB,EAAkC;MAChC,IAAI,CAACG,4BAA4B,CAACD,SAAD,EAAYhB,oBAAZ,CAAjC,EAAoE;QAClED,wBAAwB,CAACI,IAAzB,CAA8BM,gBAA9B;QACAR,yBAAyB,CAACE,IAA1B,CAA+Ba,SAA/B;QACA,OAAO,CAACjB,wBAAD,EAA2BE,yBAA3B,EAAsD,IAAtD,CAAP;MACD;;MACD,IAAIC,QAAQ,GAAGO,gBAAgB,CAACP,QAAjB,GAA4B,CAA3C,CANgC,CAOhC;;MACA,IAAIe,4BAA4B,CAACD,SAAD,EAAYlB,mBAAZ,CAAhC,EAAkE;QAChEA,mBAAmB,CAACoB,OAApB,CAA4BF,SAA5B;QACAA,SAAS,CAACd,QAAV,GAAqBA,QAArB;QACAc,SAAS,CAACR,aAAV,GAA0BW,iBAAiB,CAACH,SAAD,EAAYnB,UAAZ,CAA3C;QACAmB,SAAS,CAACI,YAAV,GAAyBX,gBAAzB;MACD,CALD,MAKO,IAAIP,QAAQ,GAAGc,SAAS,CAACd,QAAzB,EAAmC;QACxCc,SAAS,CAACd,QAAV,GAAqBA,QAArB;QACAc,SAAS,CAACR,aAAV,GAA0BW,iBAAiB,CAACH,SAAD,EAAYnB,UAAZ,CAA3C;QACAmB,SAAS,CAACI,YAAV,GAAyBX,gBAAzB;MACD;IACF,CAlCD,CAoCA;;;IACAK,UAAU,GAAGC,aAAa,CAACJ,iBAAD,EAAoBhB,IAApB,CAA1B;;IACA,KAAK,IAAIqB,SAAT,IAAsBF,UAAtB,EAAkC;MAChC,IAAI,CAACG,4BAA4B,CAACD,SAAD,EAAYlB,mBAAZ,CAAjC,EAAmE;QACjEC,wBAAwB,CAACI,IAAzB,CAA8BQ,iBAA9B;QACAZ,wBAAwB,CAACI,IAAzB,CAA8Ba,SAA9B;QACA,OAAO,CAACjB,wBAAD,EAA2BE,yBAA3B,EAAsD,IAAtD,CAAP;MACD;;MACD,IAAIC,QAAQ,GAAGS,iBAAiB,CAACT,QAAlB,GAA6B,CAA5C,CANgC,CAOhC;;MACA,IAAIe,4BAA4B,CAACD,SAAD,EAAYhB,oBAAZ,CAAhC,EAAmE;QACjEA,oBAAoB,CAACkB,OAArB,CAA6BF,SAA7B;QACAA,SAAS,CAACd,QAAV,GAAqBA,QAArB;QACAc,SAAS,CAACR,aAAV,GAA0BW,iBAAiB,CAACH,SAAD,EAAYpB,SAAZ,CAA3C;QACAoB,SAAS,CAACI,YAAV,GAAyBT,iBAAzB;MACD,CALD,MAKO,IAAIT,QAAQ,GAAGc,SAAS,CAACd,QAAzB,EAAmC;QACxCc,SAAS,CAACd,QAAV,GAAqBA,QAArB;QACAc,SAAS,CAACR,aAAV,GAA0BW,iBAAiB,CAACH,SAAD,EAAYpB,SAAZ,CAA3C;QACAoB,SAAS,CAACI,YAAV,GAAyBT,iBAAzB;MACD;IACF;EACF;;EACD,OAAO,CAACZ,wBAAD,EAA2BE,yBAA3B,EAAsD,KAAtD,CAAP;AACD;;AAED,SAASY,WAAT,CAAqBJ,gBAArB,EAAuCE,iBAAvC,EAA0D;EACxD,IAAIU,QAAQ,GAAGZ,gBAAgB,CAACa,GAAhC;EACA,IAAIC,QAAQ,GAAGd,gBAAgB,CAACe,GAAhC;EACA,IAAIC,SAAS,GAAGd,iBAAiB,CAACW,GAAlC;EACA,IAAII,SAAS,GAAGf,iBAAiB,CAACa,GAAlC;EACA,IAAIC,SAAS,KAAKJ,QAAQ,GAAG,CAAzB,IAA8BK,SAAS,KAAKH,QAAhD,EAA0D,OAAO,IAAP;EAC1D,IAAIE,SAAS,KAAKJ,QAAd,IAA0BK,SAAS,KAAKH,QAAQ,GAAG,CAAvD,EAA0D,OAAO,IAAP;EAC1D,IAAIE,SAAS,KAAKJ,QAAQ,GAAG,CAAzB,IAA8BK,SAAS,KAAKH,QAAhD,EAA0D,OAAO,IAAP;EAC1D,IAAIE,SAAS,KAAKJ,QAAd,IAA0BK,SAAS,KAAKH,QAAQ,GAAG,CAAvD,EAA0D,OAAO,IAAP;EAC1D,OAAO,KAAP;AACD;;AAED,SAASR,aAAT,CAAuBY,IAAvB,EAA6BhC,IAA7B,EAAmC;EACjC,IAAImB,UAAU,GAAG,EAAjB;EACA,IAAI;IAAEQ,GAAF;IAAOE;EAAP,IAAeG,IAAnB;EACA,IAAIL,GAAG,KAAK,CAAZ,EAAeR,UAAU,CAACX,IAAX,CAAgBR,IAAI,CAAC2B,GAAG,GAAG,CAAP,CAAJ,CAAcE,GAAd,CAAhB;EACf,IAAIA,GAAG,KAAK7B,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAAR,GAAiB,CAA7B,EAAgCU,UAAU,CAACX,IAAX,CAAgBR,IAAI,CAAC2B,GAAD,CAAJ,CAAUE,GAAG,GAAG,CAAhB,CAAhB;EAChC,IAAIF,GAAG,KAAK3B,IAAI,CAACS,MAAL,GAAc,CAA1B,EAA6BU,UAAU,CAACX,IAAX,CAAgBR,IAAI,CAAC2B,GAAG,GAAG,CAAP,CAAJ,CAAcE,GAAd,CAAhB;EAC7B,IAAIA,GAAG,KAAK,CAAZ,EAAeV,UAAU,CAACX,IAAX,CAAgBR,IAAI,CAAC2B,GAAD,CAAJ,CAAUE,GAAG,GAAG,CAAhB,CAAhB;EACf,OAAOV,UAAU,CAACc,MAAX,CACJZ,SAAD,IAAe,CAACA,SAAS,CAACa,MAAX,IAAqB,CAACb,SAAS,CAACJ,SAD1C,CAAP;AAGD;;AAED,SAASO,iBAAT,CAA2BW,KAA3B,EAAkCC,KAAlC,EAAyC;EACvC,IAAIC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASJ,KAAK,CAACR,GAAN,GAAYS,KAAK,CAACT,GAA3B,CAAR;EACA,IAAIa,CAAC,GAAGF,IAAI,CAACC,GAAL,CAASJ,KAAK,CAACN,GAAN,GAAYO,KAAK,CAACP,GAA3B,CAAR;EACA,OAAOQ,CAAC,GAAGG,CAAX;AACD;;AAED,SAASlB,4BAAT,CAAsCD,SAAtC,EAAiDoB,cAAjD,EAAiE;EAC/D,KAAK,IAAIT,IAAT,IAAiBS,cAAjB,EAAiC;IAC/B,IAAIT,IAAI,CAACL,GAAL,KAAaN,SAAS,CAACM,GAAvB,IAA8BK,IAAI,CAACH,GAAL,KAAaR,SAAS,CAACQ,GAAzD,EAA8D;MAC5D,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD;;AAED,OAAO,SAASa,oDAAT,CACLP,KADK,EAELC,KAFK,EAIL;EACA,IAAIO,wBAAwB,GAAG,EAA/B;EACA,IAAIC,WAAW,GAAGR,KAAlB;;EACA,OAAOQ,WAAW,KAAK,IAAvB,EAA6B;IAC3BD,wBAAwB,CAACnC,IAAzB,CAA8BoC,WAA9B;IACAA,WAAW,GAAGA,WAAW,CAACnB,YAA1B;EACD;;EACDmB,WAAW,GAAGT,KAAd;;EACA,OAAOS,WAAW,KAAK,IAAvB,EAA6B;IAC3BD,wBAAwB,CAACpB,OAAzB,CAAiCqB,WAAjC;IACAA,WAAW,GAAGA,WAAW,CAACnB,YAA1B;EACD;;EACD,OAAOkB,wBAAP;AACD"},"metadata":{},"sourceType":"module"}