{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bidirectionalGreedySearch(grid, startNode, finishNode) {\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      isStop = false; //if(isStop) {\n      // let unvisitedNodesStart = [];\n      // let visitedNodesInOrderStart = [];\n      // let unvisitedNodesStopFirst = [];\n      // let visitedNodesInOrderStopFirst = [];\n      // let unvisitedNodesStop = [];\n      // let visitedNodesInOrderStop = [];\n      // let unvisitedNodesFinish = [];\n      // let visitedNodesInOrderFinish = [];\n      // startNode.distance = 0\n      // stopNode.distance = 0\n      // stopNode.distanceSecond = 0\n      // finishNode.distanceSecond = 0\n      // unvisitedNodesStart.push(startNode)\n      // unvisitedNodesStopFirst.push(stopNode)\n      // unvisitedNodesStop.push(stopNode)\n      // unvisitedNodesFinish.push(finishNode)\n      // while (\n      //     unvisitedNodesStart.length !== 0 &&\n      //     unvisitedNodesStopFirst.length !== 0\n      // ) {\n      //     unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n      //     unvisitedNodesStopFirst.sort((a, b) => a.totalDistance - b.totalDistance)\n      //     let closestNodeStart = unvisitedNodesStart.shift()\n      //     let closestNodeStop = unvisitedNodesStopFirst.shift()\n      //     closestNodeStart.isVisited = true\n      //     closestNodeStop.isVisited = true\n      //     visitedNodesInOrderStart.push(closestNodeStart)\n      //     visitedNodesInOrderStopFirst.push(closestNodeStop)\n      //     if (isNeighbour(closestNodeStart, closestNodeStop)) {\n      //         return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n      //     }\n      //     //start side search\n      //     let neighbours = getNeighbours(closestNodeStart, grid)\n      //     for(let neighbour of neighbours) {\n      //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n      //             visitedNodesInOrderStart.push(closestNodeStart);\n      //             visitedNodesInOrderStopFirst.push(neighbour);\n      //             return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n      //         }\n      //         let distance = closestNodeStart.distance + 1\n      //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n      //             unvisitedNodesStart.unshift(neighbour)\n      //             neighbour.distance = distance\n      //             neighbour.totalDistance = manhattenDistance(neighbour, stopNode)\n      //             neighbour.previousNode = closestNodeStart\n      //         } else if (distance < neighbour.distance) {\n      //             neighbour.distance = distance;\n      //             neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n      //             neighbour.previousNode = closestNodeStart;\n      //         }\n      //     }\n      //     //stop side search\n      //     neighbours = getNeighbours(closestNodeStop, grid);\n      //     for (let neighbour of neighbours) {\n      //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n      //             visitedNodesInOrderStopFirst.push(closestNodeStop);\n      //             visitedNodesInOrderStart.push(neighbour);\n      //             return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n      //         }\n      //         let distance = closestNodeStop.distance + 1;\n      //         //f(n) = h(n)\n      //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n      //             unvisitedNodesStopFirst.unshift(neighbour);\n      //             neighbour.distance = distance;\n      //             neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n      //             neighbour.previousNode = closestNodeStop;\n      //         } else if (distance < neighbour.distance) {\n      //             neighbour.distance = distance;\n      //             neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n      //             neighbour.previousNode = closestNodeStop;\n      //         }\n      //     }\n      // }\n      // while (\n      //     unvisitedNodesStop.length !== 0 &&\n      //     unvisitedNodesFinish.length !== 0\n      // ) {\n      //     unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n      //     unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n      //     let closestNodeStop = unvisitedNodesStop.shift()\n      //     let closestNodeFinish = unvisitedNodesFinish.shift()\n      //     closestNodeStop.isVisitedSecond = true\n      //     closestNodeFinish.isVisitedSecond = true\n      //     visitedNodesInOrderStop.push(closestNodeStop)\n      //     visitedNodesInOrderFinish.push(closestNodeFinish)\n      //     if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n      //         return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n      //     }\n      //     let neighbours = getNeighbours(closestNodeStop, grid, true)\n      //     for(let neighbour of neighbours) {\n      //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n      //             visitedNodesInOrderStop.push(closestNodeStop);\n      //             visitedNodesInOrderFinish.push(neighbour);\n      //             console.log(visitedNodesInOrderStop, visitedNodesInOrderFinish, neighbour)\n      //             return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '2']\n      //         }\n      //         let distance = closestNodeStop.distanceSecond + 1\n      //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n      //             unvisitedNodesStop.unshift(neighbour)\n      //             neighbour.distanceSecond = distance\n      //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n      //             neighbour.previousNodeSecond = closestNodeStop\n      //         } else if (distance < neighbour.distanceSecond) {\n      //             neighbour.distanceSecond = distance;\n      //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n      //             neighbour.previousNodeSecond = closestNodeStop;\n      //         }\n      //     }\n      //     neighbours = getNeighbours(closestNodeFinish, grid, true);\n      //     for (let neighbour of neighbours) {\n      //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n      //             visitedNodesInOrderFinish.push(closestNodeFinish);\n      //             visitedNodesInOrderStop.push(neighbour);\n      //             return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n      //         }\n      //         let distance = closestNodeFinish.distanceSecond + 1;\n      //         //f(n) = h(n)\n      //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n      //             unvisitedNodesFinish.unshift(neighbour);\n      //             neighbour.distanceSecond = distance;\n      //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n      //             neighbour.previousNodeSecond = closestNodeFinish;\n      //         } else if (distance < neighbour.distanceSecond) {\n      //             neighbour.distanceSecond = distance;\n      //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n      //             neighbour.previousNodeSecond = closestNodeFinish;\n      //         }\n      //     }\n      // }\n      // return [visitedNodesInOrderStart, visitedNodesInOrderStart, false]\n      // } else {\n      //     let unvisitedNodesStart = []\n      //     let visitedNodesInOrderStart = []\n      //     let unvisitedNodesFinish = []\n      //     let visitedNodesInOrderFinish = []\n      //     startNode.distance = 0\n      //     finishNode.distance = 0\n      //     unvisitedNodesStart.push(startNode)\n      //     unvisitedNodesFinish.push(finishNode)\n      //     while (\n      //         unvisitedNodesStart.length !== 0 &&\n      //         unvisitedNodesFinish.length !== 0\n      //     ) {\n      //         unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n      //         unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n      //         let closestNodeStart = unvisitedNodesStart.shift()\n      //         let closestNodeFinish = unvisitedNodesFinish.shift()\n      //         closestNodeStart.isVisited = true;\n      //         closestNodeFinish.isVisited = true;\n      //         visitedNodesInOrderStart.push(closestNodeStart);\n      //         visitedNodesInOrderFinish.push(closestNodeFinish);\n      //         if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n      //             return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      //         }\n      //         //Start side search\n      //         let neighbours = getNeighbours(closestNodeStart, grid);\n      //         for (let neighbour of neighbours) {\n      //             if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n      //                 visitedNodesInOrderStart.push(closestNodeStart);\n      //                 visitedNodesInOrderFinish.push(neighbour);\n      //                 return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      //             }\n      //             let distance = closestNodeStart.distance + 1;\n      //             //f(n) = h(n)\n      //             if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n      //                 unvisitedNodesStart.unshift(neighbour);\n      //                 neighbour.distance = distance;\n      //                 neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n      //                 neighbour.previousNode = closestNodeStart;\n      //             } else if (distance < neighbour.distance) {\n      //                 neighbour.distance = distance;\n      //                 neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n      //                 neighbour.previousNode = closestNodeStart;\n      //             }\n      //         }\n      //         //Finish side search\n      //         neighbours = getNeighbours(closestNodeFinish, grid);\n      //         for (let neighbour of neighbours) {\n      //             if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n      //                 visitedNodesInOrderFinish.push(closestNodeFinish);\n      //                 visitedNodesInOrderStart.push(neighbour);\n      //                 return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      //             }\n      //             let distance = closestNodeFinish.distance + 1;\n      //             //f(n) = h(n)\n      //             if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n      //                 unvisitedNodesFinish.unshift(neighbour);\n      //                 neighbour.distance = distance;\n      //                 neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n      //             neighbour.previousNode = closestNodeFinish;\n      //             } else if (distance < neighbour.distance) {\n      //                 neighbour.distance = distance;\n      //                 neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n      //                 neighbour.previousNode = closestNodeFinish;\n      //             }\n      //         }\n      //     }\n      //     return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n      // }\n\n      let unvisitedNodesStart = [];\n      let visitedNodesInOrderStart = [];\n      let unvisitedNodesFinish = [];\n      let visitedNodesInOrderFinish = [];\n      startNode.distance = 0;\n      finishNode.distance = 0;\n      unvisitedNodesStart.push(startNode);\n      unvisitedNodesFinish.push(finishNode);\n\n      while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n        unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n        unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n        let closestNodeStart = unvisitedNodesStart.shift();\n        let closestNodeFinish = unvisitedNodesFinish.shift();\n        closestNodeStart.isVisited = true;\n        closestNodeFinish.isVisited = true;\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderFinish.push(closestNodeFinish);\n\n        if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        } //Start side search\n\n\n        let neighbours = getNeighbours(closestNodeStart, grid);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            visitedNodesInOrderStart.push(closestNodeStart);\n            visitedNodesInOrderFinish.push(neighbour);\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n          }\n\n          let distance = closestNodeStart.distance + 1; //f(n) = h(n)\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n            unvisitedNodesStart.unshift(neighbour);\n            neighbour.distance = distance;\n            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNode = closestNodeStart;\n          } else if (distance < neighbour.distance) {\n            neighbour.distance = distance;\n            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNode = closestNodeStart;\n          }\n        } //Finish side search\n\n\n        neighbours = getNeighbours(closestNodeFinish, grid);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n            visitedNodesInOrderFinish.push(closestNodeFinish);\n            visitedNodesInOrderStart.push(neighbour);\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n          }\n\n          let distance = closestNodeFinish.distance + 1; //f(n) = h(n)\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            unvisitedNodesFinish.unshift(neighbour);\n            neighbour.distance = distance;\n            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n            neighbour.previousNode = closestNodeFinish;\n          } else if (distance < neighbour.distance) {\n            neighbour.distance = distance;\n            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n            neighbour.previousNode = closestNodeFinish;\n          }\n        }\n      }\n\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n    }\n\n    function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n      let unvisitedNodesStop = [];\n      let visitedNodesInOrderStop = [];\n      let unvisitedNodesFinish = [];\n      let visitedNodesInOrderFinish = [];\n      stopNode.distanceSecond = 0;\n      finishNode.distanceSecond = 0;\n      unvisitedNodesStop.push(stopNode);\n      unvisitedNodesFinish.push(finishNode);\n\n      while (unvisitedNodesStop.length !== 0 && unvisitedNodesFinish.length !== 0) {\n        unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n        unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n        let closestNodeStop = unvisitedNodesStop.shift();\n        let closestNodeFinish = unvisitedNodesFinish.shift();\n        closestNodeStop.isVisitedSecond = true;\n        closestNodeFinish.isVisitedSecond = true;\n        visitedNodesInOrderStop.push(closestNodeStop);\n        visitedNodesInOrderFinish.push(closestNodeFinish);\n\n        if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n          return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1'];\n        }\n\n        let neighbours = getNeighbours(closestNodeStop, grid, true);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            visitedNodesInOrderStop.push(closestNodeStop);\n            visitedNodesInOrderFinish.push(neighbour);\n            console.log(visitedNodesInOrderStop, visitedNodesInOrderFinish, neighbour);\n            return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '2'];\n          }\n\n          let distance = closestNodeStop.distanceSecond + 1;\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n            unvisitedNodesStop.unshift(neighbour);\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNodeSecond = closestNodeStop;\n          } else if (distance < neighbour.distanceSecond) {\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n            neighbour.previousNodeSecond = closestNodeStop;\n          }\n        }\n\n        neighbours = getNeighbours(closestNodeFinish, grid, true);\n\n        for (let neighbour of neighbours) {\n          if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n            visitedNodesInOrderFinish.push(closestNodeFinish);\n            visitedNodesInOrderStop.push(neighbour);\n            return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n          }\n\n          let distance = closestNodeFinish.distanceSecond + 1; //f(n) = h(n)\n\n          if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n            unvisitedNodesFinish.unshift(neighbour);\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n            neighbour.previousNodeSecond = closestNodeFinish;\n          } else if (distance < neighbour.distanceSecond) {\n            neighbour.distanceSecond = distance;\n            neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n            neighbour.previousNodeSecond = closestNodeFinish;\n          }\n        }\n      }\n    }\n\n    function isNeighbour(closestNodeStart, closestNodeFinish) {\n      let rowStart = closestNodeStart.row;\n      let colStart = closestNodeStart.col;\n      let rowFinish = closestNodeFinish.row;\n      let colFinish = closestNodeFinish.col;\n      if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n      if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n      return false;\n    }\n\n    function getNeighbours(node, grid) {\n      let isStop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let neighbours = [];\n      let {\n        row,\n        col\n      } = node;\n      if (row !== 0) neighbours.push(grid[row - 1][col]);\n      if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n      if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n      if (col !== 0) neighbours.push(grid[row][col - 1]);\n\n      if (isStop) {\n        console.log('true');\n        return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisitedSecond);\n      } else {\n        console.log('else');\n        return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n      }\n    }\n\n    function manhattenDistance(nodeA, nodeB) {\n      let x = Math.abs(nodeA.row - nodeB.row);\n      let y = Math.abs(nodeA.col - nodeB.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const isStop = message.data[4];\n    const visitedNodesInorderFirstSearch = isStop ? bidirectionalGreedySearch(grid, startNode, stopNode) : bidirectionalGreedySearch(grid, startNode, finishNode);\n    postMessage(visitedNodesInorderFirstSearch);\n  });\n});\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","bidirectionalGreedySearch","grid","startNode","finishNode","isStop","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","distance","push","length","sort","a","b","totalDistance","closestNodeStart","shift","closestNodeFinish","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","bidirectionalGreedySearchSecond","stopNode","unvisitedNodesStop","visitedNodesInOrderStop","distanceSecond","totalDistanceSecond","closestNodeStop","isVisitedSecond","console","log","previousNodeSecond","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","data","visitedNodesInorderFirstSearch","postMessage","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n            isStop=false\n\n                //if(isStop) {\n\n                // let unvisitedNodesStart = [];\n                // let visitedNodesInOrderStart = [];\n                // let unvisitedNodesStopFirst = [];\n                // let visitedNodesInOrderStopFirst = [];\n                // let unvisitedNodesStop = [];\n                // let visitedNodesInOrderStop = [];\n                // let unvisitedNodesFinish = [];\n                // let visitedNodesInOrderFinish = [];\n                // startNode.distance = 0\n                // stopNode.distance = 0\n                // stopNode.distanceSecond = 0\n                // finishNode.distanceSecond = 0\n                // unvisitedNodesStart.push(startNode)\n                // unvisitedNodesStopFirst.push(stopNode)\n                // unvisitedNodesStop.push(stopNode)\n                // unvisitedNodesFinish.push(finishNode)\n\n                // while (\n                //     unvisitedNodesStart.length !== 0 &&\n                //     unvisitedNodesStopFirst.length !== 0\n                // ) {\n                //     unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                //     unvisitedNodesStopFirst.sort((a, b) => a.totalDistance - b.totalDistance)\n                //     let closestNodeStart = unvisitedNodesStart.shift()\n                //     let closestNodeStop = unvisitedNodesStopFirst.shift()\n\n                //     closestNodeStart.isVisited = true\n                //     closestNodeStop.isVisited = true\n                //     visitedNodesInOrderStart.push(closestNodeStart)\n                //     visitedNodesInOrderStopFirst.push(closestNodeStop)\n                //     if (isNeighbour(closestNodeStart, closestNodeStop)) {\n                //         return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n                //     }\n\n                //     //start side search\n                //     let neighbours = getNeighbours(closestNodeStart, grid)\n                //     for(let neighbour of neighbours) {\n                //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n                //             visitedNodesInOrderStart.push(closestNodeStart);\n                //             visitedNodesInOrderStopFirst.push(neighbour);\n                //             return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true]\n                //         }\n                //         let distance = closestNodeStart.distance + 1\n\n                //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                //             unvisitedNodesStart.unshift(neighbour)\n                //             neighbour.distance = distance\n                //             neighbour.totalDistance = manhattenDistance(neighbour, stopNode)\n                //             neighbour.previousNode = closestNodeStart\n                //         } else if (distance < neighbour.distance) {\n                //             neighbour.distance = distance;\n                //             neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                //             neighbour.previousNode = closestNodeStart;\n                //         }\n                //     }\n\n                //     //stop side search\n                //     neighbours = getNeighbours(closestNodeStop, grid);\n                //     for (let neighbour of neighbours) {\n                //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                //             visitedNodesInOrderStopFirst.push(closestNodeStop);\n                //             visitedNodesInOrderStart.push(neighbour);\n                //             return [visitedNodesInOrderStart, visitedNodesInOrderStopFirst, true];\n                //         }\n                //         let distance = closestNodeStop.distance + 1;\n                //         //f(n) = h(n)\n                //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStopFirst)) {\n                //             unvisitedNodesStopFirst.unshift(neighbour);\n                //             neighbour.distance = distance;\n                //             neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                //             neighbour.previousNode = closestNodeStop;\n                //         } else if (distance < neighbour.distance) {\n                //             neighbour.distance = distance;\n                //             neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                //             neighbour.previousNode = closestNodeStop;\n                //         }\n                //     }\n                // }\n\n                // while (\n                //     unvisitedNodesStop.length !== 0 &&\n                //     unvisitedNodesFinish.length !== 0\n                // ) {\n                //     unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                //     unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                //     let closestNodeStop = unvisitedNodesStop.shift()\n                //     let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                //     closestNodeStop.isVisitedSecond = true\n                //     closestNodeFinish.isVisitedSecond = true\n                //     visitedNodesInOrderStop.push(closestNodeStop)\n                //     visitedNodesInOrderFinish.push(closestNodeFinish)\n                //     if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                //         return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                //     }\n\n                //     let neighbours = getNeighbours(closestNodeStop, grid, true)\n                //     for(let neighbour of neighbours) {\n                //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                //             visitedNodesInOrderStop.push(closestNodeStop);\n                //             visitedNodesInOrderFinish.push(neighbour);\n                //             console.log(visitedNodesInOrderStop, visitedNodesInOrderFinish, neighbour)\n                //             return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '2']\n                //         }\n                //         let distance = closestNodeStop.distanceSecond + 1\n                        \n                //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                //             unvisitedNodesStop.unshift(neighbour)\n                //             neighbour.distanceSecond = distance\n                //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                //             neighbour.previousNodeSecond = closestNodeStop\n                //         } else if (distance < neighbour.distanceSecond) {\n                //             neighbour.distanceSecond = distance;\n                //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                //             neighbour.previousNodeSecond = closestNodeStop;\n                //         }\n                //     }\n\n                //     neighbours = getNeighbours(closestNodeFinish, grid, true);\n                //     for (let neighbour of neighbours) {\n                //         if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                //             visitedNodesInOrderFinish.push(closestNodeFinish);\n                //             visitedNodesInOrderStop.push(neighbour);\n                //             return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                //         }\n                //         let distance = closestNodeFinish.distanceSecond + 1;\n                //         //f(n) = h(n)\n                //         if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                //             unvisitedNodesFinish.unshift(neighbour);\n                //             neighbour.distanceSecond = distance;\n                //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                //             neighbour.previousNodeSecond = closestNodeFinish;\n                //         } else if (distance < neighbour.distanceSecond) {\n                //             neighbour.distanceSecond = distance;\n                //             neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                //             neighbour.previousNodeSecond = closestNodeFinish;\n                //         }\n                //     }\n                // }\n                // return [visitedNodesInOrderStart, visitedNodesInOrderStart, false]\n\n                // } else {\n\n                //     let unvisitedNodesStart = []\n                //     let visitedNodesInOrderStart = []\n                //     let unvisitedNodesFinish = []\n                //     let visitedNodesInOrderFinish = []\n                //     startNode.distance = 0\n                //     finishNode.distance = 0\n                //     unvisitedNodesStart.push(startNode)\n                //     unvisitedNodesFinish.push(finishNode)\n                \n                //     while (\n                //         unvisitedNodesStart.length !== 0 &&\n                //         unvisitedNodesFinish.length !== 0\n                //     ) {\n                //         unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                //         unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                //         let closestNodeStart = unvisitedNodesStart.shift()\n                //         let closestNodeFinish = unvisitedNodesFinish.shift()\n                \n                //         closestNodeStart.isVisited = true;\n                //         closestNodeFinish.isVisited = true;\n                //         visitedNodesInOrderStart.push(closestNodeStart);\n                //         visitedNodesInOrderFinish.push(closestNodeFinish);\n                //         if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                //             return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                //         }\n                    \n                //         //Start side search\n                //         let neighbours = getNeighbours(closestNodeStart, grid);\n                //         for (let neighbour of neighbours) {\n                //             if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                //                 visitedNodesInOrderStart.push(closestNodeStart);\n                //                 visitedNodesInOrderFinish.push(neighbour);\n                //                 return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                //             }\n                //             let distance = closestNodeStart.distance + 1;\n                //             //f(n) = h(n)\n                //             if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                //                 unvisitedNodesStart.unshift(neighbour);\n                //                 neighbour.distance = distance;\n                //                 neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                //                 neighbour.previousNode = closestNodeStart;\n                //             } else if (distance < neighbour.distance) {\n                //                 neighbour.distance = distance;\n                //                 neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                //                 neighbour.previousNode = closestNodeStart;\n                //             }\n                //         }\n                    \n                //         //Finish side search\n                //         neighbours = getNeighbours(closestNodeFinish, grid);\n                //         for (let neighbour of neighbours) {\n                //             if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                //                 visitedNodesInOrderFinish.push(closestNodeFinish);\n                //                 visitedNodesInOrderStart.push(neighbour);\n                //                 return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                //             }\n                //             let distance = closestNodeFinish.distance + 1;\n                //             //f(n) = h(n)\n                //             if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                //                 unvisitedNodesFinish.unshift(neighbour);\n                //                 neighbour.distance = distance;\n                //                 neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                //             neighbour.previousNode = closestNodeFinish;\n                //             } else if (distance < neighbour.distance) {\n                //                 neighbour.distance = distance;\n                //                 neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                //                 neighbour.previousNode = closestNodeFinish;\n                //             }\n                //         }\n                //     }\n                //     return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n                // }\n                let unvisitedNodesStart = []\n                let visitedNodesInOrderStart = []\n                let unvisitedNodesFinish = []\n                let visitedNodesInOrderFinish = []\n                startNode.distance = 0\n                finishNode.distance = 0\n                unvisitedNodesStart.push(startNode)\n                unvisitedNodesFinish.push(finishNode)\n            \n                while (\n                    unvisitedNodesStart.length !== 0 &&\n                    unvisitedNodesFinish.length !== 0\n                ) {\n                    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance)\n                    let closestNodeStart = unvisitedNodesStart.shift()\n                    let closestNodeFinish = unvisitedNodesFinish.shift()\n            \n                    closestNodeStart.isVisited = true;\n                    closestNodeFinish.isVisited = true;\n                    visitedNodesInOrderStart.push(closestNodeStart);\n                    visitedNodesInOrderFinish.push(closestNodeFinish);\n                    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                \n                    //Start side search\n                    let neighbours = getNeighbours(closestNodeStart, grid);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            visitedNodesInOrderStart.push(closestNodeStart);\n                            visitedNodesInOrderFinish.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                        }\n                        let distance = closestNodeStart.distance + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            unvisitedNodesStart.unshift(neighbour);\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                            neighbour.previousNode = closestNodeStart;\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                            neighbour.previousNode = closestNodeStart;\n                        }\n                    }\n                \n                    //Finish side search\n                    neighbours = getNeighbours(closestNodeFinish, grid);\n                    for (let neighbour of neighbours) {\n                        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                            visitedNodesInOrderFinish.push(closestNodeFinish);\n                            visitedNodesInOrderStart.push(neighbour);\n                            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                        }\n                        let distance = closestNodeFinish.distance + 1;\n                        //f(n) = h(n)\n                        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                            unvisitedNodesFinish.unshift(neighbour);\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                        neighbour.previousNode = closestNodeFinish;\n                        } else if (distance < neighbour.distance) {\n                            neighbour.distance = distance;\n                            neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                            neighbour.previousNode = closestNodeFinish;\n                        }\n                    }\n                }\n                return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false]\n            \n            \n        }\n\n        function bidirectionalGreedySearchSecond(grid, stopNode, finishNode) {\n\n            let unvisitedNodesStop = [];\n            let visitedNodesInOrderStop = [];\n            let unvisitedNodesFinish = [];\n            let visitedNodesInOrderFinish = [];\n            stopNode.distanceSecond = 0\n            finishNode.distanceSecond = 0\n            unvisitedNodesStop.push(stopNode)\n            unvisitedNodesFinish.push(finishNode)\n\n            while (\n                unvisitedNodesStop.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n            ) {\n                unvisitedNodesStop.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                unvisitedNodesFinish.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                let closestNodeStop = unvisitedNodesStop.shift()\n                let closestNodeFinish = unvisitedNodesFinish.shift()\n\n                closestNodeStop.isVisitedSecond = true\n                closestNodeFinish.isVisitedSecond = true\n                visitedNodesInOrderStop.push(closestNodeStop)\n                visitedNodesInOrderFinish.push(closestNodeFinish)\n                if (isNeighbour(closestNodeStop, closestNodeFinish)) {\n                    return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '1']\n                }\n\n                let neighbours = getNeighbours(closestNodeStop, grid, true)\n                for(let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        visitedNodesInOrderStop.push(closestNodeStop);\n                        visitedNodesInOrderFinish.push(neighbour);\n                        console.log(visitedNodesInOrderStop, visitedNodesInOrderFinish, neighbour)\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true, '2']\n                    }\n                    let distance = closestNodeStop.distanceSecond + 1\n                    \n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        unvisitedNodesStop.unshift(neighbour)\n                        neighbour.distanceSecond = distance\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode)\n                        neighbour.previousNodeSecond = closestNodeStop\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                        neighbour.previousNodeSecond = closestNodeStop;\n                    }\n                }\n\n                neighbours = getNeighbours(closestNodeFinish, grid, true);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStop)) {\n                        visitedNodesInOrderFinish.push(closestNodeFinish);\n                        visitedNodesInOrderStop.push(neighbour);\n                        return [visitedNodesInOrderStop, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                        unvisitedNodesFinish.unshift(neighbour);\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    } else if (distance < neighbour.distanceSecond) {\n                        neighbour.distanceSecond = distance;\n                        neighbour.totalDistanceSecond = manhattenDistance(neighbour, stopNode);\n                        neighbour.previousNodeSecond = closestNodeFinish;\n                    }\n                }\n            }\n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid, isStop=false) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            \n            if(isStop) {\n                console.log('true')\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisitedSecond\n                );\n            } else {\n                console.log('else')\n                return neighbours.filter(\n                    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n                );\n            }\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n                if (node.row === neighbour.row && node.col === neighbour.col) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const isStop = message.data[4]\n        const visitedNodesInorderFirstSearch = isStop ? bidirectionalGreedySearch(grid, startNode, stopNode) : bidirectionalGreedySearch(grid, startNode, finishNode)\n\n        postMessage(visitedNodesInorderFirstSearch);\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"AAAA;AACA,IAAIA,IAAI,GAAG,IAAX;AACA,gBAAe,MAAM;EACjB;EACAA,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,OAAO,IAAI;IACxC,IAAI,CAACA,OAAL,EAAc;;IACd,SAASC,yBAAT,CAAmCC,IAAnC,EAAyCC,SAAzC,EAAoDC,UAApD,EAAgE;MAC5D,IAAI,CAACD,SAAD,IAAc,CAACC,UAAf,IAA6BD,SAAS,KAAKC,UAA/C,EAA2D;QAC3D,OAAO,KAAP;MACC;;MACDC,MAAM,GAAC,KAAP,CAJ4D,CAMxD;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MA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"},"metadata":{},"sourceType":"module"}