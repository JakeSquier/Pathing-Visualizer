{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";export function aStar(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(!!unvisitedNodes){sortNodesByDistance(unvisitedNodes,finishNode);var closestNode=unvisitedNodes.shift();if(closestNode.isWall)continue;if(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}function sortNodesByDistance(unvisitedNodes,finishNode){// calculating f\nvar f=finishNode;unvisitedNodes.sort(function(nodeA,nodeB){var af=Math.abs(f.row-nodeA.row)+Math.abs(f.col-nodeA.col);var bf=Math.abs(f.row-nodeB.row)+Math.abs(f.col-nodeB.col);if(nodeA.isWeight){nodeA.distance+=1;}else if(nodeB.isWeight){nodeB.distance+=1;}return nodeA.distance+af-(nodeB.distance+bf);});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getAllNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}export function getNodesInShortestPathOrder(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/algorithims/aStar.js"],"names":["aStar","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","f","sort","nodeA","nodeB","af","Math","abs","row","col","bf","isWeight","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","length","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function aStar(grid, startNode, finishNode){\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid)\n    while(!!unvisitedNodes){\n        sortNodesByDistance(unvisitedNodes, finishNode)\n        const closestNode = unvisitedNodes.shift();\n\n        if(closestNode.isWall) continue;\n\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n\n        if(closestNode === finishNode) return visitedNodesInOrder;\n\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisitedNodes, finishNode) {\n    // calculating f\n    const f = finishNode\n    unvisitedNodes.sort((nodeA, nodeB) => {\n        const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n        const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n        if(nodeA.isWeight){\n          nodeA.distance += 1\n        } else if(nodeB.isWeight){\n          nodeB.distance += 1\n        }\n        return (nodeA.distance+af) - (nodeB.distance+bf)\n    });\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n}\n  \nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"]},"metadata":{},"sourceType":"module"}