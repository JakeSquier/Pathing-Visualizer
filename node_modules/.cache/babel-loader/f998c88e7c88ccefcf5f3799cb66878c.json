{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode) {\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      const isStop = stopNode === false ? false : true;\n\n      if (isStop) {\n        let unvisitedNodesStart = [];\n        let visitedNodesInOrderStart = [];\n        let unvisitedNodesStop = [];\n        let visitedNodesInOrderStop = [];\n        startNode.distance = 0;\n        stopNode.distance = 0;\n        unvisitedNodesStart.push(startNode);\n        unvisitedNodesStop.push(stopNode);\n\n        while (unvisitedNodesStart.length !== 0 && unvisitedNodesStop.length !== 0) {\n          unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n          unvisitedNodesStop.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNodeStart = unvisitedNodesStart.shift;\n        }\n      } else if (!isStop) {\n        let unvisitedNodesStart = [];\n        let visitedNodesInOrderStart = [];\n        let unvisitedNodesFinish = [];\n        let visitedNodesInOrderFinish = [];\n        startNode.distance = 0;\n        finishNode.distance = 0;\n        unvisitedNodesStart.push(startNode);\n        unvisitedNodesFinish.push(finishNode);\n\n        while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n          unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n          unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNodeStart = unvisitedNodesStart.shift();\n          let closestNodeFinish = unvisitedNodesFinish.shift();\n          closestNodeStart.isVisited = true;\n          closestNodeFinish.isVisited = true;\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderFinish.push(closestNodeFinish);\n\n          if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n          } //Start side search\n\n\n          let neighbours = getNeighbours(closestNodeStart, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              visitedNodesInOrderStart.push(closestNodeStart);\n              visitedNodesInOrderFinish.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n            }\n\n            let distance = closestNodeStart.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              unvisitedNodesStart.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNodeStart;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNodeStart;\n            }\n          } //Finish side search\n\n\n          neighbours = getNeighbours(closestNodeFinish, grid);\n\n          for (let neighbour of neighbours) {\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n              visitedNodesInOrderStart.push(closestNodeFinish);\n              visitedNodesInOrderStart.push(neighbour);\n              return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n            }\n\n            let distance = closestNodeFinish.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n              unvisitedNodesFinish.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeFinish;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n              neighbour.previousNode = closestNodeFinish;\n            }\n          }\n        }\n\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n      }\n    }\n\n    function isNeighbour(closestNodeStart, closestNodeFinish) {\n      let rowStart = closestNodeStart.row;\n      let colStart = closestNodeStart.col;\n      let rowFinish = closestNodeFinish.row;\n      let colFinish = closestNodeFinish.col;\n      if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n      if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n      if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n      return false;\n    }\n\n    function getNeighbours(node, grid) {\n      let neighbours = [];\n      let {\n        row,\n        col\n      } = node;\n      if (row !== 0) neighbours.push(grid[row - 1][col]);\n      if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n      if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n      if (col !== 0) neighbours.push(grid[row][col - 1]);\n      return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n    }\n\n    function manhattenDistance(nodeA, nodeB) {\n      let x = Math.abs(nodeA.row - nodeB.row);\n      let y = Math.abs(nodeA.col - nodeB.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2]; //const stopNode = message.data[3]\n\n    const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode);\n    postMessage(visitedNodesInorder);\n  });\n});\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  currentNode = nodeA;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","bidirectionalGreedySearch","grid","startNode","finishNode","stopNode","isStop","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesStop","visitedNodesInOrderStop","distance","push","length","sort","a","b","totalDistance","closestNodeStart","shift","unvisitedNodesFinish","visitedNodesInOrderFinish","closestNodeFinish","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","data","visitedNodesInorder","postMessage","getNodesInShortestPathOrderBidirectionalGreedySearch","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/bidirectionalGreedySearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        function bidirectionalGreedySearch(grid, startNode, finishNode, stopNode) {\n            if (!startNode || !finishNode || startNode === finishNode) {\n            return false;\n            }\n            const isStop = stopNode === false ? false : true\n\n            if(isStop) {\n                \n                let unvisitedNodesStart = [];\n                let visitedNodesInOrderStart = [];\n                let unvisitedNodesStop = [];\n                let visitedNodesInOrderStop = [];\n                startNode.distance = 0\n                stopNode.distance = 0\n                unvisitedNodesStart.push(startNode)\n                unvisitedNodesStop.push(stopNode)\n\n                while (\n                    unvisitedNodesStart.length !== 0 &&\n                    unvisitedNodesStop.length !== 0\n                ) {\n                    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance)\n                    unvisitedNodesStop.sort((a, b) => a.totalDistance - b.totalDistance)\n                    let closestNodeStart = unvisitedNodesStart.shift\n                }\n\n\n            } else if(!isStop) {\n\n                let unvisitedNodesStart = [];\n                let visitedNodesInOrderStart = [];\n                let unvisitedNodesFinish = [];\n                let visitedNodesInOrderFinish = [];\n                startNode.distance = 0;\n                finishNode.distance = 0;\n                unvisitedNodesStart.push(startNode);\n                unvisitedNodesFinish.push(finishNode);\n            \n                while (\n                unvisitedNodesStart.length !== 0 &&\n                unvisitedNodesFinish.length !== 0\n                ) {\n                unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n                unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n                let closestNodeStart = unvisitedNodesStart.shift();\n                let closestNodeFinish = unvisitedNodesFinish.shift();\n            \n                closestNodeStart.isVisited = true;\n                closestNodeFinish.isVisited = true;\n                visitedNodesInOrderStart.push(closestNodeStart);\n                visitedNodesInOrderFinish.push(closestNodeFinish);\n                if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                }\n            \n                //Start side search\n                let neighbours = getNeighbours(closestNodeStart, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                    visitedNodesInOrderStart.push(closestNodeStart);\n                    visitedNodesInOrderFinish.push(neighbour);\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeStart.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                    unvisitedNodesStart.unshift(neighbour);\n                    neighbour.distance = distance;\n                    neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                    neighbour.previousNode = closestNodeStart;\n                    } else if (distance < neighbour.distance) {\n                    neighbour.distance = distance;\n                    neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                    neighbour.previousNode = closestNodeStart;\n                    }\n                }\n            \n                //Finish side search\n                neighbours = getNeighbours(closestNodeFinish, grid);\n                for (let neighbour of neighbours) {\n                    if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n                    visitedNodesInOrderStart.push(closestNodeFinish);\n                    visitedNodesInOrderStart.push(neighbour);\n                    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n                    }\n                    let distance = closestNodeFinish.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n                    unvisitedNodesFinish.unshift(neighbour);\n                    neighbour.distance = distance;\n                    neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    } else if (distance < neighbour.distance) {\n                    neighbour.distance = distance;\n                    neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n                    neighbour.previousNode = closestNodeFinish;\n                    }\n                }\n                }\n                return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n            }\n            \n            \n        }\n        \n        function isNeighbour(closestNodeStart, closestNodeFinish) {\n            let rowStart = closestNodeStart.row;\n            let colStart = closestNodeStart.col;\n            let rowFinish = closestNodeFinish.row;\n            let colFinish = closestNodeFinish.col;\n            if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n            if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n            if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n            return false;\n        }\n        \n        function getNeighbours(node, grid) {\n            let neighbours = [];\n            let { row, col } = node;\n            if (row !== 0) neighbours.push(grid[row - 1][col]);\n            if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n            if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n            if (col !== 0) neighbours.push(grid[row][col - 1]);\n            return neighbours.filter(\n            (neighbour) => !neighbour.isWall && !neighbour.isVisited\n            );\n        }\n        \n        function manhattenDistance(nodeA, nodeB) {\n            let x = Math.abs(nodeA.row - nodeB.row);\n            let y = Math.abs(nodeA.col - nodeB.col);\n            return x + y;\n        }\n        \n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n            if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false;\n            }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        //const stopNode = message.data[3]\n        const visitedNodesInorder = bidirectionalGreedySearch(grid, startNode, finishNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}\n\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}