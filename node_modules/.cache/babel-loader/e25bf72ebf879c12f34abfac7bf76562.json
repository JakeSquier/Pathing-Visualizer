{"ast":null,"code":"var self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function greedyBFS(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      var isStop;\n\n      if (stopNode === false) {\n        isStop = false;\n      } else {\n        isStop = true;\n      }\n\n      if (!isStop) {\n        let unvisitedNodes = [];\n        let visitedNodesInOrder = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n\n          if (closestNode === finishNode) {\n            visitedNodesInOrder.push(closestNode);\n            return visitedNodesInOrder;\n          }\n\n          closestNode.isVisited = true;\n          visitedNodesInOrder.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        return visitedNodesInOrder;\n      } else if (isStop) {\n        let unvisitedNodes = [];\n        let unvisitedNodesSecond = [];\n        let visitedNodesInOrder = [];\n        let firstSearch = [];\n        let secondSearch = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n        unvisitedNodesSecond.push(stopNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n\n          if (closestNode === stopNode) {\n            firstSearch.push(closestNode);\n            break;\n          }\n\n          closestNode.isVisited = true;\n          firstSearch.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid, false);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        while (unvisitedNodesSecond.length !== 0) {\n          unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n          let closestNode = unvisitedNodesSecond.shift();\n          if (closestNode === finishNode) break;\n          closestNode.isVisitedSecond = true;\n          secondSearch.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid, true);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distanceSecond + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodesSecond.unshift(neighbour);\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        console.log([firstSearch, secondSearch]);\n        return [firstSearch, secondSearch];\n      }\n    }\n\n    function getNeighbours(node, grid, isStop) {\n      let neighbour = [];\n      let {\n        row,\n        col\n      } = node;\n\n      if (isStop) {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      } else {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].lengthSecond - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.lengthSecond - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      }\n\n      return neighbour.filter(neighbour => {\n        return isStop ? !neighbour.isWall && !neighbour.isVisitedSecond : !neighbour.isWall && !neighbour.isVisited;\n      });\n    }\n\n    function manhattenDistance(node, finishNode) {\n      let x = Math.abs(node.row - finishNode.row);\n      let y = Math.abs(node.col - finishNode.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode);\n    postMessage(visitedNodesInOrder);\n  });\n});\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","greedyBFS","grid","startNode","finishNode","stopNode","isStop","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","unvisitedNodesSecond","firstSearch","secondSearch","totalDistanceSecond","isVisitedSecond","distanceSecond","console","log","node","row","col","lengthSecond","filter","isWall","x","Math","abs","y","data","postMessage","getNodesInShortestPathOrderGreedyBFS","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js"],"sourcesContent":["var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = [];\n                let unvisitedNodesSecond = [];\n                let visitedNodesInOrder = [];\n                let firstSearch = [];\n                let secondSearch = []\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n                  let closestNode = unvisitedNodesSecond.shift();\n                  if (closestNode === finishNode) break\n              \n                  closestNode.isVisitedSecond = true;\n                  secondSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, true);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodesSecond.unshift(neighbour);\n                      neighbour.distanceSecond = distance;\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distanceSecond = distance;\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                console.log([firstSearch, secondSearch])\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].lengthSecond - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.lengthSecond - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            }\n            return neighbour.filter(\n              (neighbour) => {\n                    return isStop ? !neighbour.isWall && !neighbour.isVisitedSecond : !neighbour.isWall && !neighbour.isVisited\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row);\n            let y = Math.abs(node.col - finishNode.col);\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false;\n              }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}