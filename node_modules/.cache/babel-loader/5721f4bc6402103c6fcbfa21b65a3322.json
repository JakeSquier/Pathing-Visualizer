{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// eslint-disable-next-line import/no-anonymous-default-export\nvar self=this;export default(function(){// eslint-disable-line no-restricted-globals\nself.addEventListener(\"message\",function(message){if(!message)return;function aStar(grid,startNode,finishNode){var stopNode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;//setting up stop var to determine what to do\nvar isStop;if(stopNode===false){isStop=false;}else{isStop=true;}if(!isStop){var visitedNodesInOrder=[];//grabbing all nodes\nvar unvisitedNodes=getAllNodes(grid);//setting node distances\nunvisitedNodes.forEach(function(node){if(node===startNode){node.distance=0;}else{node.distance=Infinity;}});//starting algorithim\nwhile(!!unvisitedNodes){sortNodesByDistance(unvisitedNodes,finishNode,false);var closestNode=unvisitedNodes.shift();//checking if current node is a wall\nif(closestNode.isWall)continue;//checking if node has no where to venture to\nif(closestNode.distance===Infinity)return visitedNodesInOrder;//update current node as visited then pushing it to visitednodes array\nclosestNode.isVisited=true;visitedNodesInOrder.push(closestNode);//checking to see is closest node is the finishnode\nif(closestNode===finishNode)return visitedNodesInOrder;//get current nodes neighbors\nupdateUnvisitedNeighbors(closestNode,grid,false);}}else if(isStop){//going to repeat normal function yet twice for stop\nvar _visitedNodesInOrder=[[],[]];//grabbing all nodes        \nvar unvisitedNodesSecond=getAllNodes(grid);unvisitedNodes.forEach(function(node){if(node===startNode){node.distance=0;}else if(node===stopNode){node.distanceSecond=0;}else{node.distance=Infinity;node.distanceSecond=Infinity;}});//getting path from start to stop\nwhile(!!unvisitedNodes){sortNodesByDistance(unvisitedNodes,stopNode,false);var _closestNode=unvisitedNodes.shift();//checking if current node is a wall\nif(_closestNode.isWall)continue;//checking if node has no where to venture to\nif(_closestNode.distance===Infinity)break;//update current node as visited then pushing it to visitednodes array\n_closestNode.isVisited=true;_visitedNodesInOrder[0].push(_closestNode);//checking to see is closest node is the finishnode\nif(_closestNode===stopNode)break;//get current nodes neighbors\nupdateUnvisitedNeighbors(_closestNode,grid,false);}//getting path from stop to finish\nwhile(!!unvisitedNodesSecond){sortNodesByDistance(unvisitedNodesSecond,finishNode,true);var _closestNode2=unvisitedNodesSecond.shift();if(_closestNode2.isWall)continue;if(_closestNode2.distanceSecond===Infinity)break;_closestNode2.isVisitedSecond=true;_visitedNodesInOrder[1].push(_closestNode2);if(_closestNode2===finishNode)break;updateUnvisitedNeighbors(_closestNode2,grid,true);}return _visitedNodesInOrder;}}function sortNodesByDistance(unvisitedNodes,finishNode,isStop){// calculating f\nvar f=finishNode;unvisitedNodes.sort(function(nodeA,nodeB){var af=Math.abs(f.row-nodeA.row)+Math.abs(f.col-nodeA.col);var bf=Math.abs(f.row-nodeB.row)+Math.abs(f.col-nodeB.col);if(isStop){return nodeA.distanceSecond+af-(nodeB.distanceSecond+bf);}else{return nodeA.distance+af-(nodeB.distance+bf);}});}function updateUnvisitedNeighbors(node,grid,isStop){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid,isStop);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;isStop?neighbor.distanceSecond=node.distanceSecond+1:neighbor.distance=node.distance+1;isStop?neighbor.previousNodeSecond=node:neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getUnvisitedNeighbors(node,grid,isStop){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){//isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\nif(isStop===true){return!neighbor.isVisitedSecond;}else{return!neighbor.isVisited;}});}function getAllNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}var grid=message.data[0];var startNode=message.data[1];var finishNode=message.data[2];var stopNode=message.data[3];var visitedNodesInorder=aStar(grid,startNode,finishNode,stopNode);postMessage(visitedNodesInorder);});});","map":{"version":3,"names":["self","addEventListener","message","aStar","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","unvisitedNodes","getAllNodes","forEach","node","distance","Infinity","sortNodesByDistance","closestNode","shift","isWall","isVisited","push","updateUnvisitedNeighbors","unvisitedNodesSecond","distanceSecond","isVisitedSecond","f","sort","nodeA","nodeB","af","Math","abs","row","col","bf","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNodeSecond","previousNode","neighbors","length","filter","nodes","data","visitedNodesInorder","postMessage"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/aStarWorker.js"],"sourcesContent":["\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n\n        function aStar(grid, startNode, finishNode, stopNode=false){\n            //setting up stop var to determine what to do\n            var isStop;\n            if(stopNode===false){\n              isStop = false\n            } else {\n              isStop = true\n            }\n\n            if(!isStop){\n            const visitedNodesInOrder = []\n            //grabbing all nodes\n            var unvisitedNodes = getAllNodes(grid)\n            //setting node distances\n            unvisitedNodes.forEach((node) => {\n                if(node === startNode){\n                    node.distance = 0\n                } else {\n                    node.distance = Infinity\n                }\n            })\n        \n            //starting algorithim\n            while(!!unvisitedNodes){\n\n                sortNodesByDistance(unvisitedNodes, finishNode, false)\n                \n                const closestNode = unvisitedNodes.shift()\n        \n                //checking if current node is a wall\n                if(closestNode.isWall) continue\n        \n                //checking if node has no where to venture to\n                if(closestNode.distance === Infinity) return visitedNodesInOrder\n                //update current node as visited then pushing it to visitednodes array\n                closestNode.isVisited = true\n                visitedNodesInOrder.push(closestNode)\n\n                //checking to see is closest node is the finishnode\n                if(closestNode === finishNode) return visitedNodesInOrder\n        \n                //get current nodes neighbors\n                updateUnvisitedNeighbors(closestNode, grid, false);\n            }\n            } else if(isStop){\n                //going to repeat normal function yet twice for stop\n                const visitedNodesInOrder = [[],[]]\n                //grabbing all nodes        \n                var unvisitedNodesSecond = getAllNodes(grid)\n            \n                unvisitedNodes.forEach((node) => {\n                    if(node === startNode){\n                        node.distance = 0\n                    } else if(node === stopNode) {\n                        node.distanceSecond = 0\n                    } else {\n                        node.distance = Infinity\n                        node.distanceSecond = Infinity\n                    }\n                })\n            \n                //getting path from start to stop\n                while(!!unvisitedNodes) {\n                    sortNodesByDistance(unvisitedNodes, stopNode, false)\n                    const closestNode = unvisitedNodes.shift()\n            \n                    //checking if current node is a wall\n                    if(closestNode.isWall) continue\n            \n                    //checking if node has no where to venture to\n                    if(closestNode.distance === Infinity) break\n            \n                    //update current node as visited then pushing it to visitednodes array\n                    closestNode.isVisited = true\n                    visitedNodesInOrder[0].push(closestNode)\n            \n                    //checking to see is closest node is the finishnode\n                    if(closestNode === stopNode) break\n            \n                    //get current nodes neighbors\n                    updateUnvisitedNeighbors(closestNode, grid, false);\n                }\n                \n                //getting path from stop to finish\n                while(!!unvisitedNodesSecond) {\n                    \n                    sortNodesByDistance(unvisitedNodesSecond, finishNode, true)\n\n                    const closestNode = unvisitedNodesSecond.shift()\n            \n                    if(closestNode.isWall) continue\n            \n                    if(closestNode.distanceSecond === Infinity) break\n\n                    closestNode.isVisitedSecond = true\n                    visitedNodesInOrder[1].push(closestNode)\n            \n                    if(closestNode === finishNode) break\n            \n                    updateUnvisitedNeighbors(closestNode, grid, true)\n                }\n                return visitedNodesInOrder\n            }\n        }\n\n        function sortNodesByDistance(unvisitedNodes, finishNode, isStop) {\n            // calculating f\n            const f = finishNode\n            unvisitedNodes.sort((nodeA, nodeB) => {\n                const af = (Math.abs(f.row - nodeA.row)+(Math.abs(f.col - nodeA.col)))\n                const bf = (Math.abs(f.row - nodeB.row)+(Math.abs(f.col - nodeB.col)))\n\n                if(isStop){\n                    return (nodeA.distanceSecond+af) - (nodeB.distanceSecond+bf)\n                } else {\n                    return (nodeA.distance+af) - (nodeB.distance+bf)\n                }\n            });\n        }\n        \n        function updateUnvisitedNeighbors(node, grid, isStop) {\n            const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, isStop);\n            for (const neighbor of unvisitedNeighbors) {\n                \n                isStop ? neighbor.distanceSecond = node.distanceSecond + 1 : neighbor.distance = node.distance + 1;\n        \n                isStop ? neighbor.previousNodeSecond = node : neighbor.previousNode = node;\n            }\n        }\n        \n        function getUnvisitedNeighbors(node, grid, isStop) {\n            const neighbors = [];\n            const {col, row} = node;\n            if (row > 0) neighbors.push(grid[row - 1][col]);\n            if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n            if (col > 0) neighbors.push(grid[row][col - 1]);\n            if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n            return neighbors.filter((neighbor) => {\n            //isStop ? !neighbor.isVisitedSecond : !neighbor.isVisited\n            if(isStop===true){\n                return !neighbor.isVisitedSecond\n            } else {\n                return !neighbor.isVisited\n            }\n            });\n        }\n        \n        function getAllNodes(grid) {\n            const nodes = [];\n            for (const row of grid) {\n            for (const node of row) {\n                nodes.push(node);\n            }\n            }\n            return nodes;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInorder = aStar(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInorder);\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}