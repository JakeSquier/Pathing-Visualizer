{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function depthFirstSearch(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var isStop;\n\n      if (stopNode === false) {\n        isStop = false;\n      } else {\n        isStop = true;\n      }\n\n      if (!isStop) {\n        const visitedNodesInOrder = []; // queue to keep track of the visited nodes\n\n        const queue = [];\n        queue.push(startNode);\n\n        while (queue.length) {\n          const currNode = queue.pop(); // if the finsih node is reached then we return the visitedNodes array\n\n          if (currNode === finishNode) {\n            visitedNodesInOrder.push(currNode);\n            return visitedNodesInOrder;\n          } // we skip the nodes which are walls, start node or finish node\n\n\n          if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n            currNode.isVisited = true;\n            visitedNodesInOrder.push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queue, grid, currNode, false);\n          }\n        }\n\n        return visitedNodesInOrder;\n      } else if (isStop) {\n        const firstSearch = [];\n        const secondSearch = [];\n        let queue = [];\n        let queueSecond = [];\n        queue.push(startNode);\n        queueSecond.push(stopNode);\n\n        while (queue.length) {\n          const currNode = queue.pop(); // if the finsih node is reached then we return the visitedNodes array\n\n          if (currNode === stopNode) {\n            firstSearch.push(currNode);\n            break;\n          } // we skip the nodes which are walls, start node or finish node\n\n\n          if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n            currNode.isVisited = true;\n            firstSearch.push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queue, grid, currNode, false);\n          }\n        }\n\n        while (queueSecond.length) {\n          const currNode = queueSecond.pop(); // if the finish node is reached then we return the visitedNodes array\n\n          if (currNode === finishNode) {\n            secondSearch.push(currNode);\n            break;\n          } // we skip the nodes which are walls, start node or finish node\n\n\n          if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n            currNode.isVisitedSecond = true;\n            secondSearch.push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n          }\n        }\n\n        return [firstSearch, secondSearch];\n      }\n    }\n\n    function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n      let next;\n\n      if (isStop) {\n        if (row > 0) {\n          next = grid[row - 1][col];\n\n          if (!next.isVisitedSecond) {\n            next.previousNodeSecond = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisitedSecond) {\n            next.previousNodeSecond = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisitedSecond) {\n            next.previousNodeSecond = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisitedSecond) {\n            next.previousNodeSecond = currNode;\n            queue.push(next);\n          }\n        }\n\n        return;\n      } else if (!isStop) {\n        if (row > 0) {\n          next = grid[row - 1][col];\n\n          if (!next.isVisited) {\n            next.previousNode = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisited) {\n            next.previousNode = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisited) {\n            next.previousNode = currNode;\n            queue.push(next);\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisited) {\n            next.previousNode = currNode;\n            queue.push(next);\n          }\n        }\n\n        return;\n      }\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode);\n    postMessage(visitedNodesInOrder);\n  });\n});","map":{"version":3,"names":["self","addEventListener","message","depthFirstSearch","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","queue","push","length","currNode","pop","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","firstSearch","secondSearch","queueSecond","isVisitedSecond","next","previousNodeSecond","previousNode","data","postMessage"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function depthFirstSearch(grid, startNode, finishNode, stopNode=false) {\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n\n            if(!isStop) {\n\n                const visitedNodesInOrder = []\n                // queue to keep track of the visited nodes\n                const queue = []\n                queue.push(startNode)\n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode)\n                        return visitedNodesInOrder\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        visitedNodesInOrder.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n                return visitedNodesInOrder\n      \n            } else if(isStop) {\n\n                const firstSearch = []\n                const secondSearch = []\n                let queue = []\n                let queueSecond = []\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while (queue.length) {\n                    const currNode = queue.pop()\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        firstSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true\n                        firstSearch.push(currNode)\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode, false)\n                    }\n                }\n\n                while (queueSecond.length) {\n                    const currNode = queueSecond.pop()\n                    // if the finish node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        secondSearch.push(currNode)\n                        break\n                    }\n        \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true\n                        secondSearch.push(currNode)\n                        const { row, col } = currNode\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true)\n                    }\n                }\n                \n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function  updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop) {\n            let next;\n\n            if(isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1]\n                    if (!next.isVisitedSecond) {\n                      next.previousNodeSecond = currNode\n                      queue.push(next)\n                    }\n                  }\n                  return\n\n            } else if(!isStop) {\n                if (row > 0) {\n                    next = grid[row - 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (row < grid.length - 1) {\n                    next = grid[row + 1][col]\n                    if (!next.isVisited) {\n                      next.previousNode = currNode\n                      queue.push(next)\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    next = grid[row][col + 1];\n                    if (!next.isVisited) {\n                      next.previousNode = currNode;\n                      queue.push(next);\n                    }\n                  }\n                  if (col > 0) {\n                    next = grid[row][col - 1];\n                    if (!next.isVisited) {\n                      next.previousNode = currNode;\n                      queue.push(next);\n                    }\n                  }\n                  return\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}