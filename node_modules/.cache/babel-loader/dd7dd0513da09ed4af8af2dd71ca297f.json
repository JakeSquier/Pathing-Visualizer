{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bfs(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var isStop;\n\n      if (stopNode !== false) {\n        isStop = true;\n      } else {\n        isStop = false;\n      }\n\n      let visitedNodesInOrder = []; // queue to keep track of the visited nodes\n\n      if (!isStop) {\n        let queue = [];\n        queue.push(startNode);\n\n        while (queue.length) {\n          const currNode = queue.shift(); // if the finsih node is reached then we return the visitedNodes array\n\n          if (currNode === finishNode) return visitedNodesInOrder; // we skip the nodes which are walls, start node or finish node\n\n          if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n            currNode.isVisited = true;\n            visitedNodesInOrder.push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n          }\n        }\n      } else if (isStop) {\n        let queue = [];\n        let queueSecond = [];\n        visitedNodesInOrder = [[], []];\n        queue.push(startNode);\n        queueSecond.push(stopNode);\n\n        while (queue.length) {\n          const currNode = queue.shift();\n          if (currNode === finishNode) break;\n\n          if (!currNode.isWall && (!currNode.isStart || !currNode.isVisited)) {\n            currNode.isVisited = true;\n            visitedNodesInOrder[0].push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n          }\n        }\n\n        while (queueSecond.length) {\n          const currNode = queueSecond.shift();\n          if (currNode === finishNode) break;\n\n          if (!currNode.isWall && (!currNode.isStart || !currNode.isVisitedSecond)) {\n            currNode.isVisitedSecond = true;\n            visitedNodesInOrder[1].push(currNode);\n            const {\n              row,\n              col\n            } = currNode;\n            updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n          }\n        }\n      }\n\n      postMessage(visitedNodesInOrder);\n    } // updates the neighbours,\n    // in correspondance to the algorithm \n\n\n    function updateUnvisitedNeighbours(row, col, queue, grid, currNode) {\n      let isStop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      let next;\n\n      if (row > 0) {\n        next = grid[row - 1][col];\n\n        if (isStop) {\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisitedSecond) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        } else if (!isStop) {\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (row < grid.length - 1) {\n          next = grid[row + 1][col];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col > 0) {\n          next = grid[row][col - 1];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n\n        if (col < grid[0].length - 1) {\n          next = grid[row][col + 1];\n\n          if (!next.isVisited) {\n            queue.push(next);\n            next.previousNode = currNode;\n          }\n        }\n      }\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n    console.log(visitedNodesInOrder);\n    postMessage(visitedNodesInOrder);\n  });\n});","map":{"version":3,"names":["self","addEventListener","message","bfs","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","queue","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","queueSecond","isVisitedSecond","postMessage","next","previousNode","data","console","log"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js"],"sourcesContent":["\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode!==false){\n                isStop = true\n            } else {\n                isStop = false\n            }\n            let visitedNodesInOrder = [];\n            // queue to keep track of the visited nodes\n            if(!isStop) {\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) return visitedNodesInOrder;\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode);\n                    }\n                }\n            } else if(isStop) {\n                let queue = []\n                let queueSecond = []\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode)\n                queueSecond.push(stopNode)\n                \n                while(queue.length) {\n                    const currNode = queue.shift();\n\n                    if(currNode === finishNode) break\n\n                    if(!currNode.isWall && (!currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n                    }\n                }\n\n                while(queueSecond.length) {\n                    const currNode = queueSecond.shift();\n\n                    if(currNode === finishNode) break\n\n                    if(!currNode.isWall && (!currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n            }\n            postMessage(visitedNodesInOrder)\n\n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n                let next;\n                if (row > 0) {\n                    next = grid[row - 1][col];\n\n                    if(isStop) {\n                        if (!next.isVisitedSecond) {\n                            queue.push(next);\n                            next.previousNode = currNode;\n                        }\n                        }\n                        if (row < grid.length - 1) {\n                        next = grid[row + 1][col];\n                            if (!next.isVisitedSecond) {\n                                queue.push(next);\n                                next.previousNode = currNode;\n                            }\n                        }\n                        if (col > 0) {\n                        next = grid[row][col - 1];\n                            if (!next.isVisitedSecond) {\n                                queue.push(next);\n                                next.previousNode = currNode;\n                            }\n                        }\n                        if (col < grid[0].length - 1) {\n                        next = grid[row][col + 1];\n                            if (!next.isVisitedSecond) {\n                                queue.push(next);\n                                next.previousNode = currNode;\n                            }\n                    } else if(!isStop) {\n                        if (!next.isVisited) {\n                            queue.push(next);\n                            next.previousNode = currNode;\n                        }\n                        }\n                        if (row < grid.length - 1) {\n                        next = grid[row + 1][col];\n                        if (!next.isVisited) {\n                            queue.push(next);\n                            next.previousNode = currNode;\n                        }\n                        }\n                        if (col > 0) {\n                        next = grid[row][col - 1];\n                        if (!next.isVisited) {\n                            queue.push(next);\n                            next.previousNode = currNode;\n                        }\n                        }\n                        if (col < grid[0].length - 1) {\n                        next = grid[row][col + 1];\n                        if (!next.isVisited) {\n                            queue.push(next);\n                            next.previousNode = currNode;\n                        }\n                    }\n\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode)\n        console.log(visitedNodesInOrder)\n        postMessage(visitedNodesInOrder)\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}