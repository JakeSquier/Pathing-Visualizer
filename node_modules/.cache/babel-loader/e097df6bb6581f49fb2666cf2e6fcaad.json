{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self=this;export default(function(){// eslint-disable-line no-restricted-globals\nself.addEventListener(\"message\",function(message){if(!message)return;function bfs(grid,startNode,finishNode){var stopNode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var isStop;if(stopNode===false){isStop=false;}else{isStop=true;}var visitedNodesInOrder=[];if(isStop){// queue to keep track of the visited nodes\nvar queue=[];var queueSecond=[];visitedNodesInOrder=[[],[]];queue.push(startNode);queueSecond.push(stopNode);while(queue.length){var currNode=queue.shift();// if the finsih node is reached then we return the visitedNodes array\nif(currNode===stopNode){visitedNodesInOrder[0].push(currNode);break;}// we skip the nodes which are walls, start node or finish node\nif(!currNode.isWall&&(currNode.isStart||!currNode.isVisited)){currNode.isVisited=true;visitedNodesInOrder[0].push(currNode);var row=currNode.row,col=currNode.col;updateUnvisitedNeighbours(row,col,queue,grid,currNode,false);}}while(queueSecond.length){var _currNode=queueSecond.shift();// if the finsih node is reached then we return the visitedNodes array\nif(_currNode===finishNode){visitedNodesInOrder[1].push(_currNode);break;}// we skip the nodes which are walls, start node or finish node\nif(!_currNode.isWall&&(_currNode.isStart||!_currNode.isVisitedSecond)){_currNode.isVisitedSecond=true;visitedNodesInOrder[1].push(_currNode);var _row=_currNode.row,_col=_currNode.col;updateUnvisitedNeighbours(_row,_col,queueSecond,grid,_currNode,true);}}return visitedNodesInOrder;}else if(!isStop){// queue to keep track of the visited nodes\nvar _queue=[];_queue.push(startNode);while(_queue.length){var _currNode2=_queue.shift();// if the finsih node is reached then we return the visitedNodes array\nif(_currNode2===finishNode){visitedNodesInOrder.push(_currNode2);return visitedNodesInOrder;}// we skip the nodes which are walls, start node or finish node\nif(!_currNode2.isWall&&(_currNode2.isStart||!_currNode2.isVisited)){_currNode2.isVisited=true;visitedNodesInOrder.push(_currNode2);var _row2=_currNode2.row,_col2=_currNode2.col;updateUnvisitedNeighbours(_row2,_col2,_queue,grid,_currNode2,false);}}return visitedNodesInOrder;}}// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row,col,queue,grid,currNode){var isStop=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;if(isStop){var next;if(row>0){next=grid[row-1][col];if(!next.isVisitedSecond){queue.push(next);next.previousNodeSecond=currNode;}}if(row<grid.length-1){next=grid[row+1][col];if(!next.isVisitedSecond){queue.push(next);next.previousNodeSecond=currNode;}}if(col>0){next=grid[row][col-1];if(!next.isVisitedSecond){queue.push(next);next.previousNodeSecond=currNode;}}if(col<grid[0].length-1){next=grid[row][col+1];if(!next.isVisitedSecond){queue.push(next);next.previousNodeSecond=currNode;}}}else if(!isStop){var _next;if(row>0){_next=grid[row-1][col];if(!_next.isVisited){queue.push(_next);_next.previousNode=currNode;}}if(row<grid.length-1){_next=grid[row+1][col];if(!_next.isVisited){queue.push(_next);_next.previousNode=currNode;}}if(col>0){_next=grid[row][col-1];if(!_next.isVisited){queue.push(_next);_next.previousNode=currNode;}}if(col<grid[0].length-1){_next=grid[row][col+1];if(!_next.isVisited){queue.push(_next);_next.previousNode=currNode;}}}}var grid=message.data[0];var startNode=message.data[1];var finishNode=message.data[2];var stopNode=message.data[3];var visitedNodesInOrder=bfs(grid,startNode,finishNode,stopNode);postMessage(visitedNodesInOrder);});});","map":{"version":3,"names":["self","addEventListener","message","bfs","grid","startNode","finishNode","stopNode","isStop","visitedNodesInOrder","queue","queueSecond","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","isVisitedSecond","next","previousNodeSecond","previousNode","data","postMessage"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js"],"sourcesContent":["\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode, stopNode=false) {\n            \n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            let visitedNodesInOrder = [];\n\n            if(isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                let queueSecond = [];\n                visitedNodesInOrder = [[],[]]\n                queue.push(startNode);\n                queueSecond.push(stopNode)\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === stopNode) {\n                        visitedNodesInOrder[0].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder[0].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                while (queueSecond.length) {\n                    const currNode = queueSecond.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder[1].push(currNode);\n                        break\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisitedSecond)) {\n                        currNode.isVisitedSecond = true;\n                        visitedNodesInOrder[1].push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queueSecond, grid, currNode, true);\n                    }\n                }\n                return visitedNodesInOrder\n\n            } else if(!isStop) {\n                // queue to keep track of the visited nodes\n                let queue = [];\n                queue.push(startNode);\n                while (queue.length) {\n                    const currNode = queue.shift();\n                    // if the finsih node is reached then we return the visitedNodes array\n                    if (currNode === finishNode) {\n                        visitedNodesInOrder.push(currNode);\n                        return visitedNodesInOrder;\n                    }\n                    \n                    // we skip the nodes which are walls, start node or finish node\n                    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                        currNode.isVisited = true;\n                        visitedNodesInOrder.push(currNode);\n                        const { row, col } = currNode;\n                        updateUnvisitedNeighbours(row, col, queue, grid,currNode, false);\n                    }\n                }\n                return visitedNodesInOrder\n            }\n  \n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row, col, queue, grid, currNode, isStop=false) {\n\n            if(isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisitedSecond) {\n                    queue.push(next);\n                    next.previousNodeSecond = currNode;\n                  }\n                }\n            } else if(!isStop) {\n                let next;\n                if (row > 0) {\n                  next = grid[row - 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (row < grid.length - 1) {\n                  next = grid[row + 1][col];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col > 0) {\n                  next = grid[row][col - 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n                if (col < grid[0].length - 1) {\n                  next = grid[row][col + 1];\n                  if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                  }\n                }\n            }\n      }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}"],"mappings":"AACA;AACA,GAAIA,KAAI,CAAG,IAAX,CACA,eAAe,UAAM,CACjB;AACAA,IAAI,CAACC,gBAAL,CAAsB,SAAtB,CAAiC,SAAAC,OAAO,CAAI,CAC1C,GAAI,CAACA,OAAL,CAAc,OACZ,QAASC,IAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0D,IAAhBC,SAAgB,2DAAP,KAAO,CAEtD,GAAIC,OAAJ,CACA,GAAGD,QAAQ,GAAG,KAAd,CAAoB,CAChBC,MAAM,CAAG,KAAT,CACH,CAFD,IAEO,CACHA,MAAM,CAAG,IAAT,CACH,CACD,GAAIC,oBAAmB,CAAG,EAA1B,CAEA,GAAGD,MAAH,CAAW,CACP;AACA,GAAIE,MAAK,CAAG,EAAZ,CACA,GAAIC,YAAW,CAAG,EAAlB,CACAF,mBAAmB,CAAG,CAAC,EAAD,CAAI,EAAJ,CAAtB,CACAC,KAAK,CAACE,IAAN,CAAWP,SAAX,EACAM,WAAW,CAACC,IAAZ,CAAiBL,QAAjB,EACA,MAAOG,KAAK,CAACG,MAAb,CAAqB,CACjB,GAAMC,SAAQ,CAAGJ,KAAK,CAACK,KAAN,EAAjB,CACA;AACA,GAAID,QAAQ,GAAKP,QAAjB,CAA2B,CACvBE,mBAAmB,CAAC,CAAD,CAAnB,CAAuBG,IAAvB,CAA4BE,QAA5B,EACA,MACH,CAED;AACA,GAAI,CAACA,QAAQ,CAACE,MAAV,GAAqBF,QAAQ,CAACG,OAAT,EAAoB,CAACH,QAAQ,CAACI,SAAnD,CAAJ,CAAmE,CAC/DJ,QAAQ,CAACI,SAAT,CAAqB,IAArB,CACAT,mBAAmB,CAAC,CAAD,CAAnB,CAAuBG,IAAvB,CAA4BE,QAA5B,EAF+D,GAGvDK,IAHuD,CAG1CL,QAH0C,CAGvDK,GAHuD,CAGlDC,GAHkD,CAG1CN,QAH0C,CAGlDM,GAHkD,CAI/DC,yBAAyB,CAACF,GAAD,CAAMC,GAAN,CAAWV,KAAX,CAAkBN,IAAlB,CAAuBU,QAAvB,CAAiC,KAAjC,CAAzB,CACH,CACJ,CACD,MAAOH,WAAW,CAACE,MAAnB,CAA2B,CACvB,GAAMC,UAAQ,CAAGH,WAAW,CAACI,KAAZ,EAAjB,CACA;AACA,GAAID,SAAQ,GAAKR,UAAjB,CAA6B,CACzBG,mBAAmB,CAAC,CAAD,CAAnB,CAAuBG,IAAvB,CAA4BE,SAA5B,EACA,MACH,CAED;AACA,GAAI,CAACA,SAAQ,CAACE,MAAV,GAAqBF,SAAQ,CAACG,OAAT,EAAoB,CAACH,SAAQ,CAACQ,eAAnD,CAAJ,CAAyE,CACrER,SAAQ,CAACQ,eAAT,CAA2B,IAA3B,CACAb,mBAAmB,CAAC,CAAD,CAAnB,CAAuBG,IAAvB,CAA4BE,SAA5B,EAFqE,GAG7DK,KAH6D,CAGhDL,SAHgD,CAG7DK,GAH6D,CAGxDC,IAHwD,CAGhDN,SAHgD,CAGxDM,GAHwD,CAIrEC,yBAAyB,CAACF,IAAD,CAAMC,IAAN,CAAWT,WAAX,CAAwBP,IAAxB,CAA8BU,SAA9B,CAAwC,IAAxC,CAAzB,CACH,CACJ,CACD,MAAOL,oBAAP,CAEH,CAzCD,IAyCO,IAAG,CAACD,MAAJ,CAAY,CACf;AACA,GAAIE,OAAK,CAAG,EAAZ,CACAA,MAAK,CAACE,IAAN,CAAWP,SAAX,EACA,MAAOK,MAAK,CAACG,MAAb,CAAqB,CACjB,GAAMC,WAAQ,CAAGJ,MAAK,CAACK,KAAN,EAAjB,CACA;AACA,GAAID,UAAQ,GAAKR,UAAjB,CAA6B,CACzBG,mBAAmB,CAACG,IAApB,CAAyBE,UAAzB,EACA,MAAOL,oBAAP,CACH,CAED;AACA,GAAI,CAACK,UAAQ,CAACE,MAAV,GAAqBF,UAAQ,CAACG,OAAT,EAAoB,CAACH,UAAQ,CAACI,SAAnD,CAAJ,CAAmE,CAC/DJ,UAAQ,CAACI,SAAT,CAAqB,IAArB,CACAT,mBAAmB,CAACG,IAApB,CAAyBE,UAAzB,EAF+D,GAGvDK,MAHuD,CAG1CL,UAH0C,CAGvDK,GAHuD,CAGlDC,KAHkD,CAG1CN,UAH0C,CAGlDM,GAHkD,CAI/DC,yBAAyB,CAACF,KAAD,CAAMC,KAAN,CAAWV,MAAX,CAAkBN,IAAlB,CAAuBU,UAAvB,CAAiC,KAAjC,CAAzB,CACH,CACJ,CACD,MAAOL,oBAAP,CACH,CAEJ,CAED;AACA;AACA,QAASY,0BAAT,CAAmCF,GAAnC,CAAwCC,GAAxC,CAA6CV,KAA7C,CAAoDN,IAApD,CAA0DU,QAA1D,CAAkF,IAAdN,OAAc,2DAAP,KAAO,CAE9E,GAAGA,MAAH,CAAW,CACP,GAAIe,KAAJ,CACA,GAAIJ,GAAG,CAAG,CAAV,CAAa,CACXI,IAAI,CAAGnB,IAAI,CAACe,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACG,IAAI,CAACD,eAAV,CAA2B,CACzBZ,KAAK,CAACE,IAAN,CAAWW,IAAX,EACAA,IAAI,CAACC,kBAAL,CAA0BV,QAA1B,CACD,CACF,CACD,GAAIK,GAAG,CAAGf,IAAI,CAACS,MAAL,CAAc,CAAxB,CAA2B,CACzBU,IAAI,CAAGnB,IAAI,CAACe,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACG,IAAI,CAACD,eAAV,CAA2B,CACzBZ,KAAK,CAACE,IAAN,CAAWW,IAAX,EACAA,IAAI,CAACC,kBAAL,CAA0BV,QAA1B,CACD,CACF,CACD,GAAIM,GAAG,CAAG,CAAV,CAAa,CACXG,IAAI,CAAGnB,IAAI,CAACe,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACG,IAAI,CAACD,eAAV,CAA2B,CACzBZ,KAAK,CAACE,IAAN,CAAWW,IAAX,EACAA,IAAI,CAACC,kBAAL,CAA0BV,QAA1B,CACD,CACF,CACD,GAAIM,GAAG,CAAGhB,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAAR,CAAiB,CAA3B,CAA8B,CAC5BU,IAAI,CAAGnB,IAAI,CAACe,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACG,IAAI,CAACD,eAAV,CAA2B,CACzBZ,KAAK,CAACE,IAAN,CAAWW,IAAX,EACAA,IAAI,CAACC,kBAAL,CAA0BV,QAA1B,CACD,CACF,CACJ,CA9BD,IA8BO,IAAG,CAACN,MAAJ,CAAY,CACf,GAAIe,MAAJ,CACA,GAAIJ,GAAG,CAAG,CAAV,CAAa,CACXI,KAAI,CAAGnB,IAAI,CAACe,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACG,KAAI,CAACL,SAAV,CAAqB,CACnBR,KAAK,CAACE,IAAN,CAAWW,KAAX,EACAA,KAAI,CAACE,YAAL,CAAoBX,QAApB,CACD,CACF,CACD,GAAIK,GAAG,CAAGf,IAAI,CAACS,MAAL,CAAc,CAAxB,CAA2B,CACzBU,KAAI,CAAGnB,IAAI,CAACe,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACG,KAAI,CAACL,SAAV,CAAqB,CACnBR,KAAK,CAACE,IAAN,CAAWW,KAAX,EACAA,KAAI,CAACE,YAAL,CAAoBX,QAApB,CACD,CACF,CACD,GAAIM,GAAG,CAAG,CAAV,CAAa,CACXG,KAAI,CAAGnB,IAAI,CAACe,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACG,KAAI,CAACL,SAAV,CAAqB,CACnBR,KAAK,CAACE,IAAN,CAAWW,KAAX,EACAA,KAAI,CAACE,YAAL,CAAoBX,QAApB,CACD,CACF,CACD,GAAIM,GAAG,CAAGhB,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAAR,CAAiB,CAA3B,CAA8B,CAC5BU,KAAI,CAAGnB,IAAI,CAACe,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACG,KAAI,CAACL,SAAV,CAAqB,CACnBR,KAAK,CAACE,IAAN,CAAWW,KAAX,EACAA,KAAI,CAACE,YAAL,CAAoBX,QAApB,CACD,CACF,CACJ,CACN,CAEC,GAAMV,KAAI,CAAGF,OAAO,CAACwB,IAAR,CAAa,CAAb,CAAb,CACA,GAAMrB,UAAS,CAAGH,OAAO,CAACwB,IAAR,CAAa,CAAb,CAAlB,CACA,GAAMpB,WAAU,CAAGJ,OAAO,CAACwB,IAAR,CAAa,CAAb,CAAnB,CACA,GAAMnB,SAAQ,CAAGL,OAAO,CAACwB,IAAR,CAAa,CAAb,CAAjB,CAEA,GAAMjB,oBAAmB,CAAGN,GAAG,CAACC,IAAD,CAAOC,SAAP,CAAkBC,UAAlB,CAA8BC,QAA9B,CAA/B,CAEAoB,WAAW,CAAClB,mBAAD,CAAX,CACH,CAzJD,EA0JH,CA5JD"},"metadata":{},"sourceType":"module"}