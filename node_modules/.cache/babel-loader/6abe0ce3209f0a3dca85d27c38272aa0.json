{"ast":null,"code":"var self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function greedyBFS(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      var isStop;\n\n      if (stopNode === false) {\n        isStop = false;\n      } else {\n        isStop = true;\n      }\n\n      if (!isStop) {\n        let unvisitedNodes = [];\n        let visitedNodesInOrder = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n          if (closestNode === finishNode) return visitedNodesInOrder;\n          closestNode.isVisited = true;\n          visitedNodesInOrder.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        return visitedNodesInOrder;\n      } else if (isStop) {\n        let unvisitedNodes = [];\n        let visitedNodesInOrder = [];\n        let firstSearch = [];\n        let secondSearch = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n          if (closestNode === finishNode) return vis;\n          closestNode.isVisited = true;\n          visitedNodesInOrder.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n      }\n    }\n\n    function getNeighbours(node, grid, isStop) {\n      let neighbour = [];\n      let {\n        row,\n        col\n      } = node;\n\n      if (isStop) {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      } else {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].lengthSecond - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.lengthSecond - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      }\n\n      return neighbour.filter(neighbour => {\n        return isStop ? !neighbour.isWall && !neighbour.isVisitedSecond : !neighbour.isWall && !neighbour.isVisited;\n      });\n    }\n\n    function manhattenDistance(node, finishNode) {\n      let x = Math.abs(node.row - finishNode.row);\n      let y = Math.abs(node.col - finishNode.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode);\n    postMessage(visitedNodesInOrder);\n  });\n});\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","greedyBFS","grid","startNode","finishNode","stopNode","isStop","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","firstSearch","secondSearch","vis","node","row","col","lengthSecond","filter","isWall","isVisitedSecond","x","Math","abs","y","data","postMessage","getNodesInShortestPathOrderGreedyBFS","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js"],"sourcesContent":["var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) return visitedNodesInOrder;\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                let firstSearch = [];\n                let secondSearch = []\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) return vis;\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].lengthSecond - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.lengthSecond - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            }\n            return neighbour.filter(\n              (neighbour) => {\n                    return isStop ? !neighbour.isWall && !neighbour.isVisitedSecond : !neighbour.isWall && !neighbour.isVisited\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row);\n            let y = Math.abs(node.col - finishNode.col);\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false;\n              }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}