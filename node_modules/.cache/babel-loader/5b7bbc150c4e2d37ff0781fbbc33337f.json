{"ast":null,"code":"export function greedyBFS(grid, startNode, finishNode) {\n  console.log();\n\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    let neighbours = getNeighbours(closestNode, grid);\n\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1; //f(n) = h(n)\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\n\nfunction manhattenDistance(node, finishNode) {\n  let x = Math.abs(node.row - finishNode.row);\n  let y = Math.abs(node.col - finishNode.col);\n  return x + y;\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/algorithims/greedyBestFirstSearch.js"],"names":["greedyBFS","grid","startNode","finishNode","console","log","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","node","row","col","filter","isWall","x","Math","abs","y","getNodesInShortestPathOrderGreedyBFS","nodesInShortestPathOrder","currentNode"],"mappings":"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","sourcesContent":["export function greedyBFS(grid, startNode, finishNode) {\n    console.log()\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }"]},"metadata":{},"sourceType":"module"}