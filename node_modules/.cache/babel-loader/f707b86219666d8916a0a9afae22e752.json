{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function bfs(grid, startNode, finishNode) {\n      console.log('made it');\n      const visitedNodesInOrder = []; // queue to keep track of the visited nodes\n\n      let queue = [];\n      queue.push(startNode);\n\n      while (queue.length) {\n        const currNode = queue.shift(); // if the finsih node is reached then we return the visitedNodes array\n\n        if (currNode === finishNode) return visitedNodesInOrder; // we skip the nodes which are walls, start node or finish node\n\n        if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n          currNode.isVisited = true;\n          visitedNodesInOrder.push(currNode);\n          const {\n            row,\n            col\n          } = currNode;\n          updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n        }\n      }\n    } // updates the neighbours,\n    // in correspondance to the algorithm \n\n\n    function updateUnvisitedNeighbours(row, col, queue, grid, currNode) {\n      let next;\n\n      if (row > 0) {\n        next = grid[row - 1][col];\n\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n\n      if (row < grid.length - 1) {\n        next = grid[row + 1][col];\n\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n\n      if (col > 0) {\n        next = grid[row][col - 1];\n\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n\n      if (col < grid[0].length - 1) {\n        next = grid[row][col + 1];\n\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n    return visitedNodesInOrder;\n  });\n});","map":{"version":3,"names":["self","addEventListener","message","bfs","grid","startNode","finishNode","console","log","visitedNodesInOrder","queue","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode","data","stopNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/breadthFirstSearchWorker.js"],"sourcesContent":["\n// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n      if (!message) return;\n        function bfs(grid, startNode, finishNode) {\n            console.log('made it')\n            const visitedNodesInOrder = [];\n            // queue to keep track of the visited nodes\n            let queue = [];\n            queue.push(startNode);\n            while (queue.length) {\n            const currNode = queue.shift();\n            // if the finsih node is reached then we return the visitedNodes array\n                if (currNode === finishNode)\n                    return visitedNodesInOrder;\n                \n                // we skip the nodes which are walls, start node or finish node\n                if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n                    currNode.isVisited = true;\n                    visitedNodesInOrder.push(currNode);\n                    const { row, col } = currNode;\n                    updateUnvisitedNeighbours(row, col, queue, grid,currNode);\n                }\n            }\n        }\n        \n        // updates the neighbours,\n        // in correspondance to the algorithm \n        function updateUnvisitedNeighbours(row,col,queue,grid,currNode) {\n                let next;\n                if (row > 0) {\n                next = grid[row - 1][col];\n                if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                }\n                }\n                if (row < grid.length - 1) {\n                next = grid[row + 1][col];\n                if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                }\n                }\n                if (col > 0) {\n                next = grid[row][col - 1];\n                if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                }\n                }\n                if (col < grid[0].length - 1) {\n                next = grid[row][col + 1];\n                if (!next.isVisited) {\n                    queue.push(next);\n                    next.previousNode = currNode;\n                }\n            }\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode)\n\n        return visitedNodesInOrder\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}