{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n\n  return result;\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n\n  let dir;\n  let num;\n\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode, stopNode);\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return array[randomNum];\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([num, temp]);\n    }\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return randomNum;\n}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","stopNode","vertical","range","length","horizontal","getRecursiveWalls","len","result","i","push","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","splice","generateRandomNumber","wall"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js"],"sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode, stopNode=false) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}