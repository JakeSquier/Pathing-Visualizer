{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n    const visitedNodesInOrder = []; // stack to keep track of the visited nodes\n\n    const stack = [];\n    stack.push(startNode);\n\n    while (stack.length) {\n      const currNode = stack.pop(); // if the finsih node is reached then we return the visitedNodes array\n\n      if (currNode === finishNode) return visitedNodesInOrder; // we skip the nodes which are walls, start node or finish node\n\n      if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n        currNode.isVisited = true;\n        visitedNodesInOrder.push(currNode);\n        const {\n          row,\n          col\n        } = currNode;\n        updateUnvisitedNeighbours(row, col, stack, grid, currNode);\n      }\n    }\n  });\n  const grid = message.data[0];\n  const startNode = message.data[1];\n  const finishNode = message.data[2];\n  const stopNode = message.data[3];\n});\n\nfunction updateUnvisitedNeighbours(row, col, stack, grid, currNode) {\n  let next;\n\n  if (row > 0) {\n    next = grid[row - 1][col];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    next = grid[row + 1][col];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    next = grid[row][col + 1];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (col > 0) {\n    next = grid[row][col - 1];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n}","map":{"version":3,"names":["self","addEventListener","message","visitedNodesInOrder","stack","push","startNode","length","currNode","pop","finishNode","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","grid","data","stopNode","next","previousNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/depthFirstSearchWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n        const visitedNodesInOrder = [];\n        // stack to keep track of the visited nodes\n        const stack = []; \n        stack.push(startNode);\n        while (stack.length) {\n            const currNode = stack.pop();\n            // if the finsih node is reached then we return the visitedNodes array\n            if (currNode === finishNode) \n            return visitedNodesInOrder;\n\n            // we skip the nodes which are walls, start node or finish node\n            if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n            currNode.isVisited = true;\n            visitedNodesInOrder.push(currNode);\n            const { row, col } = currNode;\n            updateUnvisitedNeighbours(row, col, stack, grid,currNode);\n            }\n        }\n    })\n\n    const grid = message.data[0]\n    const startNode = message.data[1]\n    const finishNode = message.data[2]\n    const stopNode = message.data[3]\n    \n}\n\nfunction  updateUnvisitedNeighbours(row, col, stack, grid,currNode) {\n    let next;\n    if (row > 0) {\n      next = grid[row - 1][col];\n      if (!next.isVisited) {\n        next.previousNode = currNode;\n        stack.push(next);\n      }\n    }\n    if (row < grid.length - 1) {\n      next = grid[row + 1][col];\n      if (!next.isVisited) {\n        next.previousNode = currNode;\n        stack.push(next);\n      }\n    }\n    if (col < grid[0].length - 1) {\n      next = grid[row][col + 1];\n      if (!next.isVisited) {\n        next.previousNode = currNode;\n        stack.push(next);\n      }\n    }\n    if (col > 0) {\n      next = grid[row][col - 1];\n      if (!next.isVisited) {\n        next.previousNode = currNode;\n        stack.push(next);\n      }\n    }\n}"],"mappings":"AAAA;AACA,IAAIA,IAAI,GAAG,IAAX;AACA,gBAAe,MAAM;EACjB;EACAA,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,OAAO,IAAI;IACxC,IAAI,CAACA,OAAL,EAAc;IACd,MAAMC,mBAAmB,GAAG,EAA5B,CAFwC,CAGxC;;IACA,MAAMC,KAAK,GAAG,EAAd;IACAA,KAAK,CAACC,IAAN,CAAWC,SAAX;;IACA,OAAOF,KAAK,CAACG,MAAb,EAAqB;MACjB,MAAMC,QAAQ,GAAGJ,KAAK,CAACK,GAAN,EAAjB,CADiB,CAEjB;;MACA,IAAID,QAAQ,KAAKE,UAAjB,EACA,OAAOP,mBAAP,CAJiB,CAMjB;;MACA,IAAI,CAACK,QAAQ,CAACG,MAAV,KAAqBH,QAAQ,CAACI,OAAT,IAAoB,CAACJ,QAAQ,CAACK,SAAnD,CAAJ,EAAmE;QACnEL,QAAQ,CAACK,SAAT,GAAqB,IAArB;QACAV,mBAAmB,CAACE,IAApB,CAAyBG,QAAzB;QACA,MAAM;UAAEM,GAAF;UAAOC;QAAP,IAAeP,QAArB;QACAQ,yBAAyB,CAACF,GAAD,EAAMC,GAAN,EAAWX,KAAX,EAAkBa,IAAlB,EAAuBT,QAAvB,CAAzB;MACC;IACJ;EACJ,CApBD;EAsBA,MAAMS,IAAI,GAAGf,OAAO,CAACgB,IAAR,CAAa,CAAb,CAAb;EACA,MAAMZ,SAAS,GAAGJ,OAAO,CAACgB,IAAR,CAAa,CAAb,CAAlB;EACA,MAAMR,UAAU,GAAGR,OAAO,CAACgB,IAAR,CAAa,CAAb,CAAnB;EACA,MAAMC,QAAQ,GAAGjB,OAAO,CAACgB,IAAR,CAAa,CAAb,CAAjB;AAEH,CA7BD;;AA+BA,SAAUF,yBAAV,CAAoCF,GAApC,EAAyCC,GAAzC,EAA8CX,KAA9C,EAAqDa,IAArD,EAA0DT,QAA1D,EAAoE;EAChE,IAAIY,IAAJ;;EACA,IAAIN,GAAG,GAAG,CAAV,EAAa;IACXM,IAAI,GAAGH,IAAI,CAACH,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACK,IAAI,CAACP,SAAV,EAAqB;MACnBO,IAAI,CAACC,YAAL,GAAoBb,QAApB;MACAJ,KAAK,CAACC,IAAN,CAAWe,IAAX;IACD;EACF;;EACD,IAAIN,GAAG,GAAGG,IAAI,CAACV,MAAL,GAAc,CAAxB,EAA2B;IACzBa,IAAI,GAAGH,IAAI,CAACH,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACK,IAAI,CAACP,SAAV,EAAqB;MACnBO,IAAI,CAACC,YAAL,GAAoBb,QAApB;MACAJ,KAAK,CAACC,IAAN,CAAWe,IAAX;IACD;EACF;;EACD,IAAIL,GAAG,GAAGE,IAAI,CAAC,CAAD,CAAJ,CAAQV,MAAR,GAAiB,CAA3B,EAA8B;IAC5Ba,IAAI,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACK,IAAI,CAACP,SAAV,EAAqB;MACnBO,IAAI,CAACC,YAAL,GAAoBb,QAApB;MACAJ,KAAK,CAACC,IAAN,CAAWe,IAAX;IACD;EACF;;EACD,IAAIL,GAAG,GAAG,CAAV,EAAa;IACXK,IAAI,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACK,IAAI,CAACP,SAAV,EAAqB;MACnBO,IAAI,CAACC,YAAL,GAAoBb,QAApB;MACAJ,KAAK,CAACC,IAAN,CAAWe,IAAX;IACD;EACF;AACJ"},"metadata":{},"sourceType":"module"}