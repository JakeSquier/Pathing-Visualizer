{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode, isTH) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n\n  return result;\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n\n  let dir;\n  let num;\n\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode, stopNode);\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode, stopNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode, stopNode);\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return array[randomNum];\n} //dir === 0 => Horizontal\n//dir === 1 => Vertical\n\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col || temp === stopNode.row && num === stopNode.col && stopNode != false) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col || temp === stopNode.row && num === stopNode.col && stopNode != false) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([num, temp]);\n    }\n  }\n\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return randomNum;\n}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","isTH","vertical","range","length","horizontal","getRecursiveWalls","stopNode","len","result","i","push","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","splice","generateRandomNumber","wall"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/mazeAlgorithims/recursiveDivisionMaze.js"],"sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode, isTH) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, stopNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode,\n      stopNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode, stopNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col) ||\n        ((temp === stopNode.row && num === stopNode.col) && stopNode!=false)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col) ||\n        ((temp === stopNode.row && num === stopNode.col) && stopNode!=false)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}