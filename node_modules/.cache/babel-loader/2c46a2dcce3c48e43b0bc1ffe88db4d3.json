{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";export function greedyBFS(grid,startNode,finishNode){if(!startNode||!finishNode||startNode===finishNode){return false;}var unvisitedNodes=[];var visitedNodesInOrder=[];startNode.distance=0;unvisitedNodes.push(startNode);while(unvisitedNodes.length!==0){unvisitedNodes.sort(function(a,b){return a.totalDistance-b.totalDistance;});var closestNode=unvisitedNodes.shift();if(closestNode===finishNode)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);var neighbours=getNeighbours(closestNode,grid);var _iterator=_createForOfIteratorHelper(neighbours),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbour=_step.value;var distance=closestNode.distance+1;//f(n) = h(n)\nif(neighbourNotInUnvisitedNodes(neighbour,unvisitedNodes)){unvisitedNodes.unshift(neighbour);neighbour.distance=distance;neighbour.totalDistance=manhattenDistance(neighbour,finishNode);neighbour.previousNode=closestNode;}else if(distance<neighbour.distance){neighbour.distance=distance;neighbour.totalDistance=manhattenDistance(neighbour,finishNode);neighbour.previousNode=closestNode;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return visitedNodesInOrder;}function getNeighbours(node,grid){var neighbours=[];var row=node.row,col=node.col;if(row!==0)neighbours.push(grid[row-1][col]);if(col!==grid[0].length-1)neighbours.push(grid[row][col+1]);if(row!==grid.length-1)neighbours.push(grid[row+1][col]);if(col!==0)neighbours.push(grid[row][col-1]);return neighbours.filter(function(neighbour){return!neighbour.isWall&&!neighbour.isVisited;});}function manhattenDistance(node,finishNode){var x=Math.abs(node.row-finishNode.row);var y=Math.abs(node.col-finishNode.col);return x+y;}function neighbourNotInUnvisitedNodes(neighbour,unvisitedNodes){var _iterator2=_createForOfIteratorHelper(unvisitedNodes),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;if(node.row===neighbour.row&&node.col===neighbour.col){return false;}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return true;}export function getNodesInShortestPathOrderGreedyBFS(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/algorithims/greedyBestFirstSearch.js"],"names":["greedyBFS","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","node","row","col","filter","isWall","x","Math","abs","y","getNodesInShortestPathOrderGreedyBFS","nodesInShortestPathOrder","currentNode"],"mappings":"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","sourcesContent":["export function greedyBFS(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }"]},"metadata":{},"sourceType":"module"}