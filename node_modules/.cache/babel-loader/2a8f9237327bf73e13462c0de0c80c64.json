{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// export function dijkstra(grid, startNode, finishNode, stopNode){\n//   const visitedNodesInOrder = [[],[]];\n//   const unvisitedNodes = getAllNodes(grid)\n//   const _stopNode = stopNode[0] ? stopNode[1] : [];\n//   var pos = 0\n//   while(pos < 2){\n//     console.log('here')\n//     var endBool = pos===0 && stopNode[0]\n//     var beginNode = pos===0 ? startNode : _stopNode\n//     if(pos===0){\n//       beginNode = startNode\n//     } else if(pos===1 && stopNode[0]){\n//       beginNode = _stopNode\n//     }\n//     var endNode = endBool ? _stopNode : finishNode\n//     if(pos===0 && stopNode[0]){\n//       endNode = _stopNode\n//     } else if(!stopNode[1]){\n//       endNode = finishNode\n//     }\n//     console.log(unvisitedNodes)\n//     unvisitedNodes.forEach((node) => {\n//       if(node === beginNode){\n//         node.distance = 0\n//       } else {\n//         node.distance = Infinity\n//       }\n//     })\n//     unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n//     console.log(unvisitedNodes, pos)\n//     while(!!unvisitedNodes){\n//         sortNodesByDistance(unvisitedNodes, endNode)\n//         const closestNode = unvisitedNodes.shift();\n//         if(closestNode.isWall) continue;\n//         console.log('hh', pos)\n//         if(closestNode.distance === Infinity) return visitedNodesInOrder;\n//         closestNode.isVisited = true;\n//         if(pos === 0){\n//           visitedNodesInOrder[0].push(closestNode)\n//         } else if(pos === 1){\n//           visitedNodesInOrder[1].push(closestNode)\n//         }\n//         console.log('jj', pos)\n//         if(closestNode === endNode && stopNode[0]){\n//           break;\n//         } else if(closestNode === endNode && !stopNode[0]){\n//           return visitedNodesInOrder\n//         }\n//         updateUnvisitedNeighbors(closestNode, grid);\n//     }\n//     pos++\n//   }\n// }\nexport function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);unvisitedNodes.forEach(function(node){if(node===startNode){node.distance=0;}else{node.distance=Infinity;}});while(!!unvisitedNodes){sortNodesByDistance(unvisitedNodes,finishNode);var closestNode=unvisitedNodes.shift();if(closestNode.isWall)continue;if(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){if(nodeA.isWeight){nodeA.distance+=1;}else if(nodeB.isWeight){nodeB.distance+=2;}return nodeA.distance-nodeB.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getAllNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode){var isStop=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){if(currentNode.isTarget===true)break;//console.log(currentNode, currentNode !== null)\nnodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/algorithims/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","forEach","node","Infinity","sortNodesByDistance","closestNode","shift","isWall","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","isWeight","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","length","filter","nodes","getNodesInShortestPathOrder","isStop","nodesInShortestPathOrder","currentNode","isTarget","unshift"],"mappings":"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","sourcesContent":["\n// export function dijkstra(grid, startNode, finishNode, stopNode){\n//   const visitedNodesInOrder = [[],[]];\n//   const unvisitedNodes = getAllNodes(grid)\n//   const _stopNode = stopNode[0] ? stopNode[1] : [];\n//   var pos = 0\n//   while(pos < 2){\n//     console.log('here')\n//     var endBool = pos===0 && stopNode[0]\n//     var beginNode = pos===0 ? startNode : _stopNode\n//     if(pos===0){\n//       beginNode = startNode\n//     } else if(pos===1 && stopNode[0]){\n//       beginNode = _stopNode\n//     }\n//     var endNode = endBool ? _stopNode : finishNode\n//     if(pos===0 && stopNode[0]){\n//       endNode = _stopNode\n//     } else if(!stopNode[1]){\n//       endNode = finishNode\n//     }\n//     console.log(unvisitedNodes)\n//     unvisitedNodes.forEach((node) => {\n//       if(node === beginNode){\n//         node.distance = 0\n//       } else {\n//         node.distance = Infinity\n//       }\n//     })\n//     unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n\n//     console.log(unvisitedNodes, pos)\n//     while(!!unvisitedNodes){\n  \n//         sortNodesByDistance(unvisitedNodes, endNode)\n//         const closestNode = unvisitedNodes.shift();\n\n//         if(closestNode.isWall) continue;\n//         console.log('hh', pos)\n//         if(closestNode.distance === Infinity) return visitedNodesInOrder;\n    \n//         closestNode.isVisited = true;\n//         if(pos === 0){\n//           visitedNodesInOrder[0].push(closestNode)\n//         } else if(pos === 1){\n//           visitedNodesInOrder[1].push(closestNode)\n//         }\n//         console.log('jj', pos)\n//         if(closestNode === endNode && stopNode[0]){\n//           break;\n//         } else if(closestNode === endNode && !stopNode[0]){\n//           return visitedNodesInOrder\n//         }\n//         updateUnvisitedNeighbors(closestNode, grid);\n//     }\n//     pos++\n//   }\n// }\n\nexport function dijkstra(grid, startNode, finishNode){\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid)\n  unvisitedNodes.forEach((node) => {\n    if(node === startNode){\n      node.distance = 0\n    } else {\n      node.distance = Infinity\n    }\n  })\n  while(!!unvisitedNodes){\n      sortNodesByDistance(unvisitedNodes, finishNode)\n      const closestNode = unvisitedNodes.shift();\n\n      if(closestNode.isWall) continue;\n\n      if(closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n\n      if(closestNode === finishNode) return visitedNodesInOrder;\n\n      updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => {\n      if(nodeA.isWeight){\n        nodeA.distance += 1\n      } else if(nodeB.isWeight){\n        nodeB.distance += 2\n      }\n      return nodeA.distance - nodeB.distance\n    });\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n}\n  \nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode, isStop=false) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      if(currentNode.isTarget===true) break;\n      //console.log(currentNode, currentNode !== null)\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"]},"metadata":{},"sourceType":"module"}