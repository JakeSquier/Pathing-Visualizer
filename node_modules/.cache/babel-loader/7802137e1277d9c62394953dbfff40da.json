{"ast":null,"code":"var self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n\n    function greedyBFS(grid, startNode, finishNode) {\n      let stopNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n      }\n\n      var isStop;\n\n      if (stopNode === false) {\n        isStop = false;\n      } else {\n        isStop = true;\n      }\n\n      if (!isStop) {\n        let unvisitedNodes = [];\n        let visitedNodesInOrder = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n\n          if (closestNode === finishNode) {\n            visitedNodesInOrder.push(closestNode);\n            return visitedNodesInOrder;\n          }\n\n          closestNode.isVisited = true;\n          visitedNodesInOrder.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        return visitedNodesInOrder;\n      } else if (isStop) {\n        let unvisitedNodes = [];\n        let unvisitedNodesSecond = [];\n        let firstSearch = [];\n        let secondSearch = [];\n        startNode.distance = 0;\n        unvisitedNodes.push(startNode);\n        unvisitedNodesSecond.push(stopNode);\n\n        while (unvisitedNodes.length !== 0) {\n          unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n          let closestNode = unvisitedNodes.shift();\n\n          if (closestNode === stopNode) {\n            firstSearch.push(closestNode);\n            break;\n          }\n\n          closestNode.isVisited = true;\n          firstSearch.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid, false);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distance + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n              unvisitedNodes.unshift(neighbour);\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNode;\n            } else if (distance < neighbour.distance) {\n              neighbour.distance = distance;\n              neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n              neighbour.previousNode = closestNode;\n            }\n          }\n        }\n\n        while (unvisitedNodesSecond.length !== 0) {\n          unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond);\n          let closestNode = unvisitedNodesSecond.shift();\n\n          if (closestNode === finishNode) {\n            secondSearch.push(closestNode);\n            break;\n          }\n\n          closestNode.isVisitedSecond = true;\n          secondSearch.push(closestNode);\n          let neighbours = getNeighbours(closestNode, grid, true);\n\n          for (let neighbour of neighbours) {\n            let distance = closestNode.distanceSecond + 1; //f(n) = h(n)\n\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n              unvisitedNodesSecond.unshift(neighbour);\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNodeSecond = closestNode;\n            } else if (distance < neighbour.distanceSecond) {\n              neighbour.distanceSecond = distance;\n              neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n              neighbour.previousNodeSecond = closestNode;\n            }\n          }\n        }\n\n        return [firstSearch, secondSearch];\n      }\n    }\n\n    function getNeighbours(node, grid, isStop) {\n      let neighbour = [];\n      let {\n        row,\n        col\n      } = node;\n\n      if (isStop) {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      } else {\n        if (row !== 0) neighbour.push(grid[row - 1][col]);\n        if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n        if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n        if (col !== 0) neighbour.push(grid[row][col - 1]);\n      }\n\n      return neighbour.filter(node => {\n        if (isStop) {\n          return !node.isWall && !node.isVisitedSecond;\n        } else {\n          return !node.isWall && !node.isVisited;\n        }\n      });\n    }\n\n    function manhattenDistance(node, finishNode) {\n      let x = Math.abs(node.row - finishNode.row);\n      let y = Math.abs(node.col - finishNode.col);\n      return x + y;\n    }\n\n    function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n      for (let node of unvisitedNodes) {\n        if (node.row === neighbour.row && node.col === neighbour.col) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    const grid = message.data[0];\n    const startNode = message.data[1];\n    const finishNode = message.data[2];\n    const stopNode = message.data[3];\n    const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode);\n    postMessage(visitedNodesInOrder);\n  });\n});\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["self","addEventListener","message","greedyBFS","grid","startNode","finishNode","stopNode","isStop","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","unvisitedNodesSecond","firstSearch","secondSearch","totalDistanceSecond","isVisitedSecond","distanceSecond","previousNodeSecond","node","row","col","filter","isWall","x","Math","abs","y","data","postMessage","getNodesInShortestPathOrderGreedyBFS","nodesInShortestPathOrder","currentNode"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/greedyBestFirstSearchWorker.js"],"sourcesContent":["var self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n        if (!message) return;\n\n        function greedyBFS(grid, startNode, finishNode, stopNode=false) {\n\n            if (!startNode || !finishNode || startNode === finishNode) {\n                return false;\n            }\n\n            var isStop;\n            if(stopNode===false){\n                isStop = false\n            } else {\n                isStop = true\n            }\n            if(!isStop){\n                let unvisitedNodes = [];\n                let visitedNodesInOrder = [];\n                startNode.distance = 0;\n                unvisitedNodes.push(startNode);\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n                  let closestNode = unvisitedNodes.shift();\n                  if (closestNode === finishNode) {\n                    visitedNodesInOrder.push(closestNode)\n                    return visitedNodesInOrder;\n                  }\n              \n                  closestNode.isVisited = true;\n                  visitedNodesInOrder.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid);\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour);\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance;\n                      neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNode = closestNode;\n                    }\n                  }\n                }\n                \n                return visitedNodesInOrder;\n\n            } else if(isStop){\n\n                let unvisitedNodes = []\n                let unvisitedNodesSecond = []\n                let firstSearch = []\n                let secondSearch = []\n                startNode.distance = 0\n                unvisitedNodes.push(startNode)\n                unvisitedNodesSecond.push(stopNode)\n              \n                while (unvisitedNodes.length !== 0) {\n                  unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance)\n                  let closestNode = unvisitedNodes.shift()\n                  if (closestNode === stopNode) {\n                    firstSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisited = true;\n                  firstSearch.push(closestNode);\n              \n                  let neighbours = getNeighbours(closestNode, grid, false)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distance + 1\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n                      unvisitedNodes.unshift(neighbour)\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    } else if (distance < neighbour.distance) {\n                      neighbour.distance = distance\n                      neighbour.totalDistance = manhattenDistance(neighbour, stopNode);\n                      neighbour.previousNode = closestNode\n                    }\n                  }\n                }\n\n                while (unvisitedNodesSecond.length !== 0) {\n                  unvisitedNodesSecond.sort((a, b) => a.totalDistanceSecond - b.totalDistanceSecond)\n                  let closestNode = unvisitedNodesSecond.shift()\n                  if (closestNode === finishNode) {\n                    secondSearch.push(closestNode)\n                    break\n                  }\n              \n                  closestNode.isVisitedSecond = true\n                  secondSearch.push(closestNode)\n              \n                  let neighbours = getNeighbours(closestNode, grid, true)\n                  for (let neighbour of neighbours) {\n                    let distance = closestNode.distanceSecond + 1;\n                    //f(n) = h(n)\n                    if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesSecond)) {\n                      unvisitedNodesSecond.unshift(neighbour)\n                      neighbour.distanceSecond = distance\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNodeSecond = closestNode\n                    } else if (distance < neighbour.distanceSecond) {\n                      neighbour.distanceSecond = distance;\n                      neighbour.totalDistanceSecond = manhattenDistance(neighbour, finishNode);\n                      neighbour.previousNodeSecond = closestNode;\n                    }\n                  }\n                }\n\n                return [firstSearch, secondSearch]\n            }\n        }\n\n        function getNeighbours(node, grid, isStop) {\n            let neighbour = [];\n            let { row, col } = node;\n            \n            if(isStop) {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            } else {\n                if (row !== 0) neighbour.push(grid[row - 1][col]);\n                if (col !== grid[0].length - 1) neighbour.push(grid[row][col + 1]);\n                if (row !== grid.length - 1) neighbour.push(grid[row + 1][col]);\n                if (col !== 0) neighbour.push(grid[row][col - 1]);\n            }\n            return neighbour.filter(\n              (node) => {\n                  if(isStop){\n                    return !node.isWall && !node.isVisitedSecond\n                  } else {\n                    return !node.isWall && !node.isVisited\n                  }\n                }\n            );\n        }\n\n        function manhattenDistance(node, finishNode) {\n            let x = Math.abs(node.row - finishNode.row);\n            let y = Math.abs(node.col - finishNode.col);\n            return x + y;\n        }\n\n        function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n            for (let node of unvisitedNodes) {\n              if (node.row === neighbour.row && node.col === neighbour.col) {\n                return false;\n              }\n            }\n            return true;\n        }\n\n        const grid = message.data[0]\n        const startNode = message.data[1]\n        const finishNode = message.data[2]\n        const stopNode = message.data[3]\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, stopNode)\n\n        postMessage(visitedNodesInOrder)\n    })\n}\n\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}