{"ast":null,"code":"// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default (() => {\n  // eslint-disable-line no-restricted-globals\n  self.addEventListener(\"message\", message => {\n    if (!message) return;\n    var stopNode = false,\n        finishNode = false,\n        startNode = false;\n    const stop = message.data[1];\n    const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0];\n    nodes.map(node => {\n      if (node.isStop === true) stopNode = node;\n      if (node.isFinish === true) finishNode = node;\n      if (node.isStart === true) startNode = node;\n    });\n    var nodesInShortestPathOrder = [];\n\n    if (!stop) {\n      if (finishNode === false) postMessage(false);\n      let currentNode = finishNode;\n\n      while (currentNode !== null) {\n        if (currentNode.isStart === true) break;\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n      }\n\n      if (!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode);\n      postMessage(nodesInShortestPathOrder);\n    } else if (stop) {\n      postMessage([startNode]);\n      var startToStop = [],\n          stopToFinish = [];\n      let currentNodeFin = finishNode;\n      let currentNodeStop = stopNode;\n      var pathStart = false,\n          pathFinish = false;\n      message.data[0].map(node => {\n        if (node.isStop) pathStart = true;\n      });\n      message.data[1].map(node => {\n        if (node.isFinish) pathFinish = true;\n      });\n\n      while (currentNodeFin !== null && pathFinish) {\n        if (currentNodeFin.isStop === true) break;\n        stopToFinish.unshift(currentNodeFin);\n        currentNodeFin = currentNodeFin.previousNodeSecond;\n      }\n\n      while (currentNodeStop !== null && pathStart) {\n        if (currentNodeStop.isStart === true) break;\n        startToStop.unshift(currentNodeStop);\n        currentNodeStop = currentNodeStop.previousNode;\n      }\n\n      if (!startToStop[0].isStart && pathStart) startToStop.unshift(startNode);\n      postMessage([...startToStop, ...stopToFinish]);\n    }\n  });\n});","map":{"version":3,"names":["self","addEventListener","message","stopNode","finishNode","startNode","stop","data","nodes","map","node","isStop","isFinish","isStart","nodesInShortestPathOrder","postMessage","currentNode","unshift","previousNode","startToStop","stopToFinish","currentNodeFin","currentNodeStop","pathStart","pathFinish","previousNodeSecond"],"sources":["/Users/Jake.Squier/SE-Projects/pathing-visualizer/pathing-visualizer/src/workers/pathGrabWorker.js"],"sourcesContent":["// eslint-disable-next-line import/no-anonymous-default-export\nvar self = this;\nexport default () => {\n    // eslint-disable-line no-restricted-globals\n    self.addEventListener(\"message\", message => {\n\n        if (!message) return;\n\n        var stopNode=false, finishNode=false, startNode=false\n\n        const stop = message.data[1]\n        const nodes = stop ? [...message.data[0][0], ...message.data[0][1]] : message.data[0]\n\n        nodes.map((node) => {\n\n            if(node.isStop === true) stopNode = node\n\n            if(node.isFinish === true) finishNode = node\n\n            if(node.isStart === true) startNode = node\n\n        })\n\n        var nodesInShortestPathOrder = [];\n\n        if(!stop) {\n\n            if(finishNode === false) postMessage(false)\n\n            let currentNode = finishNode\n\n            while (currentNode !== null) {\n\n                if(currentNode.isStart===true) break;\n\n                nodesInShortestPathOrder.unshift(currentNode);\n\n                currentNode = currentNode.previousNode;\n            }\n\n            if(!nodesInShortestPathOrder[0].isStart) nodesInShortestPathOrder.unshift(startNode)\n\n            postMessage(nodesInShortestPathOrder)\n\n        } else if(stop) {\n\n            postMessage([startNode])\n\n            var startToStop=[], stopToFinish=[]\n            let currentNodeFin = finishNode\n            let currentNodeStop = stopNode\n            var pathStart=false, pathFinish=false\n\n            message.data[0].map((node) => {\n                if(node.isStop) pathStart = true\n            })\n\n            message.data[1].map((node) => {\n                if(node.isFinish) pathFinish = true\n            })\n\n            while (currentNodeFin !== null && pathFinish) {\n\n                if(currentNodeFin.isStop===true) break;\n\n                stopToFinish.unshift(currentNodeFin);\n\n                currentNodeFin = currentNodeFin.previousNodeSecond;\n            }\n\n            while (currentNodeStop !== null && pathStart) {\n\n                if(currentNodeStop.isStart===true) break;\n\n                startToStop.unshift(currentNodeStop);\n\n                currentNodeStop = currentNodeStop.previousNode;\n            }\n\n            if(!startToStop[0].isStart && pathStart) startToStop.unshift(startNode)\n\n            postMessage([...startToStop, ...stopToFinish])\n        }\n    })\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}